<!DOCTYPE html>
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<title>libtorrent</title>
<meta name="description" content="A feature complete BitTorrent protocol implementation as a C++ library">
<meta name=viewport content="width=device-width, initial-scale=1">
<meta property="og:image" content="img/logo-color.png" />
<meta property="og:site_name" content="libtorrent" />
<link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body>
<div class="document">
    <div id="container">
    <a href="index.html">
    <img src="img/logo-color-text.png" alt="libtorrent logo"/>
    </a>
    <div>

<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Version:</th>
<td>2.0.11</td></tr>
</tbody>
</table>
<p><a class="reference external" href="reference.html">home</a></p>
<div class="contents topic" id="table-of-contents">
<p class="topic-title">Table of contents</p>
<ul class="simple">
<li><a class="reference internal" href="#disk-observer" id="toc-entry-1">disk_observer</a><ul>
<li><a class="reference internal" href="#on-disk" id="toc-entry-2">on_disk()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#buffer-allocator-interface" id="toc-entry-3">buffer_allocator_interface</a></li>
<li><a class="reference internal" href="#disk-buffer-holder" id="toc-entry-4">disk_buffer_holder</a><ul>
<li><a class="reference internal" href="#disk-buffer-holder-1" id="toc-entry-5">disk_buffer_holder()</a></li>
<li><a class="reference internal" href="#disk-buffer-holder-2" id="toc-entry-6">disk_buffer_holder()</a></li>
<li><a class="reference internal" href="#disk-buffer-holder-3" id="toc-entry-7">~disk_buffer_holder()</a></li>
<li><a class="reference internal" href="#data" id="toc-entry-8">data()</a></li>
<li><a class="reference internal" href="#reset" id="toc-entry-9">reset()</a></li>
<li><a class="reference internal" href="#swap" id="toc-entry-10">swap()</a></li>
<li><a class="reference internal" href="#is-mutable" id="toc-entry-11">is_mutable()</a></li>
<li><a class="reference internal" href="#bool" id="toc-entry-12">bool()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#settings-interface" id="toc-entry-13">settings_interface</a></li>
<li><a class="reference internal" href="#open-file-state" id="toc-entry-14">open_file_state</a></li>
<li><a class="reference internal" href="#disk-interface" id="toc-entry-15">disk_interface</a><ul>
<li><a class="reference internal" href="#new-torrent" id="toc-entry-16">new_torrent()</a></li>
<li><a class="reference internal" href="#remove-torrent" id="toc-entry-17">remove_torrent()</a></li>
<li><a class="reference internal" href="#async-read-async-write" id="toc-entry-18">async_read() async_write()</a></li>
<li><a class="reference internal" href="#async-hash" id="toc-entry-19">async_hash()</a></li>
<li><a class="reference internal" href="#async-hash2" id="toc-entry-20">async_hash2()</a></li>
<li><a class="reference internal" href="#async-move-storage" id="toc-entry-21">async_move_storage()</a></li>
<li><a class="reference internal" href="#async-release-files" id="toc-entry-22">async_release_files()</a></li>
<li><a class="reference internal" href="#async-check-files" id="toc-entry-23">async_check_files()</a></li>
<li><a class="reference internal" href="#async-stop-torrent" id="toc-entry-24">async_stop_torrent()</a></li>
<li><a class="reference internal" href="#async-rename-file" id="toc-entry-25">async_rename_file()</a></li>
<li><a class="reference internal" href="#async-delete-files" id="toc-entry-26">async_delete_files()</a></li>
<li><a class="reference internal" href="#async-set-file-priority" id="toc-entry-27">async_set_file_priority()</a></li>
<li><a class="reference internal" href="#async-clear-piece" id="toc-entry-28">async_clear_piece()</a></li>
<li><a class="reference internal" href="#update-stats-counters" id="toc-entry-29">update_stats_counters()</a></li>
<li><a class="reference internal" href="#get-status" id="toc-entry-30">get_status()</a></li>
<li><a class="reference internal" href="#abort" id="toc-entry-31">abort()</a></li>
<li><a class="reference internal" href="#submit-jobs" id="toc-entry-32">submit_jobs()</a></li>
<li><a class="reference internal" href="#settings-updated" id="toc-entry-33">settings_updated()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#storage-holder" id="toc-entry-34">storage_holder</a></li>
<li><a class="reference internal" href="#file-open-mode-t" id="toc-entry-35">file_open_mode_t</a></li>
<li><a class="reference internal" href="#dht-routing-bucket" id="toc-entry-36">dht_routing_bucket</a></li>
<li><a class="reference internal" href="#torrent-alert" id="toc-entry-37">torrent_alert</a><ul>
<li><a class="reference internal" href="#message" id="toc-entry-38">message()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#peer-alert" id="toc-entry-39">peer_alert</a></li>
<li><a class="reference internal" href="#tracker-alert" id="toc-entry-40">tracker_alert</a><ul>
<li><a class="reference internal" href="#tracker-url" id="toc-entry-41">tracker_url()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#torrent-removed-alert" id="toc-entry-42">torrent_removed_alert</a></li>
<li><a class="reference internal" href="#read-piece-alert" id="toc-entry-43">read_piece_alert</a></li>
<li><a class="reference internal" href="#file-completed-alert" id="toc-entry-44">file_completed_alert</a></li>
<li><a class="reference internal" href="#file-renamed-alert" id="toc-entry-45">file_renamed_alert</a><ul>
<li><a class="reference internal" href="#new-name-old-name" id="toc-entry-46">new_name() old_name()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#file-rename-failed-alert" id="toc-entry-47">file_rename_failed_alert</a></li>
<li><a class="reference internal" href="#performance-alert" id="toc-entry-48">performance_alert</a><ul>
<li><a class="reference internal" href="#enum-performance-warning-t" id="toc-entry-49">enum performance_warning_t</a></li>
</ul>
</li>
<li><a class="reference internal" href="#state-changed-alert" id="toc-entry-50">state_changed_alert</a></li>
<li><a class="reference internal" href="#tracker-error-alert" id="toc-entry-51">tracker_error_alert</a><ul>
<li><a class="reference internal" href="#failure-reason" id="toc-entry-52">failure_reason()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#tracker-warning-alert" id="toc-entry-53">tracker_warning_alert</a><ul>
<li><a class="reference internal" href="#warning-message" id="toc-entry-54">warning_message()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#scrape-reply-alert" id="toc-entry-55">scrape_reply_alert</a></li>
<li><a class="reference internal" href="#scrape-failed-alert" id="toc-entry-56">scrape_failed_alert</a><ul>
<li><a class="reference internal" href="#error-message" id="toc-entry-57">error_message()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#tracker-reply-alert" id="toc-entry-58">tracker_reply_alert</a></li>
<li><a class="reference internal" href="#dht-reply-alert" id="toc-entry-59">dht_reply_alert</a></li>
<li><a class="reference internal" href="#tracker-announce-alert" id="toc-entry-60">tracker_announce_alert</a></li>
<li><a class="reference internal" href="#hash-failed-alert" id="toc-entry-61">hash_failed_alert</a></li>
<li><a class="reference internal" href="#peer-ban-alert" id="toc-entry-62">peer_ban_alert</a></li>
<li><a class="reference internal" href="#peer-unsnubbed-alert" id="toc-entry-63">peer_unsnubbed_alert</a></li>
<li><a class="reference internal" href="#peer-snubbed-alert" id="toc-entry-64">peer_snubbed_alert</a></li>
<li><a class="reference internal" href="#peer-error-alert" id="toc-entry-65">peer_error_alert</a></li>
<li><a class="reference internal" href="#peer-connect-alert" id="toc-entry-66">peer_connect_alert</a><ul>
<li><a class="reference internal" href="#enum-direction-t" id="toc-entry-67">enum direction_t</a></li>
</ul>
</li>
<li><a class="reference internal" href="#peer-disconnected-alert" id="toc-entry-68">peer_disconnected_alert</a></li>
<li><a class="reference internal" href="#invalid-request-alert" id="toc-entry-69">invalid_request_alert</a></li>
<li><a class="reference internal" href="#torrent-finished-alert" id="toc-entry-70">torrent_finished_alert</a></li>
<li><a class="reference internal" href="#piece-finished-alert" id="toc-entry-71">piece_finished_alert</a></li>
<li><a class="reference internal" href="#request-dropped-alert" id="toc-entry-72">request_dropped_alert</a></li>
<li><a class="reference internal" href="#block-timeout-alert" id="toc-entry-73">block_timeout_alert</a></li>
<li><a class="reference internal" href="#block-finished-alert" id="toc-entry-74">block_finished_alert</a></li>
<li><a class="reference internal" href="#block-downloading-alert" id="toc-entry-75">block_downloading_alert</a></li>
<li><a class="reference internal" href="#unwanted-block-alert" id="toc-entry-76">unwanted_block_alert</a></li>
<li><a class="reference internal" href="#storage-moved-alert" id="toc-entry-77">storage_moved_alert</a><ul>
<li><a class="reference internal" href="#old-path-storage-path" id="toc-entry-78">old_path() storage_path()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#storage-moved-failed-alert" id="toc-entry-79">storage_moved_failed_alert</a><ul>
<li><a class="reference internal" href="#file-path" id="toc-entry-80">file_path()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#torrent-deleted-alert" id="toc-entry-81">torrent_deleted_alert</a></li>
<li><a class="reference internal" href="#torrent-delete-failed-alert" id="toc-entry-82">torrent_delete_failed_alert</a></li>
<li><a class="reference internal" href="#save-resume-data-alert" id="toc-entry-83">save_resume_data_alert</a></li>
<li><a class="reference internal" href="#save-resume-data-failed-alert" id="toc-entry-84">save_resume_data_failed_alert</a></li>
<li><a class="reference internal" href="#torrent-paused-alert" id="toc-entry-85">torrent_paused_alert</a></li>
<li><a class="reference internal" href="#torrent-resumed-alert" id="toc-entry-86">torrent_resumed_alert</a></li>
<li><a class="reference internal" href="#torrent-checked-alert" id="toc-entry-87">torrent_checked_alert</a></li>
<li><a class="reference internal" href="#url-seed-alert" id="toc-entry-88">url_seed_alert</a><ul>
<li><a class="reference internal" href="#server-url" id="toc-entry-89">server_url()</a></li>
<li><a class="reference internal" href="#error-message-1" id="toc-entry-90">error_message()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#file-error-alert" id="toc-entry-91">file_error_alert</a><ul>
<li><a class="reference internal" href="#filename" id="toc-entry-92">filename()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#metadata-failed-alert" id="toc-entry-93">metadata_failed_alert</a></li>
<li><a class="reference internal" href="#metadata-received-alert" id="toc-entry-94">metadata_received_alert</a></li>
<li><a class="reference internal" href="#udp-error-alert" id="toc-entry-95">udp_error_alert</a></li>
<li><a class="reference internal" href="#external-ip-alert" id="toc-entry-96">external_ip_alert</a></li>
<li><a class="reference internal" href="#listen-failed-alert" id="toc-entry-97">listen_failed_alert</a><ul>
<li><a class="reference internal" href="#listen-interface" id="toc-entry-98">listen_interface()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#listen-succeeded-alert" id="toc-entry-99">listen_succeeded_alert</a></li>
<li><a class="reference internal" href="#portmap-error-alert" id="toc-entry-100">portmap_error_alert</a></li>
<li><a class="reference internal" href="#portmap-alert" id="toc-entry-101">portmap_alert</a></li>
<li><a class="reference internal" href="#portmap-log-alert" id="toc-entry-102">portmap_log_alert</a><ul>
<li><a class="reference internal" href="#log-message" id="toc-entry-103">log_message()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#fastresume-rejected-alert" id="toc-entry-104">fastresume_rejected_alert</a><ul>
<li><a class="reference internal" href="#file-path-1" id="toc-entry-105">file_path()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#peer-blocked-alert" id="toc-entry-106">peer_blocked_alert</a><ul>
<li><a class="reference internal" href="#enum-reason-t" id="toc-entry-107">enum reason_t</a></li>
</ul>
</li>
<li><a class="reference internal" href="#dht-announce-alert" id="toc-entry-108">dht_announce_alert</a></li>
<li><a class="reference internal" href="#dht-get-peers-alert" id="toc-entry-109">dht_get_peers_alert</a></li>
<li><a class="reference internal" href="#cache-flushed-alert" id="toc-entry-110">cache_flushed_alert</a></li>
<li><a class="reference internal" href="#lsd-peer-alert" id="toc-entry-111">lsd_peer_alert</a></li>
<li><a class="reference internal" href="#trackerid-alert" id="toc-entry-112">trackerid_alert</a><ul>
<li><a class="reference internal" href="#tracker-id" id="toc-entry-113">tracker_id()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#dht-bootstrap-alert" id="toc-entry-114">dht_bootstrap_alert</a></li>
<li><a class="reference internal" href="#torrent-error-alert" id="toc-entry-115">torrent_error_alert</a><ul>
<li><a class="reference internal" href="#filename-1" id="toc-entry-116">filename()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#torrent-need-cert-alert" id="toc-entry-117">torrent_need_cert_alert</a></li>
<li><a class="reference internal" href="#incoming-connection-alert" id="toc-entry-118">incoming_connection_alert</a></li>
<li><a class="reference internal" href="#add-torrent-alert" id="toc-entry-119">add_torrent_alert</a></li>
<li><a class="reference internal" href="#state-update-alert" id="toc-entry-120">state_update_alert</a></li>
<li><a class="reference internal" href="#session-stats-alert" id="toc-entry-121">session_stats_alert</a><ul>
<li><a class="reference internal" href="#counters" id="toc-entry-122">counters()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#dht-error-alert" id="toc-entry-123">dht_error_alert</a></li>
<li><a class="reference internal" href="#dht-immutable-item-alert" id="toc-entry-124">dht_immutable_item_alert</a></li>
<li><a class="reference internal" href="#dht-mutable-item-alert" id="toc-entry-125">dht_mutable_item_alert</a></li>
<li><a class="reference internal" href="#dht-put-alert" id="toc-entry-126">dht_put_alert</a></li>
<li><a class="reference internal" href="#i2p-alert" id="toc-entry-127">i2p_alert</a></li>
<li><a class="reference internal" href="#dht-outgoing-get-peers-alert" id="toc-entry-128">dht_outgoing_get_peers_alert</a></li>
<li><a class="reference internal" href="#log-alert" id="toc-entry-129">log_alert</a><ul>
<li><a class="reference internal" href="#log-message-1" id="toc-entry-130">log_message()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#torrent-log-alert" id="toc-entry-131">torrent_log_alert</a><ul>
<li><a class="reference internal" href="#log-message-2" id="toc-entry-132">log_message()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#peer-log-alert" id="toc-entry-133">peer_log_alert</a><ul>
<li><a class="reference internal" href="#log-message-3" id="toc-entry-134">log_message()</a></li>
<li><a class="reference internal" href="#enum-direction-t-1" id="toc-entry-135">enum direction_t</a></li>
</ul>
</li>
<li><a class="reference internal" href="#lsd-error-alert" id="toc-entry-136">lsd_error_alert</a></li>
<li><a class="reference internal" href="#dht-lookup" id="toc-entry-137">dht_lookup</a></li>
<li><a class="reference internal" href="#dht-stats-alert" id="toc-entry-138">dht_stats_alert</a></li>
<li><a class="reference internal" href="#incoming-request-alert" id="toc-entry-139">incoming_request_alert</a></li>
<li><a class="reference internal" href="#dht-log-alert" id="toc-entry-140">dht_log_alert</a><ul>
<li><a class="reference internal" href="#log-message-4" id="toc-entry-141">log_message()</a></li>
<li><a class="reference internal" href="#enum-dht-module-t" id="toc-entry-142">enum dht_module_t</a></li>
</ul>
</li>
<li><a class="reference internal" href="#dht-pkt-alert" id="toc-entry-143">dht_pkt_alert</a><ul>
<li><a class="reference internal" href="#pkt-buf" id="toc-entry-144">pkt_buf()</a></li>
<li><a class="reference internal" href="#enum-direction-t-2" id="toc-entry-145">enum direction_t</a></li>
</ul>
</li>
<li><a class="reference internal" href="#dht-get-peers-reply-alert" id="toc-entry-146">dht_get_peers_reply_alert</a></li>
<li><a class="reference internal" href="#dht-direct-response-alert" id="toc-entry-147">dht_direct_response_alert</a></li>
<li><a class="reference internal" href="#picker-log-alert" id="toc-entry-148">picker_log_alert</a></li>
<li><a class="reference internal" href="#session-error-alert" id="toc-entry-149">session_error_alert</a></li>
<li><a class="reference internal" href="#dht-live-nodes-alert" id="toc-entry-150">dht_live_nodes_alert</a><ul>
<li><a class="reference internal" href="#nodes-num-nodes" id="toc-entry-151">nodes() num_nodes()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#session-stats-header-alert" id="toc-entry-152">session_stats_header_alert</a></li>
<li><a class="reference internal" href="#dht-sample-infohashes-alert" id="toc-entry-153">dht_sample_infohashes_alert</a><ul>
<li><a class="reference internal" href="#num-samples-samples" id="toc-entry-154">num_samples() samples()</a></li>
<li><a class="reference internal" href="#num-nodes" id="toc-entry-155">num_nodes()</a></li>
<li><a class="reference internal" href="#nodes" id="toc-entry-156">nodes()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#block-uploaded-alert" id="toc-entry-157">block_uploaded_alert</a></li>
<li><a class="reference internal" href="#alerts-dropped-alert" id="toc-entry-158">alerts_dropped_alert</a></li>
<li><a class="reference internal" href="#socks5-alert" id="toc-entry-159">socks5_alert</a></li>
<li><a class="reference internal" href="#file-prio-alert" id="toc-entry-160">file_prio_alert</a></li>
<li><a class="reference internal" href="#oversized-file-alert" id="toc-entry-161">oversized_file_alert</a></li>
<li><a class="reference internal" href="#torrent-conflict-alert" id="toc-entry-162">torrent_conflict_alert</a></li>
<li><a class="reference internal" href="#peer-info-alert" id="toc-entry-163">peer_info_alert</a></li>
<li><a class="reference internal" href="#file-progress-alert" id="toc-entry-164">file_progress_alert</a></li>
<li><a class="reference internal" href="#piece-info-alert" id="toc-entry-165">piece_info_alert</a></li>
<li><a class="reference internal" href="#piece-availability-alert" id="toc-entry-166">piece_availability_alert</a></li>
<li><a class="reference internal" href="#tracker-list-alert" id="toc-entry-167">tracker_list_alert</a></li>
<li><a class="reference internal" href="#alert" id="toc-entry-168">alert</a><ul>
<li><a class="reference internal" href="#timestamp" id="toc-entry-169">timestamp()</a></li>
<li><a class="reference internal" href="#type" id="toc-entry-170">type()</a></li>
<li><a class="reference internal" href="#what" id="toc-entry-171">what()</a></li>
<li><a class="reference internal" href="#message-1" id="toc-entry-172">message()</a></li>
<li><a class="reference internal" href="#category" id="toc-entry-173">category()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#alert-cast" id="toc-entry-174">alert_cast()</a></li>
<li><a class="reference internal" href="#operation-name" id="toc-entry-175">operation_name()</a></li>
<li><a class="reference internal" href="#enum-operation-t" id="toc-entry-176">enum operation_t</a></li>
<li><a class="reference internal" href="#int" id="toc-entry-177">int</a></li>
<li><a class="reference internal" href="#alert-category-t" id="toc-entry-178">alert_category_t</a></li>
<li><a class="reference internal" href="#hasher" id="toc-entry-179">hasher</a><ul>
<li><a class="reference internal" href="#operator-hasher" id="toc-entry-180">operator=() hasher()</a></li>
<li><a class="reference internal" href="#update" id="toc-entry-181">update()</a></li>
<li><a class="reference internal" href="#final" id="toc-entry-182">final()</a></li>
<li><a class="reference internal" href="#reset-1" id="toc-entry-183">reset()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#hasher256" id="toc-entry-184">hasher256</a><ul>
<li><a class="reference internal" href="#operator-hasher256" id="toc-entry-185">operator=() hasher256()</a></li>
<li><a class="reference internal" href="#update-1" id="toc-entry-186">update()</a></li>
<li><a class="reference internal" href="#final-1" id="toc-entry-187">final()</a></li>
<li><a class="reference internal" href="#reset-2" id="toc-entry-188">reset()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#bitfield" id="toc-entry-189">bitfield</a><ul>
<li><a class="reference internal" href="#bitfield-1" id="toc-entry-190">bitfield()</a></li>
<li><a class="reference internal" href="#assign" id="toc-entry-191">assign()</a></li>
<li><a class="reference internal" href="#operator-get-bit" id="toc-entry-192">operator[]() get_bit()</a></li>
<li><a class="reference internal" href="#set-bit-clear-bit" id="toc-entry-193">set_bit() clear_bit()</a></li>
<li><a class="reference internal" href="#all-set" id="toc-entry-194">all_set()</a></li>
<li><a class="reference internal" href="#none-set" id="toc-entry-195">none_set()</a></li>
<li><a class="reference internal" href="#size" id="toc-entry-196">size()</a></li>
<li><a class="reference internal" href="#num-words" id="toc-entry-197">num_words()</a></li>
<li><a class="reference internal" href="#num-bytes" id="toc-entry-198">num_bytes()</a></li>
<li><a class="reference internal" href="#empty" id="toc-entry-199">empty()</a></li>
<li><a class="reference internal" href="#data-1" id="toc-entry-200">data()</a></li>
<li><a class="reference internal" href="#swap-1" id="toc-entry-201">swap()</a></li>
<li><a class="reference internal" href="#count" id="toc-entry-202">count()</a></li>
<li><a class="reference internal" href="#find-first-set" id="toc-entry-203">find_first_set()</a></li>
<li><a class="reference internal" href="#find-last-clear" id="toc-entry-204">find_last_clear()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#a-word-of-caution" id="toc-entry-205">a word of caution</a></li>
<li><a class="reference internal" href="#plugin-interface" id="toc-entry-206">plugin-interface</a></li>
<li><a class="reference internal" href="#custom-alerts" id="toc-entry-207">custom alerts</a></li>
<li><a class="reference internal" href="#peer-connection-handle" id="toc-entry-208">peer_connection_handle</a></li>
<li><a class="reference internal" href="#bt-peer-connection-handle" id="toc-entry-209">bt_peer_connection_handle</a></li>
<li><a class="reference internal" href="#plugin" id="toc-entry-210">plugin</a><ul>
<li><a class="reference internal" href="#implemented-features" id="toc-entry-211">implemented_features()</a></li>
<li><a class="reference internal" href="#new-torrent-1" id="toc-entry-212">new_torrent()</a></li>
<li><a class="reference internal" href="#added" id="toc-entry-213">added()</a></li>
<li><a class="reference internal" href="#abort-1" id="toc-entry-214">abort()</a></li>
<li><a class="reference internal" href="#on-dht-request" id="toc-entry-215">on_dht_request()</a></li>
<li><a class="reference internal" href="#on-alert" id="toc-entry-216">on_alert()</a></li>
<li><a class="reference internal" href="#on-unknown-torrent" id="toc-entry-217">on_unknown_torrent()</a></li>
<li><a class="reference internal" href="#on-tick" id="toc-entry-218">on_tick()</a></li>
<li><a class="reference internal" href="#get-unchoke-priority" id="toc-entry-219">get_unchoke_priority()</a></li>
<li><a class="reference internal" href="#load-state" id="toc-entry-220">load_state()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#torrent-plugin" id="toc-entry-221">torrent_plugin</a><ul>
<li><a class="reference internal" href="#new-connection" id="toc-entry-222">new_connection()</a></li>
<li><a class="reference internal" href="#on-piece-pass-on-piece-failed" id="toc-entry-223">on_piece_pass() on_piece_failed()</a></li>
<li><a class="reference internal" href="#tick" id="toc-entry-224">tick()</a></li>
<li><a class="reference internal" href="#on-resume-on-pause" id="toc-entry-225">on_resume() on_pause()</a></li>
<li><a class="reference internal" href="#on-files-checked" id="toc-entry-226">on_files_checked()</a></li>
<li><a class="reference internal" href="#on-state" id="toc-entry-227">on_state()</a></li>
<li><a class="reference internal" href="#on-add-peer" id="toc-entry-228">on_add_peer()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#peer-plugin" id="toc-entry-229">peer_plugin</a><ul>
<li><a class="reference internal" href="#type-1" id="toc-entry-230">type()</a></li>
<li><a class="reference internal" href="#add-handshake" id="toc-entry-231">add_handshake()</a></li>
<li><a class="reference internal" href="#on-disconnect" id="toc-entry-232">on_disconnect()</a></li>
<li><a class="reference internal" href="#on-connected" id="toc-entry-233">on_connected()</a></li>
<li><a class="reference internal" href="#on-handshake" id="toc-entry-234">on_handshake()</a></li>
<li><a class="reference internal" href="#on-extension-handshake" id="toc-entry-235">on_extension_handshake()</a></li>
<li><a class="reference internal" href="#on-interested-on-have-all-on-not-interested-on-have-none-on-dont-have-on-allowed-fast-on-unchoke-on-bitfield-on-have-on-request-on-choke" id="toc-entry-236">on_interested() on_have_all() on_not_interested() on_have_none() on_dont_have() on_allowed_fast() on_unchoke() on_bitfield() on_have() on_request() on_choke()</a></li>
<li><a class="reference internal" href="#on-piece" id="toc-entry-237">on_piece()</a></li>
<li><a class="reference internal" href="#sent-not-interested-sent-unchoke-sent-have-sent-piece-sent-interested" id="toc-entry-238">sent_not_interested() sent_unchoke() sent_have() sent_piece() sent_interested()</a></li>
<li><a class="reference internal" href="#sent-payload" id="toc-entry-239">sent_payload()</a></li>
<li><a class="reference internal" href="#can-disconnect" id="toc-entry-240">can_disconnect()</a></li>
<li><a class="reference internal" href="#on-extended" id="toc-entry-241">on_extended()</a></li>
<li><a class="reference internal" href="#on-unknown-message" id="toc-entry-242">on_unknown_message()</a></li>
<li><a class="reference internal" href="#on-piece-pass-on-piece-failed-1" id="toc-entry-243">on_piece_pass() on_piece_failed()</a></li>
<li><a class="reference internal" href="#tick-1" id="toc-entry-244">tick()</a></li>
<li><a class="reference internal" href="#write-request" id="toc-entry-245">write_request()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#crypto-plugin" id="toc-entry-246">crypto_plugin</a><ul>
<li><a class="reference internal" href="#decrypt" id="toc-entry-247">decrypt()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#create-smart-ban-plugin" id="toc-entry-248">create_smart_ban_plugin()</a></li>
<li><a class="reference internal" href="#create-ut-pex-plugin" id="toc-entry-249">create_ut_pex_plugin()</a></li>
<li><a class="reference internal" href="#create-ut-metadata-plugin" id="toc-entry-250">create_ut_metadata_plugin()</a></li>
<li><a class="reference internal" href="#block-info" id="toc-entry-251">block_info</a><ul>
<li><a class="reference internal" href="#peer-set-peer" id="toc-entry-252">peer() set_peer()</a></li>
<li><a class="reference internal" href="#enum-block-state-t" id="toc-entry-253">enum block_state_t</a></li>
</ul>
</li>
<li><a class="reference internal" href="#partial-piece-info" id="toc-entry-254">partial_piece_info</a></li>
<li><a class="reference internal" href="#torrent-handle" id="toc-entry-255">torrent_handle</a><ul>
<li><a class="reference internal" href="#torrent-handle-1" id="toc-entry-256">torrent_handle()</a></li>
<li><a class="reference internal" href="#add-piece" id="toc-entry-257">add_piece()</a></li>
<li><a class="reference internal" href="#read-piece" id="toc-entry-258">read_piece()</a></li>
<li><a class="reference internal" href="#have-piece" id="toc-entry-259">have_piece()</a></li>
<li><a class="reference internal" href="#post-peer-info-get-peer-info" id="toc-entry-260">post_peer_info() get_peer_info()</a></li>
<li><a class="reference internal" href="#post-status-status" id="toc-entry-261">post_status() status()</a></li>
<li><a class="reference internal" href="#post-download-queue-get-download-queue" id="toc-entry-262">post_download_queue() get_download_queue()</a></li>
<li><a class="reference internal" href="#clear-piece-deadlines-reset-piece-deadline-set-piece-deadline" id="toc-entry-263">clear_piece_deadlines() reset_piece_deadline() set_piece_deadline()</a></li>
<li><a class="reference internal" href="#post-file-progress-file-progress" id="toc-entry-264">post_file_progress() file_progress()</a></li>
<li><a class="reference internal" href="#file-status" id="toc-entry-265">file_status()</a></li>
<li><a class="reference internal" href="#clear-error" id="toc-entry-266">clear_error()</a></li>
<li><a class="reference internal" href="#trackers-replace-trackers-post-trackers-add-tracker" id="toc-entry-267">trackers() replace_trackers() post_trackers() add_tracker()</a></li>
<li><a class="reference internal" href="#add-url-seed-remove-url-seed-url-seeds" id="toc-entry-268">add_url_seed() remove_url_seed() url_seeds()</a></li>
<li><a class="reference internal" href="#remove-http-seed-add-http-seed-http-seeds" id="toc-entry-269">remove_http_seed() add_http_seed() http_seeds()</a></li>
<li><a class="reference internal" href="#add-extension" id="toc-entry-270">add_extension()</a></li>
<li><a class="reference internal" href="#set-metadata" id="toc-entry-271">set_metadata()</a></li>
<li><a class="reference internal" href="#is-valid" id="toc-entry-272">is_valid()</a></li>
<li><a class="reference internal" href="#resume-pause" id="toc-entry-273">resume() pause()</a></li>
<li><a class="reference internal" href="#unset-flags-set-flags-flags" id="toc-entry-274">unset_flags() set_flags() flags()</a></li>
<li><a class="reference internal" href="#flush-cache" id="toc-entry-275">flush_cache()</a></li>
<li><a class="reference internal" href="#force-recheck" id="toc-entry-276">force_recheck()</a></li>
<li><a class="reference internal" href="#save-resume-data" id="toc-entry-277">save_resume_data()</a></li>
<li><a class="reference internal" href="#need-save-resume-data" id="toc-entry-278">need_save_resume_data()</a></li>
<li><a class="reference internal" href="#queue-position-bottom-queue-position-top-queue-position-down-queue-position-queue-position-up" id="toc-entry-279">queue_position_bottom() queue_position_top() queue_position_down() queue_position() queue_position_up()</a></li>
<li><a class="reference internal" href="#queue-position-set" id="toc-entry-280">queue_position_set()</a></li>
<li><a class="reference internal" href="#set-ssl-certificate-set-ssl-certificate-buffer" id="toc-entry-281">set_ssl_certificate() set_ssl_certificate_buffer()</a></li>
<li><a class="reference internal" href="#torrent-file-torrent-file-with-hashes" id="toc-entry-282">torrent_file() torrent_file_with_hashes()</a></li>
<li><a class="reference internal" href="#piece-layers" id="toc-entry-283">piece_layers()</a></li>
<li><a class="reference internal" href="#post-piece-availability-piece-availability" id="toc-entry-284">post_piece_availability() piece_availability()</a></li>
<li><a class="reference internal" href="#prioritize-pieces-piece-priority-get-piece-priorities" id="toc-entry-285">prioritize_pieces() piece_priority() get_piece_priorities()</a></li>
<li><a class="reference internal" href="#file-priority-prioritize-files-get-file-priorities" id="toc-entry-286">file_priority() prioritize_files() get_file_priorities()</a></li>
<li><a class="reference internal" href="#force-dht-announce-force-lsd-announce-force-reannounce" id="toc-entry-287">force_dht_announce() force_lsd_announce() force_reannounce()</a></li>
<li><a class="reference internal" href="#scrape-tracker" id="toc-entry-288">scrape_tracker()</a></li>
<li><a class="reference internal" href="#set-download-limit-download-limit-set-upload-limit-upload-limit" id="toc-entry-289">set_download_limit() download_limit() set_upload_limit() upload_limit()</a></li>
<li><a class="reference internal" href="#connect-peer" id="toc-entry-290">connect_peer()</a></li>
<li><a class="reference internal" href="#clear-peers" id="toc-entry-291">clear_peers()</a></li>
<li><a class="reference internal" href="#set-max-uploads-max-uploads" id="toc-entry-292">set_max_uploads() max_uploads()</a></li>
<li><a class="reference internal" href="#set-max-connections-max-connections" id="toc-entry-293">set_max_connections() max_connections()</a></li>
<li><a class="reference internal" href="#move-storage" id="toc-entry-294">move_storage()</a></li>
<li><a class="reference internal" href="#rename-file" id="toc-entry-295">rename_file()</a></li>
<li><a class="reference internal" href="#info-hash-info-hashes" id="toc-entry-296">info_hash() info_hashes()</a></li>
<li><a class="reference internal" href="#operator-operator-operator" id="toc-entry-297">operator!=() operator==() operator&lt;()</a></li>
<li><a class="reference internal" href="#id" id="toc-entry-298">id()</a></li>
<li><a class="reference internal" href="#native-handle" id="toc-entry-299">native_handle()</a></li>
<li><a class="reference internal" href="#userdata" id="toc-entry-300">userdata()</a></li>
<li><a class="reference internal" href="#in-session" id="toc-entry-301">in_session()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#hash-value" id="toc-entry-302">hash_value()</a></li>
<li><a class="reference internal" href="#storage-params" id="toc-entry-303">storage_params</a></li>
<li><a class="reference internal" href="#file-slice" id="toc-entry-304">file_slice</a></li>
<li><a class="reference internal" href="#file-storage" id="toc-entry-305">file_storage</a><ul>
<li><a class="reference internal" href="#is-valid-1" id="toc-entry-306">is_valid()</a></li>
<li><a class="reference internal" href="#reserve" id="toc-entry-307">reserve()</a></li>
<li><a class="reference internal" href="#add-file-borrow-add-file" id="toc-entry-308">add_file_borrow() add_file()</a></li>
<li><a class="reference internal" href="#rename-file-1" id="toc-entry-309">rename_file()</a></li>
<li><a class="reference internal" href="#map-block" id="toc-entry-310">map_block()</a></li>
<li><a class="reference internal" href="#map-file" id="toc-entry-311">map_file()</a></li>
<li><a class="reference internal" href="#num-files" id="toc-entry-312">num_files()</a></li>
<li><a class="reference internal" href="#end-file" id="toc-entry-313">end_file()</a></li>
<li><a class="reference internal" href="#file-range" id="toc-entry-314">file_range()</a></li>
<li><a class="reference internal" href="#total-size" id="toc-entry-315">total_size()</a></li>
<li><a class="reference internal" href="#num-pieces-set-num-pieces" id="toc-entry-316">num_pieces() set_num_pieces()</a></li>
<li><a class="reference internal" href="#end-piece" id="toc-entry-317">end_piece()</a></li>
<li><a class="reference internal" href="#last-piece" id="toc-entry-318">last_piece()</a></li>
<li><a class="reference internal" href="#piece-range" id="toc-entry-319">piece_range()</a></li>
<li><a class="reference internal" href="#piece-length-set-piece-length" id="toc-entry-320">piece_length() set_piece_length()</a></li>
<li><a class="reference internal" href="#piece-size" id="toc-entry-321">piece_size()</a></li>
<li><a class="reference internal" href="#piece-size2" id="toc-entry-322">piece_size2()</a></li>
<li><a class="reference internal" href="#blocks-in-piece2" id="toc-entry-323">blocks_in_piece2()</a></li>
<li><a class="reference internal" href="#blocks-per-piece" id="toc-entry-324">blocks_per_piece()</a></li>
<li><a class="reference internal" href="#name-set-name" id="toc-entry-325">name() set_name()</a></li>
<li><a class="reference internal" href="#swap-2" id="toc-entry-326">swap()</a></li>
<li><a class="reference internal" href="#canonicalize" id="toc-entry-327">canonicalize()</a></li>
<li><a class="reference internal" href="#symlink-pad-file-at-mtime-root-ptr-file-path-file-offset-root-file-size-file-name-hash" id="toc-entry-328">symlink() pad_file_at() mtime() root_ptr() file_path() file_offset() root() file_size() file_name() hash()</a></li>
<li><a class="reference internal" href="#file-num-blocks-file-num-pieces-file-piece-range" id="toc-entry-329">file_num_blocks() file_num_pieces() file_piece_range()</a></li>
<li><a class="reference internal" href="#file-first-block-node-file-first-piece-node" id="toc-entry-330">file_first_block_node() file_first_piece_node()</a></li>
<li><a class="reference internal" href="#file-path-hash" id="toc-entry-331">file_path_hash()</a></li>
<li><a class="reference internal" href="#all-path-hashes" id="toc-entry-332">all_path_hashes()</a></li>
<li><a class="reference internal" href="#file-flags" id="toc-entry-333">file_flags()</a></li>
<li><a class="reference internal" href="#file-absolute-path" id="toc-entry-334">file_absolute_path()</a></li>
<li><a class="reference internal" href="#file-index-at-offset-file-index-at-piece" id="toc-entry-335">file_index_at_offset() file_index_at_piece()</a></li>
<li><a class="reference internal" href="#file-index-for-root" id="toc-entry-336">file_index_for_root()</a></li>
<li><a class="reference internal" href="#piece-index-at-file" id="toc-entry-337">piece_index_at_file()</a></li>
<li><a class="reference internal" href="#sanitize-symlinks" id="toc-entry-338">sanitize_symlinks()</a></li>
<li><a class="reference internal" href="#v2" id="toc-entry-339">v2()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#mmap-disk-io-constructor" id="toc-entry-340">mmap_disk_io_constructor()</a></li>
<li><a class="reference internal" href="#default-disk-io-constructor" id="toc-entry-341">default_disk_io_constructor()</a></li>
<li><a class="reference internal" href="#disabled-disk-io-constructor" id="toc-entry-342">disabled_disk_io_constructor()</a></li>
<li><a class="reference internal" href="#posix-disk-io-constructor" id="toc-entry-343">posix_disk_io_constructor()</a></li>
<li><a class="reference internal" href="#enum-storage-mode-t" id="toc-entry-344">enum storage_mode_t</a></li>
<li><a class="reference internal" href="#enum-status-t" id="toc-entry-345">enum status_t</a></li>
<li><a class="reference internal" href="#enum-move-flags-t" id="toc-entry-346">enum move_flags_t</a></li>
<li><a class="reference internal" href="#session-proxy" id="toc-entry-347">session_proxy</a><ul>
<li><a class="reference internal" href="#operator-session-proxy-session-proxy" id="toc-entry-348">operator=() session_proxy() ~session_proxy()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#session" id="toc-entry-349">session</a><ul>
<li><a class="reference internal" href="#session-1" id="toc-entry-350">session()</a></li>
<li><a class="reference internal" href="#session-2" id="toc-entry-351">session()</a></li>
<li><a class="reference internal" href="#session-3" id="toc-entry-352">~session()</a></li>
<li><a class="reference internal" href="#abort-2" id="toc-entry-353">abort()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#session-params" id="toc-entry-354">session_params</a><ul>
<li><a class="reference internal" href="#session-params-1" id="toc-entry-355">session_params()</a></li>
<li><a class="reference internal" href="#session-params-2" id="toc-entry-356">session_params()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#session-handle" id="toc-entry-357">session_handle</a><ul>
<li><a class="reference internal" href="#is-valid-2" id="toc-entry-358">is_valid()</a></li>
<li><a class="reference internal" href="#session-state" id="toc-entry-359">session_state()</a></li>
<li><a class="reference internal" href="#get-torrent-status-refresh-torrent-status" id="toc-entry-360">get_torrent_status() refresh_torrent_status()</a></li>
<li><a class="reference internal" href="#post-torrent-updates" id="toc-entry-361">post_torrent_updates()</a></li>
<li><a class="reference internal" href="#post-session-stats" id="toc-entry-362">post_session_stats()</a></li>
<li><a class="reference internal" href="#post-dht-stats" id="toc-entry-363">post_dht_stats()</a></li>
<li><a class="reference internal" href="#set-dht-state" id="toc-entry-364">set_dht_state()</a></li>
<li><a class="reference internal" href="#find-torrent-get-torrents" id="toc-entry-365">find_torrent() get_torrents()</a></li>
<li><a class="reference internal" href="#add-torrent-async-add-torrent" id="toc-entry-366">add_torrent() async_add_torrent()</a></li>
<li><a class="reference internal" href="#resume-is-paused-pause" id="toc-entry-367">resume() is_paused() pause()</a></li>
<li><a class="reference internal" href="#is-dht-running" id="toc-entry-368">is_dht_running()</a></li>
<li><a class="reference internal" href="#set-dht-storage" id="toc-entry-369">set_dht_storage()</a></li>
<li><a class="reference internal" href="#add-dht-node" id="toc-entry-370">add_dht_node()</a></li>
<li><a class="reference internal" href="#dht-get-item" id="toc-entry-371">dht_get_item()</a></li>
<li><a class="reference internal" href="#dht-get-item-1" id="toc-entry-372">dht_get_item()</a></li>
<li><a class="reference internal" href="#dht-put-item" id="toc-entry-373">dht_put_item()</a></li>
<li><a class="reference internal" href="#dht-put-item-1" id="toc-entry-374">dht_put_item()</a></li>
<li><a class="reference internal" href="#dht-announce-dht-get-peers" id="toc-entry-375">dht_announce() dht_get_peers()</a></li>
<li><a class="reference internal" href="#dht-live-nodes" id="toc-entry-376">dht_live_nodes()</a></li>
<li><a class="reference internal" href="#dht-sample-infohashes" id="toc-entry-377">dht_sample_infohashes()</a></li>
<li><a class="reference internal" href="#dht-direct-request" id="toc-entry-378">dht_direct_request()</a></li>
<li><a class="reference internal" href="#add-extension-1" id="toc-entry-379">add_extension()</a></li>
<li><a class="reference internal" href="#get-ip-filter-set-ip-filter" id="toc-entry-380">get_ip_filter() set_ip_filter()</a></li>
<li><a class="reference internal" href="#set-port-filter" id="toc-entry-381">set_port_filter()</a></li>
<li><a class="reference internal" href="#is-listening-ssl-listen-port-listen-port" id="toc-entry-382">is_listening() ssl_listen_port() listen_port()</a></li>
<li><a class="reference internal" href="#set-peer-class-filter-get-peer-class-filter" id="toc-entry-383">set_peer_class_filter() get_peer_class_filter()</a></li>
<li><a class="reference internal" href="#set-peer-class-type-filter-get-peer-class-type-filter" id="toc-entry-384">set_peer_class_type_filter() get_peer_class_type_filter()</a></li>
<li><a class="reference internal" href="#create-peer-class" id="toc-entry-385">create_peer_class()</a></li>
<li><a class="reference internal" href="#delete-peer-class" id="toc-entry-386">delete_peer_class()</a></li>
<li><a class="reference internal" href="#set-peer-class-get-peer-class" id="toc-entry-387">set_peer_class() get_peer_class()</a></li>
<li><a class="reference internal" href="#remove-torrent-1" id="toc-entry-388">remove_torrent()</a></li>
<li><a class="reference internal" href="#get-settings-apply-settings" id="toc-entry-389">get_settings() apply_settings()</a></li>
<li><a class="reference internal" href="#pop-alerts-wait-for-alert-set-alert-notify" id="toc-entry-390">pop_alerts() wait_for_alert() set_alert_notify()</a></li>
<li><a class="reference internal" href="#delete-port-mapping-add-port-mapping" id="toc-entry-391">delete_port_mapping() add_port_mapping()</a></li>
<li><a class="reference internal" href="#reopen-network-sockets" id="toc-entry-392">reopen_network_sockets()</a></li>
<li><a class="reference internal" href="#native-handle-1" id="toc-entry-393">native_handle()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#write-session-params-buf-write-session-params-read-session-params" id="toc-entry-394">write_session_params_buf() write_session_params() read_session_params()</a></li>
<li><a class="reference internal" href="#counters-1" id="toc-entry-395">counters</a><ul>
<li><a class="reference internal" href="#inc-stats-counter-operator" id="toc-entry-396">inc_stats_counter() operator[]()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#stats-metric" id="toc-entry-397">stats_metric</a></li>
<li><a class="reference internal" href="#session-stats-metrics" id="toc-entry-398">session_stats_metrics()</a></li>
<li><a class="reference internal" href="#find-metric-idx" id="toc-entry-399">find_metric_idx()</a></li>
<li><a class="reference internal" href="#enum-metric-type-t" id="toc-entry-400">enum metric_type_t</a></li>
<li><a class="reference internal" href="#peer-request" id="toc-entry-401">peer_request</a><ul>
<li><a class="reference internal" href="#operator" id="toc-entry-402">operator==()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#peer-info" id="toc-entry-403">peer_info</a><ul>
<li><a class="reference internal" href="#i2p-destination" id="toc-entry-404">i2p_destination()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#info-hash-t" id="toc-entry-405">info_hash_t</a><ul>
<li><a class="reference internal" href="#info-hash-t-1" id="toc-entry-406">info_hash_t()</a></li>
<li><a class="reference internal" href="#has-v1-has-has-v2" id="toc-entry-407">has_v1() has() has_v2()</a></li>
<li><a class="reference internal" href="#get" id="toc-entry-408">get()</a></li>
<li><a class="reference internal" href="#get-best" id="toc-entry-409">get_best()</a></li>
<li><a class="reference internal" href="#for-each" id="toc-entry-410">for_each()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#piece-block" id="toc-entry-411">piece_block</a></li>
<li><a class="reference internal" href="#load-torrent-parsed-load-torrent-file-load-torrent-buffer" id="toc-entry-412">load_torrent_parsed() load_torrent_file() load_torrent_buffer()</a></li>
<li><a class="reference internal" href="#torrent-peer-equal" id="toc-entry-413">torrent_peer_equal()</a></li>
<li><a class="reference internal" href="#make-magnet-uri" id="toc-entry-414">make_magnet_uri()</a></li>
<li><a class="reference internal" href="#parse-magnet-uri" id="toc-entry-415">parse_magnet_uri()</a></li>
<li><a class="reference internal" href="#version" id="toc-entry-416">version()</a></li>
<li><a class="reference internal" href="#truncate-files" id="toc-entry-417">truncate_files()</a></li>
<li><a class="reference internal" href="#enum-event-t" id="toc-entry-418">enum event_t</a></li>
<li><a class="reference internal" href="#enum-socket-type-t" id="toc-entry-419">enum socket_type_t</a></li>
<li><a class="reference internal" href="#enum-connection-type" id="toc-entry-420">enum connection_type</a></li>
<li><a class="reference internal" href="#enum-portmap-transport" id="toc-entry-421">enum portmap_transport</a></li>
<li><a class="reference internal" href="#enum-portmap-protocol" id="toc-entry-422">enum portmap_protocol</a></li>
<li><a class="reference internal" href="#enum-protocol-version" id="toc-entry-423">enum protocol_version</a></li>
<li><a class="reference internal" href="#int-1" id="toc-entry-424">int</a></li>
<li><a class="reference internal" href="#download-priority-t" id="toc-entry-425">download_priority_t</a></li>
<li><a class="reference internal" href="#char-const" id="toc-entry-426">char const*</a></li>
<li><a class="reference internal" href="#std-uint64-t" id="toc-entry-427">std::uint64_t</a></li>
<li><a class="reference internal" href="#pex-flags-t" id="toc-entry-428">pex_flags_t</a></li>
<li><a class="reference internal" href="#torrent-flags-t" id="toc-entry-429">torrent_flags_t</a></li>
<li><a class="reference internal" href="#entry" id="toc-entry-430">entry</a><ul>
<li><a class="reference internal" href="#type-2" id="toc-entry-431">type()</a></li>
<li><a class="reference internal" href="#entry-1" id="toc-entry-432">entry()</a></li>
<li><a class="reference internal" href="#entry-2" id="toc-entry-433">entry()</a></li>
<li><a class="reference internal" href="#entry-3" id="toc-entry-434">entry()</a></li>
<li><a class="reference internal" href="#operator-1" id="toc-entry-435">operator=()</a></li>
<li><a class="reference internal" href="#dict-string-integer-list-preformatted" id="toc-entry-436">dict() string() integer() list() preformatted()</a></li>
<li><a class="reference internal" href="#swap-3" id="toc-entry-437">swap()</a></li>
<li><a class="reference internal" href="#operator-2" id="toc-entry-438">operator[]()</a></li>
<li><a class="reference internal" href="#find-key" id="toc-entry-439">find_key()</a></li>
<li><a class="reference internal" href="#to-string" id="toc-entry-440">to_string()</a></li>
<li><a class="reference internal" href="#enum-data-type" id="toc-entry-441">enum data_type</a></li>
</ul>
</li>
<li><a class="reference internal" href="#operator-3" id="toc-entry-442">operator&lt;&lt;()</a></li>
<li><a class="reference internal" href="#bencode" id="toc-entry-443">bencode()</a></li>
<li><a class="reference internal" href="#ip-filter" id="toc-entry-444">ip_filter</a><ul>
<li><a class="reference internal" href="#empty-1" id="toc-entry-445">empty()</a></li>
<li><a class="reference internal" href="#add-rule" id="toc-entry-446">add_rule()</a></li>
<li><a class="reference internal" href="#access" id="toc-entry-447">access()</a></li>
<li><a class="reference internal" href="#export-filter" id="toc-entry-448">export_filter()</a></li>
<li><a class="reference internal" href="#enum-access-flags" id="toc-entry-449">enum access_flags</a></li>
</ul>
</li>
<li><a class="reference internal" href="#port-filter" id="toc-entry-450">port_filter</a><ul>
<li><a class="reference internal" href="#add-rule-1" id="toc-entry-451">add_rule()</a></li>
<li><a class="reference internal" href="#access-1" id="toc-entry-452">access()</a></li>
<li><a class="reference internal" href="#enum-access-flags-1" id="toc-entry-453">enum access_flags</a></li>
</ul>
</li>
<li><a class="reference internal" href="#peer-class-info" id="toc-entry-454">peer_class_info</a></li>
<li><a class="reference internal" href="#peer-class-type-filter" id="toc-entry-455">peer_class_type_filter</a><ul>
<li><a class="reference internal" href="#remove-add" id="toc-entry-456">remove() add()</a></li>
<li><a class="reference internal" href="#disallow-allow" id="toc-entry-457">disallow() allow()</a></li>
<li><a class="reference internal" href="#apply" id="toc-entry-458">apply()</a></li>
<li><a class="reference internal" href="#enum-socket-type-t-1" id="toc-entry-459">enum socket_type_t</a></li>
</ul>
</li>
<li><a class="reference internal" href="#create-torrent" id="toc-entry-460">create_torrent</a><ul>
<li><a class="reference internal" href="#create-torrent-1" id="toc-entry-461">create_torrent()</a></li>
<li><a class="reference internal" href="#generate-generate-buf" id="toc-entry-462">generate() generate_buf()</a></li>
<li><a class="reference internal" href="#files" id="toc-entry-463">files()</a></li>
<li><a class="reference internal" href="#set-comment" id="toc-entry-464">set_comment()</a></li>
<li><a class="reference internal" href="#set-creator" id="toc-entry-465">set_creator()</a></li>
<li><a class="reference internal" href="#set-creation-date" id="toc-entry-466">set_creation_date()</a></li>
<li><a class="reference internal" href="#set-hash" id="toc-entry-467">set_hash()</a></li>
<li><a class="reference internal" href="#set-hash2" id="toc-entry-468">set_hash2()</a></li>
<li><a class="reference internal" href="#add-url-seed-add-http-seed" id="toc-entry-469">add_url_seed() add_http_seed()</a></li>
<li><a class="reference internal" href="#add-node" id="toc-entry-470">add_node()</a></li>
<li><a class="reference internal" href="#add-tracker" id="toc-entry-471">add_tracker()</a></li>
<li><a class="reference internal" href="#set-root-cert" id="toc-entry-472">set_root_cert()</a></li>
<li><a class="reference internal" href="#priv-set-priv" id="toc-entry-473">priv() set_priv()</a></li>
<li><a class="reference internal" href="#num-pieces" id="toc-entry-474">num_pieces()</a></li>
<li><a class="reference internal" href="#piece-range-1" id="toc-entry-475">piece_range()</a></li>
<li><a class="reference internal" href="#file-range-1" id="toc-entry-476">file_range()</a></li>
<li><a class="reference internal" href="#file-piece-range" id="toc-entry-477">file_piece_range()</a></li>
<li><a class="reference internal" href="#total-size-1" id="toc-entry-478">total_size()</a></li>
<li><a class="reference internal" href="#piece-length-piece-size" id="toc-entry-479">piece_length() piece_size()</a></li>
<li><a class="reference internal" href="#add-similar-torrent-add-collection" id="toc-entry-480">add_similar_torrent() add_collection()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#add-files" id="toc-entry-481">add_files()</a></li>
<li><a class="reference internal" href="#set-piece-hashes" id="toc-entry-482">set_piece_hashes()</a></li>
<li><a class="reference internal" href="#bdecode-node" id="toc-entry-483">bdecode_node</a><ul>
<li><a class="reference internal" href="#bdecode-node-1" id="toc-entry-484">bdecode_node()</a></li>
<li><a class="reference internal" href="#operator-bdecode-node" id="toc-entry-485">operator=() bdecode_node()</a></li>
<li><a class="reference internal" href="#type-3" id="toc-entry-486">type()</a></li>
<li><a class="reference internal" href="#bool-1" id="toc-entry-487">bool()</a></li>
<li><a class="reference internal" href="#non-owning" id="toc-entry-488">non_owning()</a></li>
<li><a class="reference internal" href="#data-offset-data-section" id="toc-entry-489">data_offset() data_section()</a></li>
<li><a class="reference internal" href="#list-int-value-at-list-string-value-at-list-size-list-at" id="toc-entry-490">list_int_value_at() list_string_value_at() list_size() list_at()</a></li>
<li><a class="reference internal" href="#dict-find-dict-dict-find-string-dict-find-list-dict-at-dict-find-int-dict-find-string-value-dict-find-int-value-dict-at-node-dict-size-dict-find" id="toc-entry-491">dict_find_dict() dict_find_string() dict_find_list() dict_at() dict_find_int() dict_find_string_value() dict_find_int_value() dict_at_node() dict_size() dict_find()</a></li>
<li><a class="reference internal" href="#int-value" id="toc-entry-492">int_value()</a></li>
<li><a class="reference internal" href="#string-length-string-value-string-offset-string-ptr" id="toc-entry-493">string_length() string_value() string_offset() string_ptr()</a></li>
<li><a class="reference internal" href="#clear" id="toc-entry-494">clear()</a></li>
<li><a class="reference internal" href="#swap-4" id="toc-entry-495">swap()</a></li>
<li><a class="reference internal" href="#reserve-1" id="toc-entry-496">reserve()</a></li>
<li><a class="reference internal" href="#switch-underlying-buffer" id="toc-entry-497">switch_underlying_buffer()</a></li>
<li><a class="reference internal" href="#has-soft-error" id="toc-entry-498">has_soft_error()</a></li>
<li><a class="reference internal" href="#enum-type-t" id="toc-entry-499">enum type_t</a></li>
</ul>
</li>
<li><a class="reference internal" href="#print-entry" id="toc-entry-500">print_entry()</a></li>
<li><a class="reference internal" href="#bdecode" id="toc-entry-501">bdecode()</a></li>
<li><a class="reference internal" href="#client-data-t" id="toc-entry-502">client_data_t</a><ul>
<li><a class="reference internal" href="#client-data-t-1" id="toc-entry-503">client_data_t()</a></li>
<li><a class="reference internal" href="#void-operator-const" id="toc-entry-504">void*() operator=() const*()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#add-torrent-params" id="toc-entry-505">add_torrent_params</a></li>
<li><a class="reference internal" href="#storage-error" id="toc-entry-506">storage_error</a><ul>
<li><a class="reference internal" href="#bool-2" id="toc-entry-507">bool()</a></li>
<li><a class="reference internal" href="#file" id="toc-entry-508">file()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#gzip-category" id="toc-entry-509">gzip_category()</a></li>
<li><a class="reference internal" href="#pcp-category" id="toc-entry-510">pcp_category()</a></li>
<li><a class="reference internal" href="#bdecode-category" id="toc-entry-511">bdecode_category()</a></li>
<li><a class="reference internal" href="#libtorrent-category" id="toc-entry-512">libtorrent_category()</a></li>
<li><a class="reference internal" href="#http-category" id="toc-entry-513">http_category()</a></li>
<li><a class="reference internal" href="#i2p-category" id="toc-entry-514">i2p_category()</a></li>
<li><a class="reference internal" href="#socks-category" id="toc-entry-515">socks_category()</a></li>
<li><a class="reference internal" href="#upnp-category" id="toc-entry-516">upnp_category()</a></li>
<li><a class="reference internal" href="#enum-error-code-enum" id="toc-entry-517">enum error_code_enum</a></li>
<li><a class="reference internal" href="#enum-pcp-errors" id="toc-entry-518">enum pcp_errors</a></li>
<li><a class="reference internal" href="#enum-error-code-enum-1" id="toc-entry-519">enum error_code_enum</a></li>
<li><a class="reference internal" href="#enum-error-code-enum-2" id="toc-entry-520">enum error_code_enum</a></li>
<li><a class="reference internal" href="#enum-http-errors" id="toc-entry-521">enum http_errors</a></li>
<li><a class="reference internal" href="#enum-i2p-error-code" id="toc-entry-522">enum i2p_error_code</a></li>
<li><a class="reference internal" href="#enum-socks-error-code" id="toc-entry-523">enum socks_error_code</a></li>
<li><a class="reference internal" href="#enum-error-code-enum-3" id="toc-entry-524">enum error_code_enum</a></li>
<li><a class="reference internal" href="#settings-pack" id="toc-entry-525">settings_pack</a><ul>
<li><a class="reference internal" href="#set-str-set-bool-set-int" id="toc-entry-526">set_str() set_bool() set_int()</a></li>
<li><a class="reference internal" href="#has-val" id="toc-entry-527">has_val()</a></li>
<li><a class="reference internal" href="#clear-1" id="toc-entry-528">clear()</a></li>
<li><a class="reference internal" href="#clear-2" id="toc-entry-529">clear()</a></li>
<li><a class="reference internal" href="#get-bool-get-int-get-str" id="toc-entry-530">get_bool() get_int() get_str()</a></li>
<li><a class="reference internal" href="#enum-type-bases" id="toc-entry-531">enum type_bases</a></li>
<li><a class="reference internal" href="#enum-mmap-write-mode-t" id="toc-entry-532">enum mmap_write_mode_t</a></li>
<li><a class="reference internal" href="#enum-suggest-mode-t" id="toc-entry-533">enum suggest_mode_t</a></li>
<li><a class="reference internal" href="#enum-choking-algorithm-t" id="toc-entry-534">enum choking_algorithm_t</a></li>
<li><a class="reference internal" href="#enum-seed-choking-algorithm-t" id="toc-entry-535">enum seed_choking_algorithm_t</a></li>
<li><a class="reference internal" href="#enum-io-buffer-mode-t" id="toc-entry-536">enum io_buffer_mode_t</a></li>
<li><a class="reference internal" href="#enum-bandwidth-mixed-algo-t" id="toc-entry-537">enum bandwidth_mixed_algo_t</a></li>
<li><a class="reference internal" href="#enum-enc-policy" id="toc-entry-538">enum enc_policy</a></li>
<li><a class="reference internal" href="#enum-enc-level" id="toc-entry-539">enum enc_level</a></li>
<li><a class="reference internal" href="#enum-proxy-type-t" id="toc-entry-540">enum proxy_type_t</a></li>
</ul>
</li>
<li><a class="reference internal" href="#min-memory-usage-high-performance-seed" id="toc-entry-541">min_memory_usage() high_performance_seed()</a></li>
<li><a class="reference internal" href="#setting-by-name-name-for-setting" id="toc-entry-542">setting_by_name() name_for_setting()</a></li>
<li><a class="reference internal" href="#default-settings" id="toc-entry-543">default_settings()</a></li>
<li><a class="reference internal" href="#generate-fingerprint" id="toc-entry-544">generate_fingerprint()</a></li>
<li><a class="reference internal" href="#torrent-status" id="toc-entry-545">torrent_status</a><ul>
<li><a class="reference internal" href="#operator-4" id="toc-entry-546">operator==()</a></li>
<li><a class="reference internal" href="#enum-state-t" id="toc-entry-547">enum state_t</a></li>
</ul>
</li>
<li><a class="reference internal" href="#announce-infohash" id="toc-entry-548">announce_infohash</a></li>
<li><a class="reference internal" href="#announce-endpoint" id="toc-entry-549">announce_endpoint</a></li>
<li><a class="reference internal" href="#announce-entry" id="toc-entry-550">announce_entry</a><ul>
<li><a class="reference internal" href="#announce-entry-announce-entry-operator" id="toc-entry-551">~announce_entry() announce_entry() operator=()</a></li>
<li><a class="reference internal" href="#enum-tracker-source" id="toc-entry-552">enum tracker_source</a></li>
</ul>
</li>
<li><a class="reference internal" href="#web-seed-entry" id="toc-entry-553">web_seed_entry</a><ul>
<li><a class="reference internal" href="#operator-5" id="toc-entry-554">operator==()</a></li>
<li><a class="reference internal" href="#operator-6" id="toc-entry-555">operator&lt;()</a></li>
<li><a class="reference internal" href="#enum-type-t-1" id="toc-entry-556">enum type_t</a></li>
</ul>
</li>
<li><a class="reference internal" href="#load-torrent-limits" id="toc-entry-557">load_torrent_limits</a></li>
<li><a class="reference internal" href="#torrent-info" id="toc-entry-558">torrent_info</a><ul>
<li><a class="reference internal" href="#torrent-info-1" id="toc-entry-559">torrent_info()</a></li>
<li><a class="reference internal" href="#torrent-info-2" id="toc-entry-560">~torrent_info()</a></li>
<li><a class="reference internal" href="#orig-files-files" id="toc-entry-561">orig_files() files()</a></li>
<li><a class="reference internal" href="#rename-file-2" id="toc-entry-562">rename_file()</a></li>
<li><a class="reference internal" href="#remap-files" id="toc-entry-563">remap_files()</a></li>
<li><a class="reference internal" href="#trackers-clear-trackers-add-tracker" id="toc-entry-564">trackers() clear_trackers() add_tracker()</a></li>
<li><a class="reference internal" href="#similar-torrents-collections" id="toc-entry-565">similar_torrents() collections()</a></li>
<li><a class="reference internal" href="#set-web-seeds-add-url-seed-web-seeds-add-http-seed" id="toc-entry-566">set_web_seeds() add_url_seed() web_seeds() add_http_seed()</a></li>
<li><a class="reference internal" href="#total-size-2" id="toc-entry-567">total_size()</a></li>
<li><a class="reference internal" href="#piece-length-num-pieces" id="toc-entry-568">piece_length() num_pieces()</a></li>
<li><a class="reference internal" href="#blocks-per-piece-1" id="toc-entry-569">blocks_per_piece()</a></li>
<li><a class="reference internal" href="#last-piece-end-piece-piece-range" id="toc-entry-570">last_piece() end_piece() piece_range()</a></li>
<li><a class="reference internal" href="#info-hash-info-hashes-1" id="toc-entry-571">info_hash() info_hashes()</a></li>
<li><a class="reference internal" href="#v2-v1" id="toc-entry-572">v2() v1()</a></li>
<li><a class="reference internal" href="#num-files-1" id="toc-entry-573">num_files()</a></li>
<li><a class="reference internal" href="#map-block-1" id="toc-entry-574">map_block()</a></li>
<li><a class="reference internal" href="#map-file-1" id="toc-entry-575">map_file()</a></li>
<li><a class="reference internal" href="#ssl-cert" id="toc-entry-576">ssl_cert()</a></li>
<li><a class="reference internal" href="#is-valid-3" id="toc-entry-577">is_valid()</a></li>
<li><a class="reference internal" href="#priv" id="toc-entry-578">priv()</a></li>
<li><a class="reference internal" href="#is-i2p" id="toc-entry-579">is_i2p()</a></li>
<li><a class="reference internal" href="#piece-size-1" id="toc-entry-580">piece_size()</a></li>
<li><a class="reference internal" href="#hash-for-piece-ptr-hash-for-piece" id="toc-entry-581">hash_for_piece_ptr() hash_for_piece()</a></li>
<li><a class="reference internal" href="#name" id="toc-entry-582">name()</a></li>
<li><a class="reference internal" href="#creation-date" id="toc-entry-583">creation_date()</a></li>
<li><a class="reference internal" href="#creator" id="toc-entry-584">creator()</a></li>
<li><a class="reference internal" href="#comment" id="toc-entry-585">comment()</a></li>
<li><a class="reference internal" href="#nodes-1" id="toc-entry-586">nodes()</a></li>
<li><a class="reference internal" href="#add-node-1" id="toc-entry-587">add_node()</a></li>
<li><a class="reference internal" href="#parse-info-section" id="toc-entry-588">parse_info_section()</a></li>
<li><a class="reference internal" href="#info" id="toc-entry-589">info()</a></li>
<li><a class="reference internal" href="#info-section" id="toc-entry-590">info_section()</a></li>
<li><a class="reference internal" href="#piece-layer" id="toc-entry-591">piece_layer()</a></li>
<li><a class="reference internal" href="#free-piece-layers" id="toc-entry-592">free_piece_layers()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#dht-state" id="toc-entry-593">dht_state</a></li>
<li><a class="reference internal" href="#dht-storage-counters" id="toc-entry-594">dht_storage_counters</a><ul>
<li><a class="reference internal" href="#reset-3" id="toc-entry-595">reset()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#dht-storage-interface" id="toc-entry-596">dht_storage_interface</a><ul>
<li><a class="reference internal" href="#update-node-ids" id="toc-entry-597">update_node_ids()</a></li>
<li><a class="reference internal" href="#get-peers" id="toc-entry-598">get_peers()</a></li>
<li><a class="reference internal" href="#announce-peer" id="toc-entry-599">announce_peer()</a></li>
<li><a class="reference internal" href="#get-immutable-item" id="toc-entry-600">get_immutable_item()</a></li>
<li><a class="reference internal" href="#put-immutable-item" id="toc-entry-601">put_immutable_item()</a></li>
<li><a class="reference internal" href="#get-mutable-item-seq" id="toc-entry-602">get_mutable_item_seq()</a></li>
<li><a class="reference internal" href="#get-mutable-item" id="toc-entry-603">get_mutable_item()</a></li>
<li><a class="reference internal" href="#put-mutable-item" id="toc-entry-604">put_mutable_item()</a></li>
<li><a class="reference internal" href="#get-infohashes-sample" id="toc-entry-605">get_infohashes_sample()</a></li>
<li><a class="reference internal" href="#tick-2" id="toc-entry-606">tick()</a></li>
<li><a class="reference internal" href="#counters-2" id="toc-entry-607">counters()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#dht-default-storage-constructor" id="toc-entry-608">dht_default_storage_constructor()</a></li>
<li><a class="reference internal" href="#sign-mutable-item" id="toc-entry-609">sign_mutable_item()</a></li>
<li><a class="reference internal" href="#announce-flags-t" id="toc-entry-610">announce_flags_t</a></li>
<li><a class="reference internal" href="#read-resume-data" id="toc-entry-611">read_resume_data()</a></li>
<li><a class="reference internal" href="#write-resume-data-write-resume-data-buf" id="toc-entry-612">write_resume_data() write_resume_data_buf()</a></li>
<li><a class="reference internal" href="#write-torrent-file-write-torrent-file-buf" id="toc-entry-613">write_torrent_file() write_torrent_file_buf()</a></li>
<li><a class="reference internal" href="#write-torrent-flags-t" id="toc-entry-614">write_torrent_flags_t</a></li>
<li><a class="reference internal" href="#ed25519-create-seed" id="toc-entry-615">ed25519_create_seed()</a></li>
<li><a class="reference internal" href="#ed25519-create-keypair" id="toc-entry-616">ed25519_create_keypair()</a></li>
<li><a class="reference internal" href="#ed25519-sign" id="toc-entry-617">ed25519_sign()</a></li>
<li><a class="reference internal" href="#ed25519-verify" id="toc-entry-618">ed25519_verify()</a></li>
<li><a class="reference internal" href="#ed25519-add-scalar" id="toc-entry-619">ed25519_add_scalar()</a></li>
<li><a class="reference internal" href="#ed25519-key-exchange" id="toc-entry-620">ed25519_key_exchange()</a></li>
</ul>
</div>
<p>The disk I/O can be customized in libtorrent. In previous versions, the
customization was at the level of each torrent. Now, the customization point
is at the <a class="reference external" href="reference-Session.html#session">session</a> level. All torrents added to a <a class="reference external" href="reference-Session.html#session">session</a> will use the same
disk I/O subsystem, as determined by the disk_io_constructor (in
<a class="reference external" href="reference-Session.html#session_params">session_params</a>).</p>
<p>This allows the disk subsystem to also customize threading and disk job
management.</p>
<p>To customize the disk subsystem, implement <a class="reference external" href="reference-Custom_Storage.html#disk_interface">disk_interface</a> and provide a
factory function to the <a class="reference external" href="reference-Session.html#session">session</a> constructor (via <a class="reference external" href="reference-Session.html#session_params">session_params</a>).</p>
<p>Example use:</p>
<pre class="code c++ literal-block">
<span class="keyword">struct</span><span class="whitespace"> </span><span class="name class">temp_storage</span><span class="whitespace">
</span><span class="punctuation">{</span><span class="whitespace">
  </span><span class="keyword">explicit</span><span class="whitespace"> </span><span class="name">temp_storage</span><span class="punctuation">(</span><span class="name">lt</span><span class="operator">::</span><span class="name">file_storage</span><span class="whitespace"> </span><span class="keyword">const</span><span class="operator">&amp;</span><span class="whitespace"> </span><span class="name">fs</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="name">m_files</span><span class="punctuation">(</span><span class="name">fs</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="punctuation">{}</span><span class="whitespace">

  </span><span class="name">lt</span><span class="operator">::</span><span class="name">span</span><span class="operator">&lt;</span><span class="keyword type">char</span><span class="whitespace"> </span><span class="keyword">const</span><span class="operator">&gt;</span><span class="whitespace"> </span><span class="name">readv</span><span class="punctuation">(</span><span class="name">lt</span><span class="operator">::</span><span class="name">peer_request</span><span class="whitespace"> </span><span class="keyword">const</span><span class="whitespace"> </span><span class="name">r</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">lt</span><span class="operator">::</span><span class="name">storage_error</span><span class="operator">&amp;</span><span class="whitespace"> </span><span class="name">ec</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="keyword">const</span><span class="whitespace">
  </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="keyword">auto</span><span class="whitespace"> </span><span class="keyword">const</span><span class="whitespace"> </span><span class="name">i</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">m_file_data</span><span class="punctuation">.</span><span class="name">find</span><span class="punctuation">(</span><span class="name">r</span><span class="punctuation">.</span><span class="name">piece</span><span class="punctuation">);</span><span class="whitespace">
    </span><span class="keyword">if</span><span class="whitespace"> </span><span class="punctuation">(</span><span class="name">i</span><span class="whitespace"> </span><span class="operator">==</span><span class="whitespace"> </span><span class="name">m_file_data</span><span class="punctuation">.</span><span class="name">end</span><span class="punctuation">())</span><span class="whitespace">
    </span><span class="punctuation">{</span><span class="whitespace">
      </span><span class="name">ec</span><span class="punctuation">.</span><span class="name">operation</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">lt</span><span class="operator">::</span><span class="name">operation_t</span><span class="operator">::</span><span class="name">file_read</span><span class="punctuation">;</span><span class="whitespace">
      </span><span class="name">ec</span><span class="punctuation">.</span><span class="name">ec</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">boost</span><span class="operator">::</span><span class="name">asio</span><span class="operator">::</span><span class="name">error</span><span class="operator">::</span><span class="name">eof</span><span class="punctuation">;</span><span class="whitespace">
      </span><span class="keyword">return</span><span class="whitespace"> </span><span class="punctuation">{};</span><span class="whitespace">
    </span><span class="punctuation">}</span><span class="whitespace">
    </span><span class="keyword">if</span><span class="whitespace"> </span><span class="punctuation">(</span><span class="keyword type">int</span><span class="punctuation">(</span><span class="name">i</span><span class="operator">-&gt;</span><span class="name">second</span><span class="punctuation">.</span><span class="name">size</span><span class="punctuation">())</span><span class="whitespace"> </span><span class="operator">&lt;=</span><span class="whitespace"> </span><span class="name">r</span><span class="punctuation">.</span><span class="name">start</span><span class="punctuation">)</span><span class="whitespace">
    </span><span class="punctuation">{</span><span class="whitespace">
      </span><span class="name">ec</span><span class="punctuation">.</span><span class="name">operation</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">lt</span><span class="operator">::</span><span class="name">operation_t</span><span class="operator">::</span><span class="name">file_read</span><span class="punctuation">;</span><span class="whitespace">
      </span><span class="name">ec</span><span class="punctuation">.</span><span class="name">ec</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">boost</span><span class="operator">::</span><span class="name">asio</span><span class="operator">::</span><span class="name">error</span><span class="operator">::</span><span class="name">eof</span><span class="punctuation">;</span><span class="whitespace">
      </span><span class="keyword">return</span><span class="whitespace"> </span><span class="punctuation">{};</span><span class="whitespace">
    </span><span class="punctuation">}</span><span class="whitespace">
    </span><span class="keyword">return</span><span class="whitespace"> </span><span class="punctuation">{</span><span class="whitespace"> </span><span class="name">i</span><span class="operator">-&gt;</span><span class="name">second</span><span class="punctuation">.</span><span class="name">data</span><span class="punctuation">()</span><span class="whitespace"> </span><span class="operator">+</span><span class="whitespace"> </span><span class="name">r</span><span class="punctuation">.</span><span class="name">start</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">std</span><span class="operator">::</span><span class="name">min</span><span class="punctuation">(</span><span class="name">r</span><span class="punctuation">.</span><span class="name">length</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="keyword type">int</span><span class="punctuation">(</span><span class="name">i</span><span class="operator">-&gt;</span><span class="name">second</span><span class="punctuation">.</span><span class="name">size</span><span class="punctuation">())</span><span class="whitespace"> </span><span class="operator">-</span><span class="whitespace"> </span><span class="name">r</span><span class="punctuation">.</span><span class="name">start</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="punctuation">};</span><span class="whitespace">
  </span><span class="punctuation">}</span><span class="whitespace">
  </span><span class="keyword type">void</span><span class="whitespace"> </span><span class="name">writev</span><span class="punctuation">(</span><span class="name">lt</span><span class="operator">::</span><span class="name">span</span><span class="operator">&lt;</span><span class="keyword type">char</span><span class="whitespace"> </span><span class="keyword">const</span><span class="operator">&gt;</span><span class="whitespace"> </span><span class="keyword">const</span><span class="whitespace"> </span><span class="name">b</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">lt</span><span class="operator">::</span><span class="name">piece_index_t</span><span class="whitespace"> </span><span class="keyword">const</span><span class="whitespace"> </span><span class="name">piece</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="keyword type">int</span><span class="whitespace"> </span><span class="keyword">const</span><span class="whitespace"> </span><span class="name">offset</span><span class="punctuation">)</span><span class="whitespace">
  </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="keyword">auto</span><span class="operator">&amp;</span><span class="whitespace"> </span><span class="name">data</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">m_file_data</span><span class="punctuation">[</span><span class="name">piece</span><span class="punctuation">];</span><span class="whitespace">
    </span><span class="keyword">if</span><span class="whitespace"> </span><span class="punctuation">(</span><span class="name">data</span><span class="punctuation">.</span><span class="name">empty</span><span class="punctuation">())</span><span class="whitespace">
    </span><span class="punctuation">{</span><span class="whitespace">
      </span><span class="comment single">// allocate the whole piece, otherwise we'll invalidate the pointers
</span><span class="whitespace">      </span><span class="comment single">// we have returned back to libtorrent
</span><span class="whitespace">      </span><span class="keyword type">int</span><span class="whitespace"> </span><span class="keyword">const</span><span class="whitespace"> </span><span class="name">size</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">piece_size</span><span class="punctuation">(</span><span class="name">piece</span><span class="punctuation">);</span><span class="whitespace">
      </span><span class="name">data</span><span class="punctuation">.</span><span class="name">resize</span><span class="punctuation">(</span><span class="name">std</span><span class="operator">::</span><span class="keyword type">size_t</span><span class="punctuation">(</span><span class="name">size</span><span class="punctuation">));</span><span class="whitespace">
    </span><span class="punctuation">}</span><span class="whitespace">
    </span><span class="name">TORRENT_ASSERT</span><span class="punctuation">(</span><span class="name">offset</span><span class="whitespace"> </span><span class="operator">+</span><span class="whitespace"> </span><span class="name">b</span><span class="punctuation">.</span><span class="name">size</span><span class="punctuation">()</span><span class="whitespace"> </span><span class="operator">&lt;=</span><span class="whitespace"> </span><span class="keyword type">int</span><span class="punctuation">(</span><span class="name">data</span><span class="punctuation">.</span><span class="name">size</span><span class="punctuation">()));</span><span class="whitespace">
    </span><span class="name">std</span><span class="operator">::</span><span class="name">memcpy</span><span class="punctuation">(</span><span class="name">data</span><span class="punctuation">.</span><span class="name">data</span><span class="punctuation">()</span><span class="whitespace"> </span><span class="operator">+</span><span class="whitespace"> </span><span class="name">offset</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">b</span><span class="punctuation">.</span><span class="name">data</span><span class="punctuation">(),</span><span class="whitespace"> </span><span class="name">std</span><span class="operator">::</span><span class="keyword type">size_t</span><span class="punctuation">(</span><span class="name">b</span><span class="punctuation">.</span><span class="name">size</span><span class="punctuation">()));</span><span class="whitespace">
  </span><span class="punctuation">}</span><span class="whitespace">
  </span><span class="name">lt</span><span class="operator">::</span><span class="name">sha1_hash</span><span class="whitespace"> </span><span class="name">hash</span><span class="punctuation">(</span><span class="name">lt</span><span class="operator">::</span><span class="name">piece_index_t</span><span class="whitespace"> </span><span class="keyword">const</span><span class="whitespace"> </span><span class="name">piece</span><span class="whitespace">
    </span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">lt</span><span class="operator">::</span><span class="name">span</span><span class="operator">&lt;</span><span class="name">lt</span><span class="operator">::</span><span class="name">sha256_hash</span><span class="operator">&gt;</span><span class="whitespace"> </span><span class="keyword">const</span><span class="whitespace"> </span><span class="name">block_hashes</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">lt</span><span class="operator">::</span><span class="name">storage_error</span><span class="operator">&amp;</span><span class="whitespace"> </span><span class="name">ec</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="keyword">const</span><span class="whitespace">
  </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="keyword">auto</span><span class="whitespace"> </span><span class="keyword">const</span><span class="whitespace"> </span><span class="name">i</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">m_file_data</span><span class="punctuation">.</span><span class="name">find</span><span class="punctuation">(</span><span class="name">piece</span><span class="punctuation">);</span><span class="whitespace">
    </span><span class="keyword">if</span><span class="whitespace"> </span><span class="punctuation">(</span><span class="name">i</span><span class="whitespace"> </span><span class="operator">==</span><span class="whitespace"> </span><span class="name">m_file_data</span><span class="punctuation">.</span><span class="name">end</span><span class="punctuation">())</span><span class="whitespace">
    </span><span class="punctuation">{</span><span class="whitespace">
      </span><span class="name">ec</span><span class="punctuation">.</span><span class="name">operation</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">lt</span><span class="operator">::</span><span class="name">operation_t</span><span class="operator">::</span><span class="name">file_read</span><span class="punctuation">;</span><span class="whitespace">
      </span><span class="name">ec</span><span class="punctuation">.</span><span class="name">ec</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">boost</span><span class="operator">::</span><span class="name">asio</span><span class="operator">::</span><span class="name">error</span><span class="operator">::</span><span class="name">eof</span><span class="punctuation">;</span><span class="whitespace">
      </span><span class="keyword">return</span><span class="whitespace"> </span><span class="punctuation">{};</span><span class="whitespace">
    </span><span class="punctuation">}</span><span class="whitespace">
    </span><span class="keyword">if</span><span class="whitespace"> </span><span class="punctuation">(</span><span class="operator">!</span><span class="name">block_hashes</span><span class="punctuation">.</span><span class="name">empty</span><span class="punctuation">())</span><span class="whitespace">
    </span><span class="punctuation">{</span><span class="whitespace">
      </span><span class="keyword type">int</span><span class="whitespace"> </span><span class="keyword">const</span><span class="whitespace"> </span><span class="name">piece_size2</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">m_files</span><span class="punctuation">.</span><span class="name">piece_size2</span><span class="punctuation">(</span><span class="name">piece</span><span class="punctuation">);</span><span class="whitespace">
      </span><span class="keyword type">int</span><span class="whitespace"> </span><span class="keyword">const</span><span class="whitespace"> </span><span class="name">blocks_in_piece2</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">m_files</span><span class="punctuation">.</span><span class="name">blocks_in_piece2</span><span class="punctuation">(</span><span class="name">piece</span><span class="punctuation">);</span><span class="whitespace">
      </span><span class="keyword type">char</span><span class="whitespace"> </span><span class="keyword">const</span><span class="operator">*</span><span class="whitespace"> </span><span class="name">buf</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">i</span><span class="operator">-&gt;</span><span class="name">second</span><span class="punctuation">.</span><span class="name">data</span><span class="punctuation">();</span><span class="whitespace">
      </span><span class="name">std</span><span class="operator">::</span><span class="keyword type">int64_t</span><span class="whitespace"> </span><span class="name">offset</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="literal number integer">0</span><span class="punctuation">;</span><span class="whitespace">
      </span><span class="keyword">for</span><span class="whitespace"> </span><span class="punctuation">(</span><span class="keyword type">int</span><span class="whitespace"> </span><span class="name">k</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="literal number integer">0</span><span class="punctuation">;</span><span class="whitespace"> </span><span class="name">k</span><span class="whitespace"> </span><span class="operator">&lt;</span><span class="whitespace"> </span><span class="name">blocks_in_piece2</span><span class="punctuation">;</span><span class="whitespace"> </span><span class="operator">++</span><span class="name">k</span><span class="punctuation">)</span><span class="whitespace">
      </span><span class="punctuation">{</span><span class="whitespace">
        </span><span class="name">lt</span><span class="operator">::</span><span class="name">hasher256</span><span class="whitespace"> </span><span class="name">h2</span><span class="punctuation">;</span><span class="whitespace">
        </span><span class="name">std</span><span class="operator">::</span><span class="keyword type">ptrdiff_t</span><span class="whitespace"> </span><span class="keyword">const</span><span class="whitespace"> </span><span class="name">len2</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">std</span><span class="operator">::</span><span class="name">min</span><span class="punctuation">(</span><span class="name">lt</span><span class="operator">::</span><span class="name">default_block_size</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="keyword type">int</span><span class="punctuation">(</span><span class="name">piece_size2</span><span class="whitespace"> </span><span class="operator">-</span><span class="whitespace"> </span><span class="name">offset</span><span class="punctuation">));</span><span class="whitespace">
        </span><span class="name">h2</span><span class="punctuation">.</span><span class="name">update</span><span class="punctuation">({</span><span class="whitespace"> </span><span class="name">buf</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">len2</span><span class="whitespace"> </span><span class="punctuation">});</span><span class="whitespace">
        </span><span class="name">buf</span><span class="whitespace"> </span><span class="operator">+=</span><span class="whitespace"> </span><span class="name">len2</span><span class="punctuation">;</span><span class="whitespace">
        </span><span class="name">offset</span><span class="whitespace"> </span><span class="operator">+=</span><span class="whitespace"> </span><span class="name">len2</span><span class="punctuation">;</span><span class="whitespace">
        </span><span class="name">block_hashes</span><span class="punctuation">[</span><span class="name">k</span><span class="punctuation">]</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">h2</span><span class="punctuation">.</span><span class="keyword">final</span><span class="punctuation">();</span><span class="whitespace">
      </span><span class="punctuation">}</span><span class="whitespace">
    </span><span class="punctuation">}</span><span class="whitespace">
    </span><span class="keyword">return</span><span class="whitespace"> </span><span class="name">lt</span><span class="operator">::</span><span class="name">hasher</span><span class="punctuation">(</span><span class="name">i</span><span class="operator">-&gt;</span><span class="name">second</span><span class="punctuation">).</span><span class="keyword">final</span><span class="punctuation">();</span><span class="whitespace">
  </span><span class="punctuation">}</span><span class="whitespace">
  </span><span class="name">lt</span><span class="operator">::</span><span class="name">sha256_hash</span><span class="whitespace"> </span><span class="name">hash2</span><span class="punctuation">(</span><span class="name">lt</span><span class="operator">::</span><span class="name">piece_index_t</span><span class="whitespace"> </span><span class="keyword">const</span><span class="whitespace"> </span><span class="name">piece</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="keyword type">int</span><span class="whitespace"> </span><span class="keyword">const</span><span class="whitespace"> </span><span class="name">offset</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">lt</span><span class="operator">::</span><span class="name">storage_error</span><span class="operator">&amp;</span><span class="whitespace"> </span><span class="name">ec</span><span class="punctuation">)</span><span class="whitespace">
  </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="keyword">auto</span><span class="whitespace"> </span><span class="keyword">const</span><span class="whitespace"> </span><span class="name">i</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">m_file_data</span><span class="punctuation">.</span><span class="name">find</span><span class="punctuation">(</span><span class="name">piece</span><span class="punctuation">);</span><span class="whitespace">
    </span><span class="keyword">if</span><span class="whitespace"> </span><span class="punctuation">(</span><span class="name">i</span><span class="whitespace"> </span><span class="operator">==</span><span class="whitespace"> </span><span class="name">m_file_data</span><span class="punctuation">.</span><span class="name">end</span><span class="punctuation">())</span><span class="whitespace">
    </span><span class="punctuation">{</span><span class="whitespace">
      </span><span class="name">ec</span><span class="punctuation">.</span><span class="name">operation</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">lt</span><span class="operator">::</span><span class="name">operation_t</span><span class="operator">::</span><span class="name">file_read</span><span class="punctuation">;</span><span class="whitespace">
      </span><span class="name">ec</span><span class="punctuation">.</span><span class="name">ec</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">boost</span><span class="operator">::</span><span class="name">asio</span><span class="operator">::</span><span class="name">error</span><span class="operator">::</span><span class="name">eof</span><span class="punctuation">;</span><span class="whitespace">
      </span><span class="keyword">return</span><span class="whitespace"> </span><span class="punctuation">{};</span><span class="whitespace">
    </span><span class="punctuation">}</span><span class="whitespace">

    </span><span class="keyword type">int</span><span class="whitespace"> </span><span class="keyword">const</span><span class="whitespace"> </span><span class="name">piece_size</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">m_files</span><span class="punctuation">.</span><span class="name">piece_size2</span><span class="punctuation">(</span><span class="name">piece</span><span class="punctuation">);</span><span class="whitespace">

    </span><span class="name">std</span><span class="operator">::</span><span class="keyword type">ptrdiff_t</span><span class="whitespace"> </span><span class="keyword">const</span><span class="whitespace"> </span><span class="name">len</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">std</span><span class="operator">::</span><span class="name">min</span><span class="punctuation">(</span><span class="name">lt</span><span class="operator">::</span><span class="name">default_block_size</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">piece_size</span><span class="whitespace"> </span><span class="operator">-</span><span class="whitespace"> </span><span class="name">offset</span><span class="punctuation">);</span><span class="whitespace">

    </span><span class="name">lt</span><span class="operator">::</span><span class="name">span</span><span class="operator">&lt;</span><span class="keyword type">char</span><span class="whitespace"> </span><span class="keyword">const</span><span class="operator">&gt;</span><span class="whitespace"> </span><span class="name">b</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="punctuation">{</span><span class="name">i</span><span class="operator">-&gt;</span><span class="name">second</span><span class="punctuation">.</span><span class="name">data</span><span class="punctuation">()</span><span class="whitespace"> </span><span class="operator">+</span><span class="whitespace"> </span><span class="name">offset</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">len</span><span class="punctuation">};</span><span class="whitespace">
    </span><span class="keyword">return</span><span class="whitespace"> </span><span class="name">lt</span><span class="operator">::</span><span class="name">hasher256</span><span class="punctuation">(</span><span class="name">b</span><span class="punctuation">).</span><span class="keyword">final</span><span class="punctuation">();</span><span class="whitespace">
  </span><span class="punctuation">}</span><span class="whitespace">

</span><span class="keyword">private</span><span class="operator">:</span><span class="whitespace">
  </span><span class="keyword type">int</span><span class="whitespace"> </span><span class="name">piece_size</span><span class="punctuation">(</span><span class="name">lt</span><span class="operator">::</span><span class="name">piece_index_t</span><span class="whitespace"> </span><span class="name">piece</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="keyword">const</span><span class="whitespace">
  </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="keyword type">int</span><span class="whitespace"> </span><span class="keyword">const</span><span class="whitespace"> </span><span class="name">num_pieces</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="keyword">static_cast</span><span class="operator">&lt;</span><span class="keyword type">int</span><span class="operator">&gt;</span><span class="punctuation">((</span><span class="name">m_files</span><span class="punctuation">.</span><span class="name">total_size</span><span class="punctuation">()</span><span class="whitespace"> </span><span class="operator">+</span><span class="whitespace"> </span><span class="name">m_files</span><span class="punctuation">.</span><span class="name">piece_length</span><span class="punctuation">()</span><span class="whitespace"> </span><span class="operator">-</span><span class="whitespace"> </span><span class="literal number integer">1</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="operator">/</span><span class="whitespace"> </span><span class="name">m_files</span><span class="punctuation">.</span><span class="name">piece_length</span><span class="punctuation">());</span><span class="whitespace">
    </span><span class="keyword">return</span><span class="whitespace"> </span><span class="keyword">static_cast</span><span class="operator">&lt;</span><span class="keyword type">int</span><span class="operator">&gt;</span><span class="punctuation">(</span><span class="name">piece</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="operator">&lt;</span><span class="whitespace"> </span><span class="name">num_pieces</span><span class="whitespace"> </span><span class="operator">-</span><span class="whitespace"> </span><span class="literal number integer">1</span><span class="whitespace">
      </span><span class="operator">?</span><span class="whitespace"> </span><span class="name">m_files</span><span class="punctuation">.</span><span class="name">piece_length</span><span class="punctuation">()</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="keyword">static_cast</span><span class="operator">&lt;</span><span class="keyword type">int</span><span class="operator">&gt;</span><span class="punctuation">(</span><span class="name">m_files</span><span class="punctuation">.</span><span class="name">total_size</span><span class="punctuation">()</span><span class="whitespace"> </span><span class="operator">-</span><span class="whitespace"> </span><span class="name">std</span><span class="operator">::</span><span class="keyword type">int64_t</span><span class="punctuation">(</span><span class="name">num_pieces</span><span class="whitespace"> </span><span class="operator">-</span><span class="whitespace"> </span><span class="literal number integer">1</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="operator">*</span><span class="whitespace"> </span><span class="name">m_files</span><span class="punctuation">.</span><span class="name">piece_length</span><span class="punctuation">());</span><span class="whitespace">
  </span><span class="punctuation">}</span><span class="whitespace">

  </span><span class="name">lt</span><span class="operator">::</span><span class="name">file_storage</span><span class="whitespace"> </span><span class="keyword">const</span><span class="operator">&amp;</span><span class="whitespace"> </span><span class="name">m_files</span><span class="punctuation">;</span><span class="whitespace">
  </span><span class="name">std</span><span class="operator">::</span><span class="name">map</span><span class="operator">&lt;</span><span class="name">lt</span><span class="operator">::</span><span class="name">piece_index_t</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">std</span><span class="operator">::</span><span class="name">vector</span><span class="operator">&lt;</span><span class="keyword type">char</span><span class="operator">&gt;&gt;</span><span class="whitespace"> </span><span class="name">m_file_data</span><span class="punctuation">;</span><span class="whitespace">
</span><span class="punctuation">};</span><span class="whitespace">

</span><span class="name">lt</span><span class="operator">::</span><span class="name">storage_index_t</span><span class="whitespace"> </span><span class="name function">pop</span><span class="punctuation">(</span><span class="name">std</span><span class="operator">::</span><span class="name">vector</span><span class="operator">&lt;</span><span class="name">lt</span><span class="operator">::</span><span class="name">storage_index_t</span><span class="operator">&gt;&amp;</span><span class="whitespace"> </span><span class="name">q</span><span class="punctuation">)</span><span class="whitespace">
</span><span class="punctuation">{</span><span class="whitespace">
  </span><span class="name">TORRENT_ASSERT</span><span class="punctuation">(</span><span class="operator">!</span><span class="name">q</span><span class="punctuation">.</span><span class="name">empty</span><span class="punctuation">());</span><span class="whitespace">
  </span><span class="name">lt</span><span class="operator">::</span><span class="name">storage_index_t</span><span class="whitespace"> </span><span class="keyword">const</span><span class="whitespace"> </span><span class="name">ret</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">q</span><span class="punctuation">.</span><span class="name">back</span><span class="punctuation">();</span><span class="whitespace">
  </span><span class="name">q</span><span class="punctuation">.</span><span class="name">pop_back</span><span class="punctuation">();</span><span class="whitespace">
  </span><span class="keyword">return</span><span class="whitespace"> </span><span class="name">ret</span><span class="punctuation">;</span><span class="whitespace">
</span><span class="punctuation">}</span><span class="whitespace">

</span><span class="keyword">struct</span><span class="whitespace"> </span><span class="name class">temp_disk_io</span><span class="whitespace"> </span><span class="keyword">final</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="name">lt</span><span class="operator">::</span><span class="name">disk_interface</span><span class="whitespace">
  </span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">lt</span><span class="operator">::</span><span class="name">buffer_allocator_interface</span><span class="whitespace">
</span><span class="punctuation">{</span><span class="whitespace">
  </span><span class="keyword">explicit</span><span class="whitespace"> </span><span class="name">temp_disk_io</span><span class="punctuation">(</span><span class="name">lt</span><span class="operator">::</span><span class="name">io_context</span><span class="operator">&amp;</span><span class="whitespace"> </span><span class="name">ioc</span><span class="punctuation">)</span><span class="operator">:</span><span class="whitespace"> </span><span class="name">m_ioc</span><span class="punctuation">(</span><span class="name">ioc</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="punctuation">{}</span><span class="whitespace">

  </span><span class="keyword type">void</span><span class="whitespace"> </span><span class="name">settings_updated</span><span class="punctuation">()</span><span class="whitespace"> </span><span class="keyword">override</span><span class="whitespace"> </span><span class="punctuation">{}</span><span class="whitespace">

  </span><span class="name">lt</span><span class="operator">::</span><span class="name">storage_holder</span><span class="whitespace"> </span><span class="name">new_torrent</span><span class="punctuation">(</span><span class="name">lt</span><span class="operator">::</span><span class="name">storage_params</span><span class="whitespace"> </span><span class="keyword">const</span><span class="operator">&amp;</span><span class="whitespace"> </span><span class="name">params</span><span class="whitespace">
    </span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">std</span><span class="operator">::</span><span class="name">shared_ptr</span><span class="operator">&lt;</span><span class="keyword type">void</span><span class="operator">&gt;</span><span class="whitespace"> </span><span class="keyword">const</span><span class="operator">&amp;</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="keyword">override</span><span class="whitespace">
  </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="name">lt</span><span class="operator">::</span><span class="name">storage_index_t</span><span class="whitespace"> </span><span class="keyword">const</span><span class="whitespace"> </span><span class="name">idx</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">m_free_slots</span><span class="punctuation">.</span><span class="name">empty</span><span class="punctuation">()</span><span class="whitespace">
      </span><span class="operator">?</span><span class="whitespace"> </span><span class="name">m_torrents</span><span class="punctuation">.</span><span class="name">end_index</span><span class="punctuation">()</span><span class="whitespace">
      </span><span class="operator">:</span><span class="whitespace"> </span><span class="name">pop</span><span class="punctuation">(</span><span class="name">m_free_slots</span><span class="punctuation">);</span><span class="whitespace">
    </span><span class="keyword">auto</span><span class="whitespace"> </span><span class="name">storage</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">std</span><span class="operator">::</span><span class="name">make_unique</span><span class="operator">&lt;</span><span class="name">temp_storage</span><span class="operator">&gt;</span><span class="punctuation">(</span><span class="name">params</span><span class="punctuation">.</span><span class="name">files</span><span class="punctuation">);</span><span class="whitespace">
    </span><span class="keyword">if</span><span class="whitespace"> </span><span class="punctuation">(</span><span class="name">idx</span><span class="whitespace"> </span><span class="operator">==</span><span class="whitespace"> </span><span class="name">m_torrents</span><span class="punctuation">.</span><span class="name">end_index</span><span class="punctuation">())</span><span class="whitespace"> </span><span class="name">m_torrents</span><span class="punctuation">.</span><span class="name">emplace_back</span><span class="punctuation">(</span><span class="name">std</span><span class="operator">::</span><span class="name">move</span><span class="punctuation">(</span><span class="name">storage</span><span class="punctuation">));</span><span class="whitespace">
    </span><span class="keyword">else</span><span class="whitespace"> </span><span class="name">m_torrents</span><span class="punctuation">[</span><span class="name">idx</span><span class="punctuation">]</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">std</span><span class="operator">::</span><span class="name">move</span><span class="punctuation">(</span><span class="name">storage</span><span class="punctuation">);</span><span class="whitespace">
    </span><span class="keyword">return</span><span class="whitespace"> </span><span class="name">lt</span><span class="operator">::</span><span class="name">storage_holder</span><span class="punctuation">(</span><span class="name">idx</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="operator">*</span><span class="keyword">this</span><span class="punctuation">);</span><span class="whitespace">
  </span><span class="punctuation">}</span><span class="whitespace">

  </span><span class="keyword type">void</span><span class="whitespace"> </span><span class="name">remove_torrent</span><span class="punctuation">(</span><span class="name">lt</span><span class="operator">::</span><span class="name">storage_index_t</span><span class="whitespace"> </span><span class="keyword">const</span><span class="whitespace"> </span><span class="name">idx</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="keyword">override</span><span class="whitespace">
  </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="name">m_torrents</span><span class="punctuation">[</span><span class="name">idx</span><span class="punctuation">].</span><span class="name">reset</span><span class="punctuation">();</span><span class="whitespace">
    </span><span class="name">m_free_slots</span><span class="punctuation">.</span><span class="name">push_back</span><span class="punctuation">(</span><span class="name">idx</span><span class="punctuation">);</span><span class="whitespace">
  </span><span class="punctuation">}</span><span class="whitespace">

  </span><span class="keyword type">void</span><span class="whitespace"> </span><span class="name">abort</span><span class="punctuation">(</span><span class="keyword type">bool</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="keyword">override</span><span class="whitespace"> </span><span class="punctuation">{}</span><span class="whitespace">

  </span><span class="keyword type">void</span><span class="whitespace"> </span><span class="name">async_read</span><span class="punctuation">(</span><span class="name">lt</span><span class="operator">::</span><span class="name">storage_index_t</span><span class="whitespace"> </span><span class="name">storage</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">lt</span><span class="operator">::</span><span class="name">peer_request</span><span class="whitespace"> </span><span class="keyword">const</span><span class="operator">&amp;</span><span class="whitespace"> </span><span class="name">r</span><span class="whitespace">
    </span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">std</span><span class="operator">::</span><span class="name">function</span><span class="operator">&lt;</span><span class="keyword type">void</span><span class="punctuation">(</span><span class="name">lt</span><span class="operator">::</span><span class="name">disk_buffer_holder</span><span class="whitespace"> </span><span class="name">block</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">lt</span><span class="operator">::</span><span class="name">storage_error</span><span class="whitespace"> </span><span class="keyword">const</span><span class="operator">&amp;</span><span class="whitespace"> </span><span class="name">se</span><span class="punctuation">)</span><span class="operator">&gt;</span><span class="whitespace"> </span><span class="name">handler</span><span class="whitespace">
    </span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">lt</span><span class="operator">::</span><span class="name">disk_job_flags_t</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="keyword">override</span><span class="whitespace">
  </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="comment single">// this buffer is owned by the storage. It will remain valid for as
</span><span class="whitespace">    </span><span class="comment single">// long as the torrent remains in the session. We don't need any lifetime
</span><span class="whitespace">    </span><span class="comment single">// management of it.
</span><span class="whitespace">    </span><span class="name">lt</span><span class="operator">::</span><span class="name">storage_error</span><span class="whitespace"> </span><span class="name">error</span><span class="punctuation">;</span><span class="whitespace">
    </span><span class="name">lt</span><span class="operator">::</span><span class="name">span</span><span class="operator">&lt;</span><span class="keyword type">char</span><span class="whitespace"> </span><span class="keyword">const</span><span class="operator">&gt;</span><span class="whitespace"> </span><span class="name">b</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">m_torrents</span><span class="punctuation">[</span><span class="name">storage</span><span class="punctuation">]</span><span class="operator">-&gt;</span><span class="name">readv</span><span class="punctuation">(</span><span class="name">r</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">error</span><span class="punctuation">);</span><span class="whitespace">

    </span><span class="name">post</span><span class="punctuation">(</span><span class="name">m_ioc</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="punctuation">[</span><span class="name">handler</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">error</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">b</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="keyword">this</span><span class="punctuation">]</span><span class="whitespace">
      </span><span class="punctuation">{</span><span class="whitespace"> </span><span class="name">handler</span><span class="punctuation">(</span><span class="name">lt</span><span class="operator">::</span><span class="name">disk_buffer_holder</span><span class="punctuation">(</span><span class="operator">*</span><span class="keyword">this</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="keyword">const_cast</span><span class="operator">&lt;</span><span class="keyword type">char</span><span class="operator">*&gt;</span><span class="punctuation">(</span><span class="name">b</span><span class="punctuation">.</span><span class="name">data</span><span class="punctuation">()),</span><span class="whitespace"> </span><span class="keyword type">int</span><span class="punctuation">(</span><span class="name">b</span><span class="punctuation">.</span><span class="name">size</span><span class="punctuation">())),</span><span class="whitespace"> </span><span class="name">error</span><span class="punctuation">);</span><span class="whitespace"> </span><span class="punctuation">});</span><span class="whitespace">
  </span><span class="punctuation">}</span><span class="whitespace">

  </span><span class="keyword type">bool</span><span class="whitespace"> </span><span class="name">async_write</span><span class="punctuation">(</span><span class="name">lt</span><span class="operator">::</span><span class="name">storage_index_t</span><span class="whitespace"> </span><span class="name">storage</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">lt</span><span class="operator">::</span><span class="name">peer_request</span><span class="whitespace"> </span><span class="keyword">const</span><span class="operator">&amp;</span><span class="whitespace"> </span><span class="name">r</span><span class="whitespace">
    </span><span class="punctuation">,</span><span class="whitespace"> </span><span class="keyword type">char</span><span class="whitespace"> </span><span class="keyword">const</span><span class="operator">*</span><span class="whitespace"> </span><span class="name">buf</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">std</span><span class="operator">::</span><span class="name">shared_ptr</span><span class="operator">&lt;</span><span class="name">lt</span><span class="operator">::</span><span class="name">disk_observer</span><span class="operator">&gt;</span><span class="whitespace">
    </span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">std</span><span class="operator">::</span><span class="name">function</span><span class="operator">&lt;</span><span class="keyword type">void</span><span class="punctuation">(</span><span class="name">lt</span><span class="operator">::</span><span class="name">storage_error</span><span class="whitespace"> </span><span class="keyword">const</span><span class="operator">&amp;</span><span class="punctuation">)</span><span class="operator">&gt;</span><span class="whitespace"> </span><span class="name">handler</span><span class="whitespace">
    </span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">lt</span><span class="operator">::</span><span class="name">disk_job_flags_t</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="keyword">override</span><span class="whitespace">
  </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="name">lt</span><span class="operator">::</span><span class="name">span</span><span class="operator">&lt;</span><span class="keyword type">char</span><span class="whitespace"> </span><span class="keyword">const</span><span class="operator">&gt;</span><span class="whitespace"> </span><span class="keyword">const</span><span class="whitespace"> </span><span class="name">b</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="punctuation">{</span><span class="whitespace"> </span><span class="name">buf</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">r</span><span class="punctuation">.</span><span class="name">length</span><span class="whitespace"> </span><span class="punctuation">};</span><span class="whitespace">

    </span><span class="name">m_torrents</span><span class="punctuation">[</span><span class="name">storage</span><span class="punctuation">]</span><span class="operator">-&gt;</span><span class="name">writev</span><span class="punctuation">(</span><span class="name">b</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">r</span><span class="punctuation">.</span><span class="name">piece</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">r</span><span class="punctuation">.</span><span class="name">start</span><span class="punctuation">);</span><span class="whitespace">

    </span><span class="name">post</span><span class="punctuation">(</span><span class="name">m_ioc</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="punctuation">[</span><span class="operator">=</span><span class="punctuation">]{</span><span class="whitespace"> </span><span class="name">handler</span><span class="punctuation">(</span><span class="name">lt</span><span class="operator">::</span><span class="name">storage_error</span><span class="punctuation">());</span><span class="whitespace"> </span><span class="punctuation">});</span><span class="whitespace">
    </span><span class="keyword">return</span><span class="whitespace"> </span><span class="name builtin">false</span><span class="punctuation">;</span><span class="whitespace">
  </span><span class="punctuation">}</span><span class="whitespace">

  </span><span class="keyword type">void</span><span class="whitespace"> </span><span class="name">async_hash</span><span class="punctuation">(</span><span class="name">lt</span><span class="operator">::</span><span class="name">storage_index_t</span><span class="whitespace"> </span><span class="name">storage</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">lt</span><span class="operator">::</span><span class="name">piece_index_t</span><span class="whitespace"> </span><span class="keyword">const</span><span class="whitespace"> </span><span class="name">piece</span><span class="whitespace">
    </span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">lt</span><span class="operator">::</span><span class="name">span</span><span class="operator">&lt;</span><span class="name">lt</span><span class="operator">::</span><span class="name">sha256_hash</span><span class="operator">&gt;</span><span class="whitespace"> </span><span class="name">block_hashes</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">lt</span><span class="operator">::</span><span class="name">disk_job_flags_t</span><span class="whitespace">
    </span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">std</span><span class="operator">::</span><span class="name">function</span><span class="operator">&lt;</span><span class="keyword type">void</span><span class="punctuation">(</span><span class="name">lt</span><span class="operator">::</span><span class="name">piece_index_t</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">lt</span><span class="operator">::</span><span class="name">sha1_hash</span><span class="whitespace"> </span><span class="keyword">const</span><span class="operator">&amp;</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">lt</span><span class="operator">::</span><span class="name">storage_error</span><span class="whitespace"> </span><span class="keyword">const</span><span class="operator">&amp;</span><span class="punctuation">)</span><span class="operator">&gt;</span><span class="whitespace"> </span><span class="name">handler</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="keyword">override</span><span class="whitespace">
  </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="name">lt</span><span class="operator">::</span><span class="name">storage_error</span><span class="whitespace"> </span><span class="name">error</span><span class="punctuation">;</span><span class="whitespace">
    </span><span class="name">lt</span><span class="operator">::</span><span class="name">sha1_hash</span><span class="whitespace"> </span><span class="keyword">const</span><span class="whitespace"> </span><span class="name">hash</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">m_torrents</span><span class="punctuation">[</span><span class="name">storage</span><span class="punctuation">]</span><span class="operator">-&gt;</span><span class="name">hash</span><span class="punctuation">(</span><span class="name">piece</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">block_hashes</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">error</span><span class="punctuation">);</span><span class="whitespace">
    </span><span class="name">post</span><span class="punctuation">(</span><span class="name">m_ioc</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="punctuation">[</span><span class="operator">=</span><span class="punctuation">]{</span><span class="whitespace"> </span><span class="name">handler</span><span class="punctuation">(</span><span class="name">piece</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">hash</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">error</span><span class="punctuation">);</span><span class="whitespace"> </span><span class="punctuation">});</span><span class="whitespace">
  </span><span class="punctuation">}</span><span class="whitespace">

  </span><span class="keyword type">void</span><span class="whitespace"> </span><span class="name">async_hash2</span><span class="punctuation">(</span><span class="name">lt</span><span class="operator">::</span><span class="name">storage_index_t</span><span class="whitespace"> </span><span class="name">storage</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">lt</span><span class="operator">::</span><span class="name">piece_index_t</span><span class="whitespace"> </span><span class="keyword">const</span><span class="whitespace"> </span><span class="name">piece</span><span class="whitespace">
    </span><span class="punctuation">,</span><span class="whitespace"> </span><span class="keyword type">int</span><span class="whitespace"> </span><span class="keyword">const</span><span class="whitespace"> </span><span class="name">offset</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">lt</span><span class="operator">::</span><span class="name">disk_job_flags_t</span><span class="whitespace">
    </span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">std</span><span class="operator">::</span><span class="name">function</span><span class="operator">&lt;</span><span class="keyword type">void</span><span class="punctuation">(</span><span class="name">lt</span><span class="operator">::</span><span class="name">piece_index_t</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">lt</span><span class="operator">::</span><span class="name">sha256_hash</span><span class="whitespace"> </span><span class="keyword">const</span><span class="operator">&amp;</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">lt</span><span class="operator">::</span><span class="name">storage_error</span><span class="whitespace"> </span><span class="keyword">const</span><span class="operator">&amp;</span><span class="punctuation">)</span><span class="operator">&gt;</span><span class="whitespace"> </span><span class="name">handler</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="keyword">override</span><span class="whitespace">
  </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="name">lt</span><span class="operator">::</span><span class="name">storage_error</span><span class="whitespace"> </span><span class="name">error</span><span class="punctuation">;</span><span class="whitespace">
    </span><span class="name">lt</span><span class="operator">::</span><span class="name">sha256_hash</span><span class="whitespace"> </span><span class="keyword">const</span><span class="whitespace"> </span><span class="name">hash</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">m_torrents</span><span class="punctuation">[</span><span class="name">storage</span><span class="punctuation">]</span><span class="operator">-&gt;</span><span class="name">hash2</span><span class="punctuation">(</span><span class="name">piece</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">offset</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">error</span><span class="punctuation">);</span><span class="whitespace">
    </span><span class="name">post</span><span class="punctuation">(</span><span class="name">m_ioc</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="punctuation">[</span><span class="operator">=</span><span class="punctuation">]{</span><span class="whitespace"> </span><span class="name">handler</span><span class="punctuation">(</span><span class="name">piece</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">hash</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">error</span><span class="punctuation">);</span><span class="whitespace"> </span><span class="punctuation">});</span><span class="whitespace">
  </span><span class="punctuation">}</span><span class="whitespace">

  </span><span class="keyword type">void</span><span class="whitespace"> </span><span class="name">async_move_storage</span><span class="punctuation">(</span><span class="name">lt</span><span class="operator">::</span><span class="name">storage_index_t</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">std</span><span class="operator">::</span><span class="name">string</span><span class="whitespace"> </span><span class="name">p</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">lt</span><span class="operator">::</span><span class="name">move_flags_t</span><span class="whitespace">
    </span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">std</span><span class="operator">::</span><span class="name">function</span><span class="operator">&lt;</span><span class="keyword type">void</span><span class="punctuation">(</span><span class="name">lt</span><span class="operator">::</span><span class="name">status_t</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">std</span><span class="operator">::</span><span class="name">string</span><span class="whitespace"> </span><span class="keyword">const</span><span class="operator">&amp;</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">lt</span><span class="operator">::</span><span class="name">storage_error</span><span class="whitespace"> </span><span class="keyword">const</span><span class="operator">&amp;</span><span class="punctuation">)</span><span class="operator">&gt;</span><span class="whitespace"> </span><span class="name">handler</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="keyword">override</span><span class="whitespace">
  </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="name">post</span><span class="punctuation">(</span><span class="name">m_ioc</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="punctuation">[</span><span class="operator">=</span><span class="punctuation">]{</span><span class="whitespace">
      </span><span class="name">handler</span><span class="punctuation">(</span><span class="name">lt</span><span class="operator">::</span><span class="name">status_t</span><span class="operator">::</span><span class="name">fatal_disk_error</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">p</span><span class="whitespace">
        </span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">lt</span><span class="operator">::</span><span class="name">storage_error</span><span class="punctuation">(</span><span class="name">lt</span><span class="operator">::</span><span class="name">error_code</span><span class="punctuation">(</span><span class="name">boost</span><span class="operator">::</span><span class="name">system</span><span class="operator">::</span><span class="name">errc</span><span class="operator">::</span><span class="name">operation_not_supported</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">lt</span><span class="operator">::</span><span class="name">system_category</span><span class="punctuation">())));</span><span class="whitespace">
    </span><span class="punctuation">});</span><span class="whitespace">
  </span><span class="punctuation">}</span><span class="whitespace">

  </span><span class="keyword type">void</span><span class="whitespace"> </span><span class="name">async_release_files</span><span class="punctuation">(</span><span class="name">lt</span><span class="operator">::</span><span class="name">storage_index_t</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">std</span><span class="operator">::</span><span class="name">function</span><span class="operator">&lt;</span><span class="keyword type">void</span><span class="punctuation">()</span><span class="operator">&gt;</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="keyword">override</span><span class="whitespace"> </span><span class="punctuation">{}</span><span class="whitespace">

  </span><span class="keyword type">void</span><span class="whitespace"> </span><span class="name">async_delete_files</span><span class="punctuation">(</span><span class="name">lt</span><span class="operator">::</span><span class="name">storage_index_t</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">lt</span><span class="operator">::</span><span class="name">remove_flags_t</span><span class="whitespace">
    </span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">std</span><span class="operator">::</span><span class="name">function</span><span class="operator">&lt;</span><span class="keyword type">void</span><span class="punctuation">(</span><span class="name">lt</span><span class="operator">::</span><span class="name">storage_error</span><span class="whitespace"> </span><span class="keyword">const</span><span class="operator">&amp;</span><span class="punctuation">)</span><span class="operator">&gt;</span><span class="whitespace"> </span><span class="name">handler</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="keyword">override</span><span class="whitespace">
  </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="name">post</span><span class="punctuation">(</span><span class="name">m_ioc</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="punctuation">[</span><span class="operator">=</span><span class="punctuation">]{</span><span class="whitespace"> </span><span class="name">handler</span><span class="punctuation">(</span><span class="name">lt</span><span class="operator">::</span><span class="name">storage_error</span><span class="punctuation">());</span><span class="whitespace"> </span><span class="punctuation">});</span><span class="whitespace">
  </span><span class="punctuation">}</span><span class="whitespace">

  </span><span class="keyword type">void</span><span class="whitespace"> </span><span class="name">async_check_files</span><span class="punctuation">(</span><span class="name">lt</span><span class="operator">::</span><span class="name">storage_index_t</span><span class="whitespace">
    </span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">lt</span><span class="operator">::</span><span class="name">add_torrent_params</span><span class="whitespace"> </span><span class="keyword">const</span><span class="operator">*</span><span class="whitespace">
    </span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">lt</span><span class="operator">::</span><span class="name">aux</span><span class="operator">::</span><span class="name">vector</span><span class="operator">&lt;</span><span class="name">std</span><span class="operator">::</span><span class="name">string</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">lt</span><span class="operator">::</span><span class="name">file_index_t</span><span class="operator">&gt;</span><span class="whitespace">
    </span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">std</span><span class="operator">::</span><span class="name">function</span><span class="operator">&lt;</span><span class="keyword type">void</span><span class="punctuation">(</span><span class="name">lt</span><span class="operator">::</span><span class="name">status_t</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">lt</span><span class="operator">::</span><span class="name">storage_error</span><span class="whitespace"> </span><span class="keyword">const</span><span class="operator">&amp;</span><span class="punctuation">)</span><span class="operator">&gt;</span><span class="whitespace"> </span><span class="name">handler</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="keyword">override</span><span class="whitespace">
  </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="name">post</span><span class="punctuation">(</span><span class="name">m_ioc</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="punctuation">[</span><span class="operator">=</span><span class="punctuation">]{</span><span class="whitespace"> </span><span class="name">handler</span><span class="punctuation">(</span><span class="name">lt</span><span class="operator">::</span><span class="name">status_t</span><span class="operator">::</span><span class="name">no_error</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">lt</span><span class="operator">::</span><span class="name">storage_error</span><span class="punctuation">());</span><span class="whitespace"> </span><span class="punctuation">});</span><span class="whitespace">
  </span><span class="punctuation">}</span><span class="whitespace">

  </span><span class="keyword type">void</span><span class="whitespace"> </span><span class="name">async_rename_file</span><span class="punctuation">(</span><span class="name">lt</span><span class="operator">::</span><span class="name">storage_index_t</span><span class="whitespace">
    </span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">lt</span><span class="operator">::</span><span class="name">file_index_t</span><span class="whitespace"> </span><span class="keyword">const</span><span class="whitespace"> </span><span class="name">idx</span><span class="whitespace">
    </span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">std</span><span class="operator">::</span><span class="name">string</span><span class="whitespace"> </span><span class="keyword">const</span><span class="whitespace"> </span><span class="name">name</span><span class="whitespace">
    </span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">std</span><span class="operator">::</span><span class="name">function</span><span class="operator">&lt;</span><span class="keyword type">void</span><span class="punctuation">(</span><span class="name">std</span><span class="operator">::</span><span class="name">string</span><span class="whitespace"> </span><span class="keyword">const</span><span class="operator">&amp;</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">lt</span><span class="operator">::</span><span class="name">file_index_t</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">lt</span><span class="operator">::</span><span class="name">storage_error</span><span class="whitespace"> </span><span class="keyword">const</span><span class="operator">&amp;</span><span class="punctuation">)</span><span class="operator">&gt;</span><span class="whitespace"> </span><span class="name">handler</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="keyword">override</span><span class="whitespace">
  </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="name">post</span><span class="punctuation">(</span><span class="name">m_ioc</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="punctuation">[</span><span class="operator">=</span><span class="punctuation">]{</span><span class="whitespace"> </span><span class="name">handler</span><span class="punctuation">(</span><span class="name">name</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">idx</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">lt</span><span class="operator">::</span><span class="name">storage_error</span><span class="punctuation">());</span><span class="whitespace"> </span><span class="punctuation">});</span><span class="whitespace">
  </span><span class="punctuation">}</span><span class="whitespace">

  </span><span class="keyword type">void</span><span class="whitespace"> </span><span class="name">async_stop_torrent</span><span class="punctuation">(</span><span class="name">lt</span><span class="operator">::</span><span class="name">storage_index_t</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">std</span><span class="operator">::</span><span class="name">function</span><span class="operator">&lt;</span><span class="keyword type">void</span><span class="punctuation">()</span><span class="operator">&gt;</span><span class="whitespace"> </span><span class="name">handler</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="keyword">override</span><span class="whitespace">
  </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="name">post</span><span class="punctuation">(</span><span class="name">m_ioc</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">handler</span><span class="punctuation">);</span><span class="whitespace">
  </span><span class="punctuation">}</span><span class="whitespace">

  </span><span class="keyword type">void</span><span class="whitespace"> </span><span class="name">async_set_file_priority</span><span class="punctuation">(</span><span class="name">lt</span><span class="operator">::</span><span class="name">storage_index_t</span><span class="whitespace">
    </span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">lt</span><span class="operator">::</span><span class="name">aux</span><span class="operator">::</span><span class="name">vector</span><span class="operator">&lt;</span><span class="name">lt</span><span class="operator">::</span><span class="name">download_priority_t</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">lt</span><span class="operator">::</span><span class="name">file_index_t</span><span class="operator">&gt;</span><span class="whitespace"> </span><span class="name">prio</span><span class="whitespace">
    </span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">std</span><span class="operator">::</span><span class="name">function</span><span class="operator">&lt;</span><span class="keyword type">void</span><span class="punctuation">(</span><span class="name">lt</span><span class="operator">::</span><span class="name">storage_error</span><span class="whitespace"> </span><span class="keyword">const</span><span class="operator">&amp;</span><span class="whitespace">
      </span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">lt</span><span class="operator">::</span><span class="name">aux</span><span class="operator">::</span><span class="name">vector</span><span class="operator">&lt;</span><span class="name">lt</span><span class="operator">::</span><span class="name">download_priority_t</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">lt</span><span class="operator">::</span><span class="name">file_index_t</span><span class="operator">&gt;</span><span class="punctuation">)</span><span class="operator">&gt;</span><span class="whitespace"> </span><span class="name">handler</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="keyword">override</span><span class="whitespace">
  </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="name">post</span><span class="punctuation">(</span><span class="name">m_ioc</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="punctuation">[</span><span class="operator">=</span><span class="punctuation">]{</span><span class="whitespace">
      </span><span class="name">handler</span><span class="punctuation">(</span><span class="name">lt</span><span class="operator">::</span><span class="name">storage_error</span><span class="punctuation">(</span><span class="name">lt</span><span class="operator">::</span><span class="name">error_code</span><span class="punctuation">(</span><span class="whitespace">
        </span><span class="name">boost</span><span class="operator">::</span><span class="name">system</span><span class="operator">::</span><span class="name">errc</span><span class="operator">::</span><span class="name">operation_not_supported</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">lt</span><span class="operator">::</span><span class="name">system_category</span><span class="punctuation">())),</span><span class="whitespace"> </span><span class="name">std</span><span class="operator">::</span><span class="name">move</span><span class="punctuation">(</span><span class="name">prio</span><span class="punctuation">));</span><span class="whitespace">
    </span><span class="punctuation">});</span><span class="whitespace">
  </span><span class="punctuation">}</span><span class="whitespace">

  </span><span class="keyword type">void</span><span class="whitespace"> </span><span class="name">async_clear_piece</span><span class="punctuation">(</span><span class="name">lt</span><span class="operator">::</span><span class="name">storage_index_t</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">lt</span><span class="operator">::</span><span class="name">piece_index_t</span><span class="whitespace"> </span><span class="name">index</span><span class="whitespace">
    </span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">std</span><span class="operator">::</span><span class="name">function</span><span class="operator">&lt;</span><span class="keyword type">void</span><span class="punctuation">(</span><span class="name">lt</span><span class="operator">::</span><span class="name">piece_index_t</span><span class="punctuation">)</span><span class="operator">&gt;</span><span class="whitespace"> </span><span class="name">handler</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="keyword">override</span><span class="whitespace">
  </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="name">post</span><span class="punctuation">(</span><span class="name">m_ioc</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="punctuation">[</span><span class="operator">=</span><span class="punctuation">]{</span><span class="whitespace"> </span><span class="name">handler</span><span class="punctuation">(</span><span class="name">index</span><span class="punctuation">);</span><span class="whitespace"> </span><span class="punctuation">});</span><span class="whitespace">
  </span><span class="punctuation">}</span><span class="whitespace">

  </span><span class="comment single">// implements buffer_allocator_interface
</span><span class="whitespace">  </span><span class="keyword type">void</span><span class="whitespace"> </span><span class="name">free_disk_buffer</span><span class="punctuation">(</span><span class="keyword type">char</span><span class="operator">*</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="keyword">override</span><span class="whitespace">
  </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="comment single">// never free any buffer. We only return buffers owned by the storage
</span><span class="whitespace">    </span><span class="comment single">// object
</span><span class="whitespace">  </span><span class="punctuation">}</span><span class="whitespace">

  </span><span class="keyword type">void</span><span class="whitespace"> </span><span class="name">update_stats_counters</span><span class="punctuation">(</span><span class="name">lt</span><span class="operator">::</span><span class="name">counters</span><span class="operator">&amp;</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="keyword">const</span><span class="whitespace"> </span><span class="keyword">override</span><span class="whitespace"> </span><span class="punctuation">{}</span><span class="whitespace">

  </span><span class="name">std</span><span class="operator">::</span><span class="name">vector</span><span class="operator">&lt;</span><span class="name">lt</span><span class="operator">::</span><span class="name">open_file_state</span><span class="operator">&gt;</span><span class="whitespace"> </span><span class="name">get_status</span><span class="punctuation">(</span><span class="name">lt</span><span class="operator">::</span><span class="name">storage_index_t</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="keyword">const</span><span class="whitespace"> </span><span class="keyword">override</span><span class="whitespace">
  </span><span class="punctuation">{</span><span class="whitespace"> </span><span class="keyword">return</span><span class="whitespace"> </span><span class="punctuation">{};</span><span class="whitespace"> </span><span class="punctuation">}</span><span class="whitespace">

  </span><span class="keyword type">void</span><span class="whitespace"> </span><span class="name">submit_jobs</span><span class="punctuation">()</span><span class="whitespace"> </span><span class="keyword">override</span><span class="whitespace"> </span><span class="punctuation">{}</span><span class="whitespace">

</span><span class="keyword">private</span><span class="operator">:</span><span class="whitespace">

  </span><span class="name">lt</span><span class="operator">::</span><span class="name">aux</span><span class="operator">::</span><span class="name">vector</span><span class="operator">&lt;</span><span class="name">std</span><span class="operator">::</span><span class="name">shared_ptr</span><span class="operator">&lt;</span><span class="name">temp_storage</span><span class="operator">&gt;</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">lt</span><span class="operator">::</span><span class="name">storage_index_t</span><span class="operator">&gt;</span><span class="whitespace"> </span><span class="name">m_torrents</span><span class="punctuation">;</span><span class="whitespace">

  </span><span class="comment single">// slots that are unused in the m_torrents vector
</span><span class="whitespace">  </span><span class="name">std</span><span class="operator">::</span><span class="name">vector</span><span class="operator">&lt;</span><span class="name">lt</span><span class="operator">::</span><span class="name">storage_index_t</span><span class="operator">&gt;</span><span class="whitespace"> </span><span class="name">m_free_slots</span><span class="punctuation">;</span><span class="whitespace">

  </span><span class="comment single">// callbacks are posted on this
</span><span class="whitespace">  </span><span class="name">lt</span><span class="operator">::</span><span class="name">io_context</span><span class="operator">&amp;</span><span class="whitespace"> </span><span class="name">m_ioc</span><span class="punctuation">;</span><span class="whitespace">
</span><span class="punctuation">};</span><span class="whitespace">

</span><span class="name">std</span><span class="operator">::</span><span class="name">unique_ptr</span><span class="operator">&lt;</span><span class="name">lt</span><span class="operator">::</span><span class="name">disk_interface</span><span class="operator">&gt;</span><span class="whitespace"> </span><span class="name">temp_disk_constructor</span><span class="punctuation">(</span><span class="whitespace">
  </span><span class="name">lt</span><span class="operator">::</span><span class="name">io_context</span><span class="operator">&amp;</span><span class="whitespace"> </span><span class="name">ioc</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">lt</span><span class="operator">::</span><span class="name">settings_interface</span><span class="whitespace"> </span><span class="keyword">const</span><span class="operator">&amp;</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">lt</span><span class="operator">::</span><span class="name">counters</span><span class="operator">&amp;</span><span class="punctuation">)</span><span class="whitespace">
</span><span class="punctuation">{</span><span class="whitespace">
  </span><span class="keyword">return</span><span class="whitespace"> </span><span class="name">std</span><span class="operator">::</span><span class="name">make_unique</span><span class="operator">&lt;</span><span class="name">temp_disk_io</span><span class="operator">&gt;</span><span class="punctuation">(</span><span class="name">ioc</span><span class="punctuation">);</span><span class="whitespace">
</span><span class="punctuation">}</span>
</pre>
<a name="disk_observer"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+disk_observer&labels=documentation&body=Documentation+under+heading+%22class+disk_observer%22+could+be+improved">report issue</a>]</span><div class="section" id="disk-observer">
<h1>disk_observer</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/disk_observer.hpp">libtorrent/disk_observer.hpp</a>&quot;</p>
<pre class="literal-block">
struct disk_observer
{
   virtual void <strong>on_disk</strong> () = 0;
};
</pre>
<a name="on_disk()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:disk_observer%3A%3A%5Bon_disk%28%29%5D&labels=documentation&body=Documentation+under+heading+%22disk_observer%3A%3A%5Bon_disk%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="on-disk">
<h2>on_disk()</h2>
<pre class="literal-block">
virtual void <strong>on_disk</strong> () = 0;
</pre>
<p>called when the disk cache size has dropped
below the low watermark again and we can
resume downloading from peers</p>
<a name="buffer_allocator_interface"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+buffer_allocator_interface&labels=documentation&body=Documentation+under+heading+%22class+buffer_allocator_interface%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="buffer-allocator-interface">
<h1>buffer_allocator_interface</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/disk_buffer_holder.hpp">libtorrent/disk_buffer_holder.hpp</a>&quot;</p>
<p>the interface for freeing disk buffers, used by the <a class="reference external" href="reference-Custom_Storage.html#disk_buffer_holder">disk_buffer_holder</a>.
when implementing <a class="reference external" href="reference-Custom_Storage.html#disk_interface">disk_interface</a>, this must also be implemented in order
to return disk buffers back to libtorrent</p>
<pre class="literal-block">
struct buffer_allocator_interface
{
   virtual void <strong>free_disk_buffer</strong> (char* b) = 0;
};
</pre>
<a name="disk_buffer_holder"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+disk_buffer_holder&labels=documentation&body=Documentation+under+heading+%22class+disk_buffer_holder%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="disk-buffer-holder">
<h1>disk_buffer_holder</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/disk_buffer_holder.hpp">libtorrent/disk_buffer_holder.hpp</a>&quot;</p>
<p>The disk buffer holder acts like a <tt class="docutils literal">unique_ptr</tt> that frees a disk buffer
when it's destructed</p>
<p>If this buffer holder is moved-from, default constructed or reset,
<tt class="docutils literal">data()</tt> will return nullptr.</p>
<pre class="literal-block">
struct disk_buffer_holder
{
   disk_buffer_holder&amp; <strong>operator=</strong> (disk_buffer_holder&amp;&amp;) &amp; noexcept;
   <strong>disk_buffer_holder</strong> (disk_buffer_holder&amp;&amp;) noexcept;
   <strong>disk_buffer_holder</strong> (disk_buffer_holder const&amp;) = delete;
   disk_buffer_holder&amp; <strong>operator=</strong> (disk_buffer_holder const&amp;) = delete;
   <strong>disk_buffer_holder</strong> (buffer_allocator_interface&amp; alloc
      , char* buf, int sz) noexcept;
   <strong>disk_buffer_holder</strong> () noexcept = default;
   <strong>~disk_buffer_holder</strong> ();
   char* <strong>data</strong> () const noexcept;
   void <strong>reset</strong> ();
   void <strong>swap</strong> (disk_buffer_holder&amp; h) noexcept;
   bool <strong>is_mutable</strong> () const noexcept;
   explicit operator <strong>bool</strong> () const noexcept;
   std::ptrdiff_t <strong>size</strong> () const;
};
</pre>
<a name="disk_buffer_holder()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:disk_buffer_holder%3A%3A%5Bdisk_buffer_holder%28%29%5D&labels=documentation&body=Documentation+under+heading+%22disk_buffer_holder%3A%3A%5Bdisk_buffer_holder%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="disk-buffer-holder-1">
<h2>disk_buffer_holder()</h2>
<pre class="literal-block">
<strong>disk_buffer_holder</strong> (buffer_allocator_interface&amp; alloc
      , char* buf, int sz) noexcept;
</pre>
<p>construct a buffer holder that will free the held buffer
using a disk buffer pool directly (there's only one
disk_buffer_pool per <a class="reference external" href="reference-Session.html#session">session</a>)</p>
<a name="disk_buffer_holder()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:disk_buffer_holder%3A%3A%5Bdisk_buffer_holder%28%29%5D&labels=documentation&body=Documentation+under+heading+%22disk_buffer_holder%3A%3A%5Bdisk_buffer_holder%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="disk-buffer-holder-2">
<h2>disk_buffer_holder()</h2>
<pre class="literal-block">
<strong>disk_buffer_holder</strong> () noexcept = default;
</pre>
<p>default construct a holder that does not own any buffer</p>
<a name="~disk_buffer_holder()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:disk_buffer_holder%3A%3A%5B~disk_buffer_holder%28%29%5D&labels=documentation&body=Documentation+under+heading+%22disk_buffer_holder%3A%3A%5B~disk_buffer_holder%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="disk-buffer-holder-3">
<h2>~disk_buffer_holder()</h2>
<pre class="literal-block">
<strong>~disk_buffer_holder</strong> ();
</pre>
<p>frees disk buffer held by this object</p>
<a name="data()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:disk_buffer_holder%3A%3A%5Bdata%28%29%5D&labels=documentation&body=Documentation+under+heading+%22disk_buffer_holder%3A%3A%5Bdata%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="data">
<h2>data()</h2>
<pre class="literal-block">
char* <strong>data</strong> () const noexcept;
</pre>
<p>return a pointer to the held buffer, if any. Otherwise returns nullptr.</p>
<a name="reset()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:disk_buffer_holder%3A%3A%5Breset%28%29%5D&labels=documentation&body=Documentation+under+heading+%22disk_buffer_holder%3A%3A%5Breset%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="reset">
<h2>reset()</h2>
<pre class="literal-block">
void <strong>reset</strong> ();
</pre>
<p>free the held disk buffer, if any, and clear the holder. This sets the
holder object to a default-constructed state</p>
<a name="swap()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:disk_buffer_holder%3A%3A%5Bswap%28%29%5D&labels=documentation&body=Documentation+under+heading+%22disk_buffer_holder%3A%3A%5Bswap%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="swap">
<h2>swap()</h2>
<pre class="literal-block">
void <strong>swap</strong> (disk_buffer_holder&amp; h) noexcept;
</pre>
<p>swap pointers of two disk buffer holders.</p>
<a name="is_mutable()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:disk_buffer_holder%3A%3A%5Bis_mutable%28%29%5D&labels=documentation&body=Documentation+under+heading+%22disk_buffer_holder%3A%3A%5Bis_mutable%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="is-mutable">
<h2>is_mutable()</h2>
<pre class="literal-block">
bool <strong>is_mutable</strong> () const noexcept;
</pre>
<p>if this returns true, the buffer may not be modified in place</p>
<a name="bool()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:disk_buffer_holder%3A%3A%5Bbool%28%29%5D&labels=documentation&body=Documentation+under+heading+%22disk_buffer_holder%3A%3A%5Bbool%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="bool">
<h2>bool()</h2>
<pre class="literal-block">
explicit operator <strong>bool</strong> () const noexcept;
</pre>
<p>implicitly convertible to true if the object is currently holding a
buffer</p>
<a name="settings_interface"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+settings_interface&labels=documentation&body=Documentation+under+heading+%22class+settings_interface%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="settings-interface">
<h1>settings_interface</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/settings_pack.hpp">libtorrent/settings_pack.hpp</a>&quot;</p>
<p>the common interface to <a class="reference external" href="reference-Settings.html#settings_pack">settings_pack</a> and the internal representation of
settings.</p>
<pre class="literal-block">
struct settings_interface
{
   virtual void <strong>set_str</strong> (int name, std::string val) = 0;
   virtual bool <strong>has_val</strong> (int name) const = 0;
   virtual void <strong>set_bool</strong> (int name, bool val) = 0;
   virtual void <strong>set_int</strong> (int name, int val) = 0;
   virtual std::string const&amp; <strong>get_str</strong> (int name) const = 0;
   virtual int <strong>get_int</strong> (int name) const = 0;
   virtual bool <strong>get_bool</strong> (int name) const = 0;
};
</pre>
<a name="open_file_state"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+open_file_state&labels=documentation&body=Documentation+under+heading+%22class+open_file_state%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="open-file-state">
<h1>open_file_state</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/disk_interface.hpp">libtorrent/disk_interface.hpp</a>&quot;</p>
<p>this contains information about a file that's currently open by the
libtorrent disk I/O subsystem. It's associated with a single torrent.</p>
<pre class="literal-block">
struct open_file_state
{
   file_index_t file_index;
   file_open_mode_t open_mode;
   time_point last_use;
};
</pre>
<a name="file_index"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:open_file_state%3A%3A%5Bfile_index%5D&labels=documentation&body=Documentation+under+heading+%22open_file_state%3A%3A%5Bfile_index%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>file_index</dt>
<dd>the index of the file this <a class="reference external" href="reference-Bencoding.html#entry">entry</a> refers to into the <tt class="docutils literal">file_storage</tt>
file list of this torrent. This starts indexing at 0.</dd>
</dl>
<a name="open_mode"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:open_file_state%3A%3A%5Bopen_mode%5D&labels=documentation&body=Documentation+under+heading+%22open_file_state%3A%3A%5Bopen_mode%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>open_mode</dt>
<dd><p class="first"><tt class="docutils literal">open_mode</tt> is a bitmask of the file flags this file is currently
opened with. For possible flags, see <a class="reference external" href="reference-Custom_Storage.html#file_open_mode_t">file_open_mode_t</a>.</p>
<p class="last">Note that the read/write mode is not a bitmask. The two least significant bits are used
to represent the read/write mode. Those bits can be masked out using the <tt class="docutils literal">rw_mask</tt> constant.</p>
</dd>
</dl>
<a name="last_use"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:open_file_state%3A%3A%5Blast_use%5D&labels=documentation&body=Documentation+under+heading+%22open_file_state%3A%3A%5Blast_use%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>last_use</dt>
<dd>a (high precision) timestamp of when the file was last used.</dd>
</dl>
<a name="disk_interface"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+disk_interface&labels=documentation&body=Documentation+under+heading+%22class+disk_interface%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="disk-interface">
<h1>disk_interface</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/disk_interface.hpp">libtorrent/disk_interface.hpp</a>&quot;</p>
<p>The <a class="reference external" href="reference-Custom_Storage.html#disk_interface">disk_interface</a> is the customization point for disk I/O in libtorrent.
implement this interface and provide a factory function to the <a class="reference external" href="reference-Session.html#session">session</a> constructor
use custom disk I/O. All functions on the disk subsystem (implementing
<a class="reference external" href="reference-Custom_Storage.html#disk_interface">disk_interface</a>) are called from within libtorrent's network thread. For
disk I/O to be performed in a separate thread, the disk subsystem has to
manage that itself.</p>
<p>Although the functions are called <tt class="docutils literal">async_*</tt>, they do not technically
<em>have</em> to be asynchronous, but they support being asynchronous, by
expecting the result passed back into a callback. The callbacks must be
posted back onto the network thread via the io_context object passed into
the constructor. The callbacks will be run in the network thread.</p>
<pre class="literal-block">
struct disk_interface
{
   virtual storage_holder <strong>new_torrent</strong> (storage_params const&amp; p
      , std::shared_ptr&lt;void&gt; const&amp; torrent) = 0;
   virtual void <strong>remove_torrent</strong> (storage_index_t) = 0;
   virtual bool <strong>async_write</strong> (storage_index_t storage, peer_request const&amp; r
      , char const* buf, std::shared_ptr&lt;disk_observer&gt; o
      , std::function&lt;void(storage_error const&amp;)&gt; handler
      , disk_job_flags_t flags = {}) = 0;
   virtual void <strong>async_read</strong> (storage_index_t storage, peer_request const&amp; r
      , std::function&lt;void(disk_buffer_holder, storage_error const&amp;)&gt; handler
      , disk_job_flags_t flags = {}) = 0;
   virtual void <strong>async_hash</strong> (storage_index_t storage, piece_index_t piece, span&lt;sha256_hash&gt; v2
      , disk_job_flags_t flags
      , std::function&lt;void(piece_index_t, sha1_hash const&amp;, storage_error const&amp;)&gt; handler) = 0;
   virtual void <strong>async_hash2</strong> (storage_index_t storage, piece_index_t piece, int offset, disk_job_flags_t flags
      , std::function&lt;void(piece_index_t, sha256_hash const&amp;, storage_error const&amp;)&gt; handler) = 0;
   virtual void <strong>async_move_storage</strong> (storage_index_t storage, std::string p, move_flags_t flags
      , std::function&lt;void(status_t, std::string const&amp;, storage_error const&amp;)&gt; handler) = 0;
   virtual void <strong>async_release_files</strong> (storage_index_t storage
      , std::function&lt;void()&gt; handler = std::function&lt;void()&gt;()) = 0;
   virtual void <strong>async_check_files</strong> (storage_index_t storage
      , add_torrent_params const* resume_data
      , aux::vector&lt;std::string, file_index_t&gt; links
      , std::function&lt;void(status_t, storage_error const&amp;)&gt; handler) = 0;
   virtual void <strong>async_stop_torrent</strong> (storage_index_t storage
      , std::function&lt;void()&gt; handler = std::function&lt;void()&gt;()) = 0;
   virtual void <strong>async_rename_file</strong> (storage_index_t storage
      , file_index_t index, std::string name
      , std::function&lt;void(std::string const&amp;, file_index_t, storage_error const&amp;)&gt; handler) = 0;
   virtual void <strong>async_delete_files</strong> (storage_index_t storage, remove_flags_t options
      , std::function&lt;void(storage_error const&amp;)&gt; handler) = 0;
   virtual void <strong>async_set_file_priority</strong> (storage_index_t storage
      , aux::vector&lt;download_priority_t, file_index_t&gt; prio
      , std::function&lt;void(storage_error const&amp;
      , aux::vector&lt;download_priority_t, file_index_t&gt;)&gt; handler) = 0;
   virtual void <strong>async_clear_piece</strong> (storage_index_t storage, piece_index_t index
      , std::function&lt;void(piece_index_t)&gt; handler) = 0;
   virtual void <strong>update_stats_counters</strong> (counters&amp; c) const = 0;
   virtual std::vector&lt;open_file_state&gt; <strong>get_status</strong> (storage_index_t) const = 0;
   virtual void <strong>abort</strong> (bool wait) = 0;
   virtual void <strong>submit_jobs</strong> () = 0;
   virtual void <strong>settings_updated</strong> () = 0;

   static constexpr disk_job_flags_t <strong>force_copy</strong>  = 0_bit;
   static constexpr disk_job_flags_t <strong>sequential_access</strong>  = 3_bit;
   static constexpr disk_job_flags_t <strong>volatile_read</strong>  = 4_bit;
   static constexpr disk_job_flags_t <strong>v1_hash</strong>  = 5_bit;
   static constexpr disk_job_flags_t <strong>flush_piece</strong>  = 7_bit;
};
</pre>
<a name="new_torrent()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:disk_interface%3A%3A%5Bnew_torrent%28%29%5D&labels=documentation&body=Documentation+under+heading+%22disk_interface%3A%3A%5Bnew_torrent%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="new-torrent">
<h2>new_torrent()</h2>
<pre class="literal-block">
virtual storage_holder <strong>new_torrent</strong> (storage_params const&amp; p
      , std::shared_ptr&lt;void&gt; const&amp; torrent) = 0;
</pre>
<p>this is called when a new torrent is added. The shared_ptr can be
used to hold the internal torrent object alive as long as there are
outstanding disk operations on the storage.
The returned <a class="reference external" href="reference-Custom_Storage.html#storage_holder">storage_holder</a> is an owning reference to the underlying
storage that was just created. It is fundamentally a storage_index_t</p>
<a name="remove_torrent()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:disk_interface%3A%3A%5Bremove_torrent%28%29%5D&labels=documentation&body=Documentation+under+heading+%22disk_interface%3A%3A%5Bremove_torrent%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="remove-torrent">
<h2>remove_torrent()</h2>
<pre class="literal-block">
virtual void <strong>remove_torrent</strong> (storage_index_t) = 0;
</pre>
<p>remove the storage with the specified index. This is not expected to
delete any files from disk, just to clean up any resources associated
with the specified storage.</p>
<a name="async_read()"></a>
<a name="async_write()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:disk_interface%3A%3A%5Basync_read%28%29+async_write%28%29%5D&labels=documentation&body=Documentation+under+heading+%22disk_interface%3A%3A%5Basync_read%28%29+async_write%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="async-read-async-write">
<h2>async_read() async_write()</h2>
<pre class="literal-block">
virtual bool <strong>async_write</strong> (storage_index_t storage, peer_request const&amp; r
      , char const* buf, std::shared_ptr&lt;disk_observer&gt; o
      , std::function&lt;void(storage_error const&amp;)&gt; handler
      , disk_job_flags_t flags = {}) = 0;
virtual void <strong>async_read</strong> (storage_index_t storage, peer_request const&amp; r
      , std::function&lt;void(disk_buffer_holder, storage_error const&amp;)&gt; handler
      , disk_job_flags_t flags = {}) = 0;
</pre>
<p>perform a read or write operation from/to the specified storage
index and the specified request. When the operation completes, call
handler possibly with a <a class="reference external" href="reference-Custom_Storage.html#disk_buffer_holder">disk_buffer_holder</a>, holding the buffer with
the result. Flags may be set to affect the read operation. See
disk_job_flags_t.</p>
<p>The <a class="reference external" href="reference-Custom_Storage.html#disk_observer">disk_observer</a> is a callback to indicate that
the store buffer/disk write queue is below the watermark to let peers
start writing buffers to disk again. When <tt class="docutils literal">async_write()</tt> returns
<tt class="docutils literal">true</tt>, indicating the write queue is full, the peer will stop
further writes and wait for the passed-in <tt class="docutils literal">disk_observer</tt> to be
notified before resuming.</p>
<p>Note that for <tt class="docutils literal">async_read</tt>, the <a class="reference external" href="reference-Core.html#peer_request">peer_request</a> (<tt class="docutils literal">r</tt>) is not
necessarily aligned to blocks (but it is most of the time). However,
all writes (passed to <tt class="docutils literal">async_write</tt>) are guaranteed to be block
aligned.</p>
<a name="async_hash()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:disk_interface%3A%3A%5Basync_hash%28%29%5D&labels=documentation&body=Documentation+under+heading+%22disk_interface%3A%3A%5Basync_hash%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="async-hash">
<h2>async_hash()</h2>
<pre class="literal-block">
virtual void <strong>async_hash</strong> (storage_index_t storage, piece_index_t piece, span&lt;sha256_hash&gt; v2
      , disk_job_flags_t flags
      , std::function&lt;void(piece_index_t, sha1_hash const&amp;, storage_error const&amp;)&gt; handler) = 0;
</pre>
<p>Compute hash(es) for the specified piece. Unless the v1_hash flag is
set (in <tt class="docutils literal">flags</tt>), the SHA-1 hash of the whole piece does not need
to be computed.</p>
<p>The <cite>v2</cite> span is optional and can be empty, which means v2 hashes
should not be computed. If v2 is non-empty it must be at least large
enough to hold all v2 blocks in the piece, and this function will
fill in the span with the SHA-256 block hashes of the piece.</p>
<a name="async_hash2()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:disk_interface%3A%3A%5Basync_hash2%28%29%5D&labels=documentation&body=Documentation+under+heading+%22disk_interface%3A%3A%5Basync_hash2%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="async-hash2">
<h2>async_hash2()</h2>
<pre class="literal-block">
virtual void <strong>async_hash2</strong> (storage_index_t storage, piece_index_t piece, int offset, disk_job_flags_t flags
      , std::function&lt;void(piece_index_t, sha256_hash const&amp;, storage_error const&amp;)&gt; handler) = 0;
</pre>
<p>computes the v2 hash (SHA-256) of a single block. The block at
<tt class="docutils literal">offset</tt> in piece <tt class="docutils literal">piece</tt>.</p>
<a name="async_move_storage()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:disk_interface%3A%3A%5Basync_move_storage%28%29%5D&labels=documentation&body=Documentation+under+heading+%22disk_interface%3A%3A%5Basync_move_storage%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="async-move-storage">
<h2>async_move_storage()</h2>
<pre class="literal-block">
virtual void <strong>async_move_storage</strong> (storage_index_t storage, std::string p, move_flags_t flags
      , std::function&lt;void(status_t, std::string const&amp;, storage_error const&amp;)&gt; handler) = 0;
</pre>
<p>called to request the files for the specified storage/torrent be
moved to a new location. It is the disk I/O object's responsibility
to synchronize this with any currently outstanding disk operations to
the storage. Whether files are replaced at the destination path or
not is controlled by <tt class="docutils literal">flags</tt> (see <a class="reference external" href="reference-Storage.html#move_flags_t">move_flags_t</a>).</p>
<a name="async_release_files()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:disk_interface%3A%3A%5Basync_release_files%28%29%5D&labels=documentation&body=Documentation+under+heading+%22disk_interface%3A%3A%5Basync_release_files%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="async-release-files">
<h2>async_release_files()</h2>
<pre class="literal-block">
virtual void <strong>async_release_files</strong> (storage_index_t storage
      , std::function&lt;void()&gt; handler = std::function&lt;void()&gt;()) = 0;
</pre>
<p>This is called on disk I/O objects to request they close all open
files for the specified storage/torrent. If file handles are not
pooled/cached, it can be a no-op. For truly asynchronous disk I/O,
this should provide at least one point in time when all files are
closed. It is possible that later asynchronous operations will
re-open some of the files, by the time this completion handler is
called, that's fine.</p>
<a name="async_check_files()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:disk_interface%3A%3A%5Basync_check_files%28%29%5D&labels=documentation&body=Documentation+under+heading+%22disk_interface%3A%3A%5Basync_check_files%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="async-check-files">
<h2>async_check_files()</h2>
<pre class="literal-block">
virtual void <strong>async_check_files</strong> (storage_index_t storage
      , add_torrent_params const* resume_data
      , aux::vector&lt;std::string, file_index_t&gt; links
      , std::function&lt;void(status_t, storage_error const&amp;)&gt; handler) = 0;
</pre>
<p>this is called when torrents are added to validate their resume data
against the files on disk. This function is expected to do a few things:</p>
<p>if <tt class="docutils literal">links</tt> is non-empty, it contains a string for each file in the
torrent. The string being a path to an existing identical file. The
default behavior is to create hard links of those files into the
storage of the new torrent (specified by <tt class="docutils literal">storage</tt>). An empty
string indicates that there is no known identical file. This is part
of the &quot;mutable torrent&quot; feature, where files can be reused from
other torrents.</p>
<p>The <tt class="docutils literal">resume_data</tt> points the resume data passed in by the client.</p>
<p>If the <tt class="docutils literal"><span class="pre">resume_data-&gt;flags</span></tt> field has the seed_mode flag set, all
files/pieces are expected to be on disk already. This should be
verified. Not just the existence of the file, but also that it has
the correct size.</p>
<p>Any file with a piece set in the <tt class="docutils literal"><span class="pre">resume_data-&gt;have_pieces</span></tt> bitmask
should exist on disk, this should be verified. Pad files and files
with zero priority may be skipped.</p>
<a name="async_stop_torrent()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:disk_interface%3A%3A%5Basync_stop_torrent%28%29%5D&labels=documentation&body=Documentation+under+heading+%22disk_interface%3A%3A%5Basync_stop_torrent%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="async-stop-torrent">
<h2>async_stop_torrent()</h2>
<pre class="literal-block">
virtual void <strong>async_stop_torrent</strong> (storage_index_t storage
      , std::function&lt;void()&gt; handler = std::function&lt;void()&gt;()) = 0;
</pre>
<p>This is called when a torrent is stopped. It gives the disk I/O
object an opportunity to flush any data to disk that's currently kept
cached. This function should at least do the same thing as
<a class="reference external" href="reference-Custom_Storage.html#async_release_files()">async_release_files()</a>.</p>
<a name="async_rename_file()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:disk_interface%3A%3A%5Basync_rename_file%28%29%5D&labels=documentation&body=Documentation+under+heading+%22disk_interface%3A%3A%5Basync_rename_file%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="async-rename-file">
<h2>async_rename_file()</h2>
<pre class="literal-block">
virtual void <strong>async_rename_file</strong> (storage_index_t storage
      , file_index_t index, std::string name
      , std::function&lt;void(std::string const&amp;, file_index_t, storage_error const&amp;)&gt; handler) = 0;
</pre>
<p>This function is called when the name of a file in the specified
storage has been requested to be renamed. The disk I/O object is
responsible for renaming the file without racing with other
potentially outstanding operations against the file (such as read,
write, move, etc.).</p>
<a name="async_delete_files()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:disk_interface%3A%3A%5Basync_delete_files%28%29%5D&labels=documentation&body=Documentation+under+heading+%22disk_interface%3A%3A%5Basync_delete_files%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="async-delete-files">
<h2>async_delete_files()</h2>
<pre class="literal-block">
virtual void <strong>async_delete_files</strong> (storage_index_t storage, remove_flags_t options
      , std::function&lt;void(storage_error const&amp;)&gt; handler) = 0;
</pre>
<p>This function is called when some file(s) on disk have been requested
to be removed by the client. <tt class="docutils literal">storage</tt> indicates which torrent is
referred to. See <a class="reference external" href="reference-Session.html#session_handle">session_handle</a> for <tt class="docutils literal">remove_flags_t</tt> flags
indicating which files are to be removed.
e.g. <a class="reference external" href="reference-Session.html#delete_files">session_handle::delete_files</a> - delete all files
<a class="reference external" href="reference-Session.html#delete_partfile">session_handle::delete_partfile</a> - only delete part file.</p>
<a name="async_set_file_priority()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:disk_interface%3A%3A%5Basync_set_file_priority%28%29%5D&labels=documentation&body=Documentation+under+heading+%22disk_interface%3A%3A%5Basync_set_file_priority%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="async-set-file-priority">
<h2>async_set_file_priority()</h2>
<pre class="literal-block">
virtual void <strong>async_set_file_priority</strong> (storage_index_t storage
      , aux::vector&lt;download_priority_t, file_index_t&gt; prio
      , std::function&lt;void(storage_error const&amp;
      , aux::vector&lt;download_priority_t, file_index_t&gt;)&gt; handler) = 0;
</pre>
<p>This is called to set the priority of some or all files. Changing the
priority from or to 0 may involve moving data to and from the
partfile. The disk I/O object is responsible for correctly
synchronizing this work to not race with any potentially outstanding
asynchronous operations affecting these files.</p>
<p><tt class="docutils literal">prio</tt> is a vector of the file priority for all files. If it's
shorter than the total number of files in the torrent, they are
assumed to be set to the default priority.</p>
<a name="async_clear_piece()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:disk_interface%3A%3A%5Basync_clear_piece%28%29%5D&labels=documentation&body=Documentation+under+heading+%22disk_interface%3A%3A%5Basync_clear_piece%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="async-clear-piece">
<h2>async_clear_piece()</h2>
<pre class="literal-block">
virtual void <strong>async_clear_piece</strong> (storage_index_t storage, piece_index_t index
      , std::function&lt;void(piece_index_t)&gt; handler) = 0;
</pre>
<p>This is called when a piece fails the hash check, to ensure there are
no outstanding disk operations to the piece before blocks are
re-requested from peers to overwrite the existing blocks. The disk I/O
object does not need to perform any action other than synchronize
with all outstanding disk operations to the specified piece before
posting the result back.</p>
<a name="update_stats_counters()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:disk_interface%3A%3A%5Bupdate_stats_counters%28%29%5D&labels=documentation&body=Documentation+under+heading+%22disk_interface%3A%3A%5Bupdate_stats_counters%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="update-stats-counters">
<h2>update_stats_counters()</h2>
<pre class="literal-block">
virtual void <strong>update_stats_counters</strong> (counters&amp; c) const = 0;
</pre>
<p><a class="reference external" href="reference-Custom_Storage.html#update_stats_counters()">update_stats_counters()</a> is called to give the disk storage an
opportunity to update gauges in the <tt class="docutils literal">c</tt> stats <a class="reference external" href="reference-Stats.html#counters">counters</a>, that aren't
updated continuously as operations are performed. This is called
before a snapshot of the <a class="reference external" href="reference-Stats.html#counters">counters</a> are passed to the client.</p>
<a name="get_status()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:disk_interface%3A%3A%5Bget_status%28%29%5D&labels=documentation&body=Documentation+under+heading+%22disk_interface%3A%3A%5Bget_status%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="get-status">
<h2>get_status()</h2>
<pre class="literal-block">
virtual std::vector&lt;open_file_state&gt; <strong>get_status</strong> (storage_index_t) const = 0;
</pre>
<p>Return a list of all the files that are currently open for the
specified storage/torrent. This is is just used for the client to
query the currently open files, and which modes those files are open
in.</p>
<a name="abort()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:disk_interface%3A%3A%5Babort%28%29%5D&labels=documentation&body=Documentation+under+heading+%22disk_interface%3A%3A%5Babort%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="abort">
<h2>abort()</h2>
<pre class="literal-block">
virtual void <strong>abort</strong> (bool wait) = 0;
</pre>
<p>this is called when the <a class="reference external" href="reference-Session.html#session">session</a> is starting to shut down. The disk
I/O object is expected to flush any outstanding write jobs, cancel
hash jobs and initiate tearing down of any internal threads. If
<tt class="docutils literal">wait</tt> is true, this should be asynchronous. i.e. this call should
not return until all threads have stopped and all jobs have either
been aborted or completed and the disk I/O object is ready to be
destructed.</p>
<a name="submit_jobs()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:disk_interface%3A%3A%5Bsubmit_jobs%28%29%5D&labels=documentation&body=Documentation+under+heading+%22disk_interface%3A%3A%5Bsubmit_jobs%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="submit-jobs">
<h2>submit_jobs()</h2>
<pre class="literal-block">
virtual void <strong>submit_jobs</strong> () = 0;
</pre>
<p>This will be called after a batch of disk jobs has been issues (via
the <tt class="docutils literal">async_*</tt> ). It gives the disk I/O object an opportunity to
notify any potential condition variables to wake up the disk
thread(s). The <tt class="docutils literal">async_*</tt> calls can of course also notify condition
variables, but doing it in this call allows for batching jobs, by
issuing the notification once for a collection of jobs.</p>
<a name="settings_updated()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:disk_interface%3A%3A%5Bsettings_updated%28%29%5D&labels=documentation&body=Documentation+under+heading+%22disk_interface%3A%3A%5Bsettings_updated%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="settings-updated">
<h2>settings_updated()</h2>
<pre class="literal-block">
virtual void <strong>settings_updated</strong> () = 0;
</pre>
<p>This is called to notify the disk I/O object that the settings have
been updated. In the disk io constructor, a <a class="reference external" href="reference-Custom_Storage.html#settings_interface">settings_interface</a>
reference is passed in. Whenever these settings are updated, this
function is called to allow the disk I/O object to react to any
changed settings relevant to its operations.</p>
<a name="force_copy"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:disk_interface%3A%3A%5Bforce_copy%5D&labels=documentation&body=Documentation+under+heading+%22disk_interface%3A%3A%5Bforce_copy%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>force_copy</dt>
<dd>force making a copy of the cached block, rather than getting a
reference to a block already in the cache. This is used the block is
expected to be overwritten very soon, by async_write()`, and we need
access to the previous content.</dd>
</dl>
<a name="sequential_access"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:disk_interface%3A%3A%5Bsequential_access%5D&labels=documentation&body=Documentation+under+heading+%22disk_interface%3A%3A%5Bsequential_access%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>sequential_access</dt>
<dd>hint that there may be more disk operations with sequential access to
the file</dd>
</dl>
<a name="volatile_read"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:disk_interface%3A%3A%5Bvolatile_read%5D&labels=documentation&body=Documentation+under+heading+%22disk_interface%3A%3A%5Bvolatile_read%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>volatile_read</dt>
<dd>don't keep the read block in cache. This is a hint that this block is
unlikely to be read again anytime soon, and caching it would be
wasteful.</dd>
</dl>
<a name="v1_hash"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:disk_interface%3A%3A%5Bv1_hash%5D&labels=documentation&body=Documentation+under+heading+%22disk_interface%3A%3A%5Bv1_hash%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>v1_hash</dt>
<dd>compute a v1 piece hash. This is only used by the <a class="reference external" href="reference-Custom_Storage.html#async_hash()">async_hash()</a> call.
If this flag is not set in the <a class="reference external" href="reference-Custom_Storage.html#async_hash()">async_hash()</a> call, the SHA-1 piece
hash does not need to be computed.</dd>
</dl>
<a name="flush_piece"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:disk_interface%3A%3A%5Bflush_piece%5D&labels=documentation&body=Documentation+under+heading+%22disk_interface%3A%3A%5Bflush_piece%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>flush_piece</dt>
<dd>this flag instructs a hash job that we just completed this piece, and
it should be flushed to disk</dd>
</dl>
<a name="storage_holder"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+storage_holder&labels=documentation&body=Documentation+under+heading+%22class+storage_holder%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="storage-holder">
<h1>storage_holder</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/disk_interface.hpp">libtorrent/disk_interface.hpp</a>&quot;</p>
<p>a unique, owning, reference to the storage of a torrent in a disk io
subsystem (class that implements <a class="reference external" href="reference-Custom_Storage.html#disk_interface">disk_interface</a>). This is held by the
internal libtorrent torrent object to tie the storage object allocated
for a torrent to the lifetime of the internal torrent object. When a
torrent is removed from the <a class="reference external" href="reference-Session.html#session">session</a>, this holder is destructed and will
inform the disk object.</p>
<pre class="literal-block">
struct storage_holder
{
   <strong>storage_holder</strong> (storage_index_t idx, disk_interface&amp; disk_io);
   <strong>~storage_holder</strong> ();
   <strong>storage_holder</strong> () = default;
   explicit operator <strong>bool</strong> () const;
   operator <strong>storage_index_t</strong> () const;
   void <strong>reset</strong> ();
   storage_holder&amp; <strong>operator=</strong> (storage_holder const&amp;) = delete;
   <strong>storage_holder</strong> (storage_holder const&amp;) = delete;
   <strong>storage_holder</strong> (storage_holder&amp;&amp; rhs) noexcept;
   storage_holder&amp; <strong>operator=</strong> (storage_holder&amp;&amp; rhs) noexcept;
};
</pre>
<a name="file_open_mode_t"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:file_open_mode_t&labels=documentation&body=Documentation+under+heading+%22file_open_mode_t%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="file-open-mode-t">
<h1>file_open_mode_t</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/disk_interface.hpp">libtorrent/disk_interface.hpp</a>&quot;</p>
<a name="file_open_mode_t::read_only"></a><dl class="docutils">
<dt>read_only</dt>
<dd>open the file for reading only</dd>
</dl>
<a name="file_open_mode_t::write_only"></a><dl class="docutils">
<dt>write_only</dt>
<dd>open the file for writing only</dd>
</dl>
<a name="file_open_mode_t::read_write"></a><dl class="docutils">
<dt>read_write</dt>
<dd>open the file for reading and writing</dd>
</dl>
<a name="file_open_mode_t::rw_mask"></a><dl class="docutils">
<dt>rw_mask</dt>
<dd>the mask for the bits determining read or write mode</dd>
</dl>
<a name="file_open_mode_t::sparse"></a><dl class="docutils">
<dt>sparse</dt>
<dd>open the file in sparse mode (if supported by the
filesystem).</dd>
</dl>
<a name="file_open_mode_t::no_atime"></a><dl class="docutils">
<dt>no_atime</dt>
<dd>don't update the access timestamps on the file (if
supported by the operating system and filesystem).
this generally improves disk performance.</dd>
</dl>
<a name="file_open_mode_t::random_access"></a><dl class="docutils">
<dt>random_access</dt>
<dd>When this is not set, the kernel is hinted that access to this file will
be made sequentially.</dd>
</dl>
<a name="file_open_mode_t::mmapped"></a><dl class="docutils">
<dt>mmapped</dt>
<dd>the file is memory mapped</dd>
</dl>
<p>The <a class="reference external" href="reference-Session.html#pop_alerts()">pop_alerts()</a> function on <a class="reference external" href="reference-Session.html#session">session</a> is the main interface for retrieving
alerts (warnings, messages and errors from libtorrent). If no alerts have
been posted by libtorrent <a class="reference external" href="reference-Session.html#pop_alerts()">pop_alerts()</a> will return an empty list.</p>
<p>By default, only errors are reported. <a class="reference external" href="reference-Settings.html#alert_mask">settings_pack::alert_mask</a> can be
used to specify which kinds of events should be reported. The <a class="reference external" href="reference-Alerts.html#alert">alert</a> mask is
a combination of the <a class="reference external" href="reference-Alerts.html#alert_category_t">alert_category_t</a> flags in the <a class="reference external" href="reference-Alerts.html#alert">alert</a> class.</p>
<p>Every <a class="reference external" href="reference-Alerts.html#alert">alert</a> belongs to one or more category. There is a cost associated with
posting alerts. Only alerts that belong to an enabled category are
posted. Setting the <a class="reference external" href="reference-Alerts.html#alert">alert</a> bitmask to 0 will disable all alerts (except those
that are non-discardable). Alerts that are responses to API calls such as
<a class="reference external" href="reference-Torrent_Handle.html#save_resume_data()">save_resume_data()</a> and <a class="reference external" href="reference-Session.html#post_session_stats()">post_session_stats()</a> are non-discardable and will be
posted even if their category is disabled.</p>
<p>There are other <a class="reference external" href="reference-Alerts.html#alert">alert</a> base classes that some alerts derive from, all the
alerts that are generated for a specific torrent are derived from
<a class="reference external" href="reference-Alerts.html#torrent_alert">torrent_alert</a>, and tracker events derive from <a class="reference external" href="reference-Alerts.html#tracker_alert">tracker_alert</a>.</p>
<p>Alerts returned by <a class="reference external" href="reference-Session.html#pop_alerts()">pop_alerts()</a> are only valid until the next call to
<a class="reference external" href="reference-Session.html#pop_alerts()">pop_alerts()</a>. You may not copy an <a class="reference external" href="reference-Alerts.html#alert">alert</a> object to access it after the next
call to <a class="reference external" href="reference-Session.html#pop_alerts()">pop_alerts()</a>. Internal members of alerts also become invalid once
<a class="reference external" href="reference-Session.html#pop_alerts()">pop_alerts()</a> is called again.</p>
<a name="dht_routing_bucket"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+dht_routing_bucket&labels=documentation&body=Documentation+under+heading+%22class+dht_routing_bucket%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="dht-routing-bucket">
<h1>dht_routing_bucket</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>struct to hold information about a single DHT routing table bucket</p>
<pre class="literal-block">
struct dht_routing_bucket
{
   int num_nodes;
   int num_replacements;
   int last_active;
};
</pre>
<a name="num_nodes"></a>
<a name="num_replacements"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_routing_bucket%3A%3A%5Bnum_nodes+num_replacements%5D&labels=documentation&body=Documentation+under+heading+%22dht_routing_bucket%3A%3A%5Bnum_nodes+num_replacements%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>num_nodes num_replacements</dt>
<dd>the total number of nodes and replacement nodes
in the routing table</dd>
</dl>
<a name="last_active"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_routing_bucket%3A%3A%5Blast_active%5D&labels=documentation&body=Documentation+under+heading+%22dht_routing_bucket%3A%3A%5Blast_active%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>last_active</dt>
<dd>number of seconds since last activity</dd>
</dl>
<a name="torrent_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+torrent_alert&labels=documentation&body=Documentation+under+heading+%22class+torrent_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="torrent-alert">
<h1>torrent_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This is a base class for alerts that are associated with a
specific torrent. It contains a handle to the torrent.</p>
<p>Note that by the time the client receives a <a class="reference external" href="reference-Alerts.html#torrent_alert">torrent_alert</a>, its
<tt class="docutils literal">handle</tt> member may be invalid.</p>
<pre class="literal-block">
struct torrent_alert : alert
{
   std::string <strong>message</strong> () const override;
   char const* <strong>torrent_name</strong> () const;

   torrent_handle handle;
};
</pre>
<a name="message()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_alert%3A%3A%5Bmessage%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_alert%3A%3A%5Bmessage%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="message">
<h2>message()</h2>
<pre class="literal-block">
std::string <strong>message</strong> () const override;
</pre>
<p>returns the message associated with this <a class="reference external" href="reference-Alerts.html#alert">alert</a></p>
<a name="handle"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_alert%3A%3A%5Bhandle%5D&labels=documentation&body=Documentation+under+heading+%22torrent_alert%3A%3A%5Bhandle%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>handle</dt>
<dd>The <a class="reference external" href="reference-Torrent_Handle.html#torrent_handle">torrent_handle</a> pointing to the torrent this
<a class="reference external" href="reference-Alerts.html#alert">alert</a> is associated with.</dd>
</dl>
<a name="peer_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+peer_alert&labels=documentation&body=Documentation+under+heading+%22class+peer_alert%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="peer-alert">
<h1>peer_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>The peer <a class="reference external" href="reference-Alerts.html#alert">alert</a> is a base class for alerts that refer to a specific peer. It includes all
the information to identify the peer. i.e. <tt class="docutils literal">ip</tt> and <tt class="docutils literal"><span class="pre">peer-id</span></tt>.</p>
<pre class="literal-block">
struct peer_alert : torrent_alert
{
   std::string <strong>message</strong> () const override;

   aux::noexcept_movable&lt;<a class="reference external" href="tcp::endpoint">tcp::endpoint</a>&gt; endpoint;
   peer_id pid;
};
</pre>
<a name="endpoint"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_alert%3A%3A%5Bendpoint%5D&labels=documentation&body=Documentation+under+heading+%22peer_alert%3A%3A%5Bendpoint%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>endpoint</dt>
<dd>The peer's IP address and port.</dd>
</dl>
<a name="pid"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_alert%3A%3A%5Bpid%5D&labels=documentation&body=Documentation+under+heading+%22peer_alert%3A%3A%5Bpid%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>pid</dt>
<dd>the peer ID, if known.</dd>
</dl>
<a name="tracker_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+tracker_alert&labels=documentation&body=Documentation+under+heading+%22class+tracker_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="tracker-alert">
<h1>tracker_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This is a base class used for alerts that are associated with a
specific tracker. It derives from <a class="reference external" href="reference-Alerts.html#torrent_alert">torrent_alert</a> since a tracker
is also associated with a specific torrent.</p>
<pre class="literal-block">
struct tracker_alert : torrent_alert
{
   std::string <strong>message</strong> () const override;
   char const* <strong>tracker_url</strong> () const;

   aux::noexcept_movable&lt;<a class="reference external" href="tcp::endpoint">tcp::endpoint</a>&gt; local_endpoint;
};
</pre>
<a name="tracker_url()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:tracker_alert%3A%3A%5Btracker_url%28%29%5D&labels=documentation&body=Documentation+under+heading+%22tracker_alert%3A%3A%5Btracker_url%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="tracker-url">
<h2>tracker_url()</h2>
<pre class="literal-block">
char const* <strong>tracker_url</strong> () const;
</pre>
<p>returns a 0-terminated string of the tracker's URL</p>
<a name="local_endpoint"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:tracker_alert%3A%3A%5Blocal_endpoint%5D&labels=documentation&body=Documentation+under+heading+%22tracker_alert%3A%3A%5Blocal_endpoint%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>local_endpoint</dt>
<dd>endpoint of the listen interface being announced</dd>
</dl>
<a name="torrent_removed_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+torrent_removed_alert&labels=documentation&body=Documentation+under+heading+%22class+torrent_removed_alert%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="torrent-removed-alert">
<h1>torrent_removed_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>The <tt class="docutils literal">torrent_removed_alert</tt> is posted whenever a torrent is removed. Since
the torrent handle in its base class will usually be invalid (since the torrent
is already removed) it has the info hash as a member, to identify it.
It's posted when the <tt class="docutils literal"><span class="pre">alert_category::status</span></tt> bit is set in the alert_mask.</p>
<p>Note that the <tt class="docutils literal">handle</tt> remains valid for some time after
<a class="reference external" href="reference-Alerts.html#torrent_removed_alert">torrent_removed_alert</a> is posted, as long as some internal libtorrent
task (such as an I/O task) refers to it. Additionally, other alerts like
<a class="reference external" href="reference-Alerts.html#save_resume_data_alert">save_resume_data_alert</a> may be posted after <a class="reference external" href="reference-Alerts.html#torrent_removed_alert">torrent_removed_alert</a>.
To synchronize on whether the torrent has been removed or not, call
<a class="reference external" href="reference-Torrent_Handle.html#in_session()">torrent_handle::in_session()</a>. This will return true before
<a class="reference external" href="reference-Alerts.html#torrent_removed_alert">torrent_removed_alert</a> is posted, and false afterward.</p>
<p>Even though the <tt class="docutils literal">handle</tt> member doesn't point to an existing torrent anymore,
it is still useful for comparing to other handles, which may also no
longer point to existing torrents, but to the same non-existing torrents.</p>
<p>The <tt class="docutils literal">torrent_handle</tt> acts as a <tt class="docutils literal">weak_ptr</tt>, even though its object no
longer exists, it can still compare equal to another weak pointer which
points to the same non-existent object.</p>
<pre class="literal-block">
struct torrent_removed_alert final : torrent_alert
{
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::status;
   info_hash_t info_hashes;
   client_data_t userdata;
};
</pre>
<a name="userdata"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_removed_alert%3A%3A%5Buserdata%5D&labels=documentation&body=Documentation+under+heading+%22torrent_removed_alert%3A%3A%5Buserdata%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>userdata</dt>
<dd>'<cite>userdata`</cite> as set in <a class="reference external" href="reference-Add_Torrent.html#add_torrent_params">add_torrent_params</a> at torrent creation.
This can be used to associate this torrent with related data
in the client application more efficiently than info_hashes.</dd>
</dl>
<a name="read_piece_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+read_piece_alert&labels=documentation&body=Documentation+under+heading+%22class+read_piece_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="read-piece-alert">
<h1>read_piece_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This <a class="reference external" href="reference-Alerts.html#alert">alert</a> is posted when the asynchronous read operation initiated by
a call to <a class="reference external" href="reference-Torrent_Handle.html#read_piece()">torrent_handle::read_piece()</a> is completed. If the read failed, the torrent
is paused and an error state is set and the buffer member of the <a class="reference external" href="reference-Alerts.html#alert">alert</a>
is 0. If successful, <tt class="docutils literal">buffer</tt> points to a buffer containing all the data
of the piece. <tt class="docutils literal">piece</tt> is the piece index that was read. <tt class="docutils literal">size</tt> is the
number of bytes that was read.</p>
<p>If the operation fails, <tt class="docutils literal">error</tt> will indicate what went wrong.</p>
<pre class="literal-block">
struct read_piece_alert final : torrent_alert
{
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::storage;
   error_code const error;
   boost::shared_array&lt;char&gt; const buffer;
   piece_index_t const piece;
   int const size;
};
</pre>
<a name="file_completed_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+file_completed_alert&labels=documentation&body=Documentation+under+heading+%22class+file_completed_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="file-completed-alert">
<h1>file_completed_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This is posted whenever an individual file completes its download. i.e.
All pieces overlapping this file have passed their hash check.</p>
<pre class="literal-block">
struct file_completed_alert final : torrent_alert
{
   std::string <strong>message</strong> () const override;

   file_index_t const index;
};
</pre>
<a name="index"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:file_completed_alert%3A%3A%5Bindex%5D&labels=documentation&body=Documentation+under+heading+%22file_completed_alert%3A%3A%5Bindex%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>index</dt>
<dd>refers to the index of the file that completed.</dd>
</dl>
<a name="file_renamed_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+file_renamed_alert&labels=documentation&body=Documentation+under+heading+%22class+file_renamed_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="file-renamed-alert">
<h1>file_renamed_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This is posted as a response to a <a class="reference external" href="reference-Torrent_Handle.html#rename_file()">torrent_handle::rename_file()</a> call, if the rename
operation succeeds.</p>
<pre class="literal-block">
struct file_renamed_alert final : torrent_alert
{
   std::string <strong>message</strong> () const override;
   char const* <strong>new_name</strong> () const;
   char const* <strong>old_name</strong> () const;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::storage;
   file_index_t const index;
};
</pre>
<a name="new_name()"></a>
<a name="old_name()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:file_renamed_alert%3A%3A%5Bnew_name%28%29+old_name%28%29%5D&labels=documentation&body=Documentation+under+heading+%22file_renamed_alert%3A%3A%5Bnew_name%28%29+old_name%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="new-name-old-name">
<h2>new_name() old_name()</h2>
<pre class="literal-block">
char const* <strong>new_name</strong> () const;
char const* <strong>old_name</strong> () const;
</pre>
<p>returns the new and previous file name, respectively.</p>
<a name="index"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:file_renamed_alert%3A%3A%5Bindex%5D&labels=documentation&body=Documentation+under+heading+%22file_renamed_alert%3A%3A%5Bindex%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>index</dt>
<dd>refers to the index of the file that was renamed,</dd>
</dl>
<a name="file_rename_failed_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+file_rename_failed_alert&labels=documentation&body=Documentation+under+heading+%22class+file_rename_failed_alert%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="file-rename-failed-alert">
<h1>file_rename_failed_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This is posted as a response to a <a class="reference external" href="reference-Torrent_Handle.html#rename_file()">torrent_handle::rename_file()</a> call, if the rename
operation failed.</p>
<pre class="literal-block">
struct file_rename_failed_alert final : torrent_alert
{
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::storage;
   file_index_t const index;
   error_code const error;
};
</pre>
<a name="index"></a>
<a name="error"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:file_rename_failed_alert%3A%3A%5Bindex+error%5D&labels=documentation&body=Documentation+under+heading+%22file_rename_failed_alert%3A%3A%5Bindex+error%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>index error</dt>
<dd>refers to the index of the file that was supposed to be renamed,
<tt class="docutils literal">error</tt> is the error code returned from the filesystem.</dd>
</dl>
<a name="performance_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+performance_alert&labels=documentation&body=Documentation+under+heading+%22class+performance_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="performance-alert">
<h1>performance_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This <a class="reference external" href="reference-Alerts.html#alert">alert</a> is generated when a limit is reached that might have a negative impact on
upload or download rate performance.</p>
<pre class="literal-block">
struct performance_alert final : torrent_alert
{
   std::string <strong>message</strong> () const override;

   enum performance_warning_t
   {
      outstanding_disk_buffer_limit_reached,
      outstanding_request_limit_reached,
      upload_limit_too_low,
      download_limit_too_low,
      send_buffer_watermark_too_low,
      too_many_optimistic_unchoke_slots,
      too_high_disk_queue_limit,
      aio_limit_reached,
      deprecated_bittyrant_with_no_uplimit,
      too_few_outgoing_ports,
      too_few_file_descriptors,
      num_warnings,
   };

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::performance_warning;
   performance_warning_t const warning_code;
};
</pre>
<a name="performance_warning_t"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+performance_warning_t&labels=documentation&body=Documentation+under+heading+%22enum+performance_warning_t%22+could+be+improved">report issue</a>]</span><div class="section" id="enum-performance-warning-t">
<h2>enum performance_warning_t</h2>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="27%" />
<col width="5%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>outstanding_disk_buffer_limit_reached</td>
<td>0</td>
<td>This warning means that the number of bytes queued to be written to disk
exceeds the max disk byte queue setting (<tt class="docutils literal"><span class="pre">settings_pack::max_queued_disk_bytes</span></tt>).
This might restrict the download rate, by not queuing up enough write jobs
to the disk I/O thread. When this <a class="reference external" href="reference-Alerts.html#alert">alert</a> is posted, peer connections are
temporarily stopped from downloading, until the queued disk bytes have fallen
below the limit again. Unless your <tt class="docutils literal">max_queued_disk_bytes</tt> setting is already
high, you might want to increase it to get better performance.</td>
</tr>
<tr><td>outstanding_request_limit_reached</td>
<td>1</td>
<td>This is posted when libtorrent would like to send more requests to a peer,
but it's limited by <tt class="docutils literal"><span class="pre">settings_pack::max_out_request_queue</span></tt>. The queue length
libtorrent is trying to achieve is determined by the download rate and the
assumed round-trip-time (<tt class="docutils literal"><span class="pre">settings_pack::request_queue_time</span></tt>). The assumed
round-trip-time is not limited to just the network RTT, but also the remote disk
access time and message handling time. It defaults to 3 seconds. The target number
of outstanding requests is set to fill the bandwidth-delay product (assumed RTT
times download rate divided by number of bytes per request). When this <a class="reference external" href="reference-Alerts.html#alert">alert</a>
is posted, there is a risk that the number of outstanding requests is too low
and limits the download rate. You might want to increase the <tt class="docutils literal">max_out_request_queue</tt>
setting.</td>
</tr>
<tr><td>upload_limit_too_low</td>
<td>2</td>
<td>This warning is posted when the amount of TCP/IP overhead is greater than the
upload rate limit. When this happens, the TCP/IP overhead is caused by a much
faster download rate, triggering TCP ACK packets. These packets eat into the
rate limit specified to libtorrent. When the overhead traffic is greater than
the rate limit, libtorrent will not be able to send any actual payload, such
as piece requests. This means the download rate will suffer, and new requests
can be sent again. There will be an equilibrium where the download rate, on
average, is about 20 times the upload rate limit. If you want to maximize the
download rate, increase the upload rate limit above 5% of your download capacity.</td>
</tr>
<tr><td>download_limit_too_low</td>
<td>3</td>
<td>This is the same warning as <tt class="docutils literal">upload_limit_too_low</tt> but referring to the download
limit instead of upload. This suggests that your download rate limit is much lower
than your upload capacity. Your upload rate will suffer. To maximize upload rate,
make sure your download rate limit is above 5% of your upload capacity.</td>
</tr>
<tr><td>send_buffer_watermark_too_low</td>
<td>4</td>
<td><p class="first">We're stalled on the disk. We want to write to the socket, and we can write
but our send buffer is empty, waiting to be refilled from the disk.
This either means the disk is slower than the network connection
or that our send buffer watermark is too small, because we can
send it all before the disk gets back to us.
The number of bytes that we keep outstanding, requested from the disk, is calculated
as follows:</p>
<pre class="code C++ literal-block">
<span class="name">min</span><span class="punctuation">(</span><span class="literal number integer">512</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">max</span><span class="punctuation">(</span><span class="name">upload_rate</span><span class="whitespace"> </span><span class="operator">*</span><span class="whitespace"> </span><span class="name">send_buffer_watermark_factor</span><span class="whitespace"> </span><span class="operator">/</span><span class="whitespace"> </span><span class="literal number integer">100</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">send_buffer_watermark</span><span class="punctuation">))</span>
</pre>
<p class="last">If you receive this <a class="reference external" href="reference-Alerts.html#alert">alert</a>, you might want to either increase your <tt class="docutils literal">send_buffer_watermark</tt>
or <tt class="docutils literal">send_buffer_watermark_factor</tt>.</p>
</td>
</tr>
<tr><td>too_many_optimistic_unchoke_slots</td>
<td>5</td>
<td>If the half (or more) of all upload slots are set as optimistic unchoke slots, this
warning is issued. You probably want more regular (rate based) unchoke slots.</td>
</tr>
<tr><td>too_high_disk_queue_limit</td>
<td>6</td>
<td>If the disk write queue ever grows larger than half of the cache size, this warning
is posted. The disk write queue eats into the total disk cache and leaves very little
left for the actual cache. This causes the disk cache to oscillate in evicting large
portions of the cache before allowing peers to download any more, onto the disk write
queue. Either lower <tt class="docutils literal">max_queued_disk_bytes</tt> or increase <tt class="docutils literal">cache_size</tt>.</td>
</tr>
<tr><td>aio_limit_reached</td>
<td>7</td>
<td>&nbsp;</td>
</tr>
<tr><td>deprecated_bittyrant_with_no_uplimit</td>
<td>8</td>
<td>&nbsp;</td>
</tr>
<tr><td>too_few_outgoing_ports</td>
<td>9</td>
<td>This is generated if outgoing peer connections are failing because of <em>address in use</em>
errors, indicating that <tt class="docutils literal"><span class="pre">settings_pack::outgoing_ports</span></tt> is set and is too small of
a range. Consider not using the <tt class="docutils literal">outgoing_ports</tt> setting at all, or widen the range to
include more ports.</td>
</tr>
<tr><td>too_few_file_descriptors</td>
<td>10</td>
<td>&nbsp;</td>
</tr>
<tr><td>num_warnings</td>
<td>11</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<a name="state_changed_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+state_changed_alert&labels=documentation&body=Documentation+under+heading+%22class+state_changed_alert%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="state-changed-alert">
<h1>state_changed_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>Generated whenever a torrent changes its state.</p>
<pre class="literal-block">
struct state_changed_alert final : torrent_alert
{
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::status;
   torrent_status::state_t const state;
   torrent_status::state_t const prev_state;
};
</pre>
<a name="state"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:state_changed_alert%3A%3A%5Bstate%5D&labels=documentation&body=Documentation+under+heading+%22state_changed_alert%3A%3A%5Bstate%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>state</dt>
<dd>the new state of the torrent.</dd>
</dl>
<a name="prev_state"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:state_changed_alert%3A%3A%5Bprev_state%5D&labels=documentation&body=Documentation+under+heading+%22state_changed_alert%3A%3A%5Bprev_state%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>prev_state</dt>
<dd>the previous state.</dd>
</dl>
<a name="tracker_error_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+tracker_error_alert&labels=documentation&body=Documentation+under+heading+%22class+tracker_error_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="tracker-error-alert">
<h1>tracker_error_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This <a class="reference external" href="reference-Alerts.html#alert">alert</a> is generated on tracker time outs, premature disconnects,
invalid response or a HTTP response other than &quot;200 OK&quot;. From the <a class="reference external" href="reference-Alerts.html#alert">alert</a>
you can get the handle to the torrent the tracker belongs to.</p>
<pre class="literal-block">
struct tracker_error_alert final : tracker_alert
{
   std::string <strong>message</strong> () const override;
   char const* <strong>failure_reason</strong> () const;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::tracker | alert_category::error;
   int const times_in_row;
   error_code const error;
   operation_t op;
   protocol_version version;
};
</pre>
<a name="failure_reason()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:tracker_error_alert%3A%3A%5Bfailure_reason%28%29%5D&labels=documentation&body=Documentation+under+heading+%22tracker_error_alert%3A%3A%5Bfailure_reason%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="failure-reason">
<h2>failure_reason()</h2>
<pre class="literal-block">
char const* <strong>failure_reason</strong> () const;
</pre>
<p>if the tracker sent a &quot;failure reason&quot; string, it will be returned
here.</p>
<a name="times_in_row"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:tracker_error_alert%3A%3A%5Btimes_in_row%5D&labels=documentation&body=Documentation+under+heading+%22tracker_error_alert%3A%3A%5Btimes_in_row%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>times_in_row</dt>
<dd>This member says how many times in a row this tracker has failed.</dd>
</dl>
<a name="error"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:tracker_error_alert%3A%3A%5Berror%5D&labels=documentation&body=Documentation+under+heading+%22tracker_error_alert%3A%3A%5Berror%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>error</dt>
<dd>the error code indicating why the tracker announce failed. If it is
is <tt class="docutils literal"><span class="pre">lt::errors::tracker_failure</span></tt> the <a class="reference external" href="reference-Alerts.html#failure_reason()">failure_reason()</a> might contain
a more detailed description of why the tracker rejected the request.
HTTP status codes indicating errors are also set in this field.</dd>
</dl>
<a name="version"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:tracker_error_alert%3A%3A%5Bversion%5D&labels=documentation&body=Documentation+under+heading+%22tracker_error_alert%3A%3A%5Bversion%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>version</dt>
<dd>the bittorrent protocol version that was announced</dd>
</dl>
<a name="tracker_warning_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+tracker_warning_alert&labels=documentation&body=Documentation+under+heading+%22class+tracker_warning_alert%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="tracker-warning-alert">
<h1>tracker_warning_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This <a class="reference external" href="reference-Alerts.html#alert">alert</a> is triggered if the tracker reply contains a warning field.
Usually this means that the tracker announce was successful, but the
tracker has a message to the client.</p>
<pre class="literal-block">
struct tracker_warning_alert final : tracker_alert
{
   std::string <strong>message</strong> () const override;
   char const* <strong>warning_message</strong> () const;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::tracker | alert_category::error;
   protocol_version version;
};
</pre>
<a name="warning_message()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:tracker_warning_alert%3A%3A%5Bwarning_message%28%29%5D&labels=documentation&body=Documentation+under+heading+%22tracker_warning_alert%3A%3A%5Bwarning_message%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="warning-message">
<h2>warning_message()</h2>
<pre class="literal-block">
char const* <strong>warning_message</strong> () const;
</pre>
<p>the message associated with this warning</p>
<a name="version"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:tracker_warning_alert%3A%3A%5Bversion%5D&labels=documentation&body=Documentation+under+heading+%22tracker_warning_alert%3A%3A%5Bversion%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>version</dt>
<dd>the bittorrent protocol version that was announced</dd>
</dl>
<a name="scrape_reply_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+scrape_reply_alert&labels=documentation&body=Documentation+under+heading+%22class+scrape_reply_alert%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="scrape-reply-alert">
<h1>scrape_reply_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This <a class="reference external" href="reference-Alerts.html#alert">alert</a> is generated when a scrape request succeeds.</p>
<pre class="literal-block">
struct scrape_reply_alert final : tracker_alert
{
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::tracker;
   int const incomplete;
   int const complete;
   protocol_version version;
};
</pre>
<a name="incomplete"></a>
<a name="complete"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:scrape_reply_alert%3A%3A%5Bincomplete+complete%5D&labels=documentation&body=Documentation+under+heading+%22scrape_reply_alert%3A%3A%5Bincomplete+complete%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>incomplete complete</dt>
<dd>the data returned in the scrape response. These numbers
may be -1 if the response was malformed.</dd>
</dl>
<a name="version"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:scrape_reply_alert%3A%3A%5Bversion%5D&labels=documentation&body=Documentation+under+heading+%22scrape_reply_alert%3A%3A%5Bversion%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>version</dt>
<dd>the bittorrent protocol version that was scraped</dd>
</dl>
<a name="scrape_failed_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+scrape_failed_alert&labels=documentation&body=Documentation+under+heading+%22class+scrape_failed_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="scrape-failed-alert">
<h1>scrape_failed_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>If a scrape request fails, this <a class="reference external" href="reference-Alerts.html#alert">alert</a> is generated. This might be due
to the tracker timing out, refusing connection or returning an http response
code indicating an error.</p>
<pre class="literal-block">
struct scrape_failed_alert final : tracker_alert
{
   std::string <strong>message</strong> () const override;
   char const* <strong>error_message</strong> () const;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::tracker | alert_category::error;
   error_code const error;
   protocol_version version;
};
</pre>
<a name="error_message()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:scrape_failed_alert%3A%3A%5Berror_message%28%29%5D&labels=documentation&body=Documentation+under+heading+%22scrape_failed_alert%3A%3A%5Berror_message%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="error-message">
<h2>error_message()</h2>
<pre class="literal-block">
char const* <strong>error_message</strong> () const;
</pre>
<p>if the error indicates there is an associated message, this returns
that message. Otherwise and empty string.</p>
<a name="error"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:scrape_failed_alert%3A%3A%5Berror%5D&labels=documentation&body=Documentation+under+heading+%22scrape_failed_alert%3A%3A%5Berror%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>error</dt>
<dd>the error itself. This may indicate that the tracker sent an error
message (<tt class="docutils literal"><span class="pre">error::tracker_failure</span></tt>), in which case it can be
retrieved by calling <tt class="docutils literal">error_message()</tt>.</dd>
</dl>
<a name="version"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:scrape_failed_alert%3A%3A%5Bversion%5D&labels=documentation&body=Documentation+under+heading+%22scrape_failed_alert%3A%3A%5Bversion%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>version</dt>
<dd>the bittorrent protocol version that was scraped</dd>
</dl>
<a name="tracker_reply_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+tracker_reply_alert&labels=documentation&body=Documentation+under+heading+%22class+tracker_reply_alert%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="tracker-reply-alert">
<h1>tracker_reply_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This <a class="reference external" href="reference-Alerts.html#alert">alert</a> is only for informational purpose. It is generated when a tracker announce
succeeds. It is generated regardless what kind of tracker was used, be it UDP, HTTP or
the DHT.</p>
<pre class="literal-block">
struct tracker_reply_alert final : tracker_alert
{
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::tracker;
   int const num_peers;
   protocol_version version;
};
</pre>
<a name="num_peers"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:tracker_reply_alert%3A%3A%5Bnum_peers%5D&labels=documentation&body=Documentation+under+heading+%22tracker_reply_alert%3A%3A%5Bnum_peers%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>num_peers</dt>
<dd>tells how many peers the tracker returned in this response. This is
not expected to be greater than the <tt class="docutils literal">num_want</tt> settings. These are not necessarily
all new peers, some of them may already be connected.</dd>
</dl>
<a name="version"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:tracker_reply_alert%3A%3A%5Bversion%5D&labels=documentation&body=Documentation+under+heading+%22tracker_reply_alert%3A%3A%5Bversion%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>version</dt>
<dd>the bittorrent protocol version that was announced</dd>
</dl>
<a name="dht_reply_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+dht_reply_alert&labels=documentation&body=Documentation+under+heading+%22class+dht_reply_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="dht-reply-alert">
<h1>dht_reply_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This <a class="reference external" href="reference-Alerts.html#alert">alert</a> is generated each time the DHT receives peers from a node. <tt class="docutils literal">num_peers</tt>
is the number of peers we received in this packet. Typically these packets are
received from multiple DHT nodes, and so the alerts are typically generated
a few at a time.</p>
<pre class="literal-block">
struct dht_reply_alert final : tracker_alert
{
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::dht | alert_category::tracker;
   int const num_peers;
};
</pre>
<a name="tracker_announce_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+tracker_announce_alert&labels=documentation&body=Documentation+under+heading+%22class+tracker_announce_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="tracker-announce-alert">
<h1>tracker_announce_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This <a class="reference external" href="reference-Alerts.html#alert">alert</a> is generated each time a tracker announce is sent (or attempted to be sent).
There are no extra data members in this <a class="reference external" href="reference-Alerts.html#alert">alert</a>. The url can be found in the base class
however.</p>
<pre class="literal-block">
struct tracker_announce_alert final : tracker_alert
{
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::tracker;
   event_t const event;
   protocol_version version;
};
</pre>
<a name="event"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:tracker_announce_alert%3A%3A%5Bevent%5D&labels=documentation&body=Documentation+under+heading+%22tracker_announce_alert%3A%3A%5Bevent%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>event</dt>
<dd>specifies what event was sent to the tracker. See <a class="reference external" href="reference-Core.html#event_t">event_t</a>.</dd>
</dl>
<a name="version"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:tracker_announce_alert%3A%3A%5Bversion%5D&labels=documentation&body=Documentation+under+heading+%22tracker_announce_alert%3A%3A%5Bversion%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>version</dt>
<dd>the bittorrent protocol version that is announced</dd>
</dl>
<a name="hash_failed_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+hash_failed_alert&labels=documentation&body=Documentation+under+heading+%22class+hash_failed_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="hash-failed-alert">
<h1>hash_failed_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This <a class="reference external" href="reference-Alerts.html#alert">alert</a> is generated when a finished piece fails its hash check. You can get the handle
to the torrent which got the failed piece and the index of the piece itself from the <a class="reference external" href="reference-Alerts.html#alert">alert</a>.</p>
<pre class="literal-block">
struct hash_failed_alert final : torrent_alert
{
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::status;
   piece_index_t const piece_index;
};
</pre>
<a name="peer_ban_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+peer_ban_alert&labels=documentation&body=Documentation+under+heading+%22class+peer_ban_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="peer-ban-alert">
<h1>peer_ban_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This <a class="reference external" href="reference-Alerts.html#alert">alert</a> is generated when a peer is banned because it has sent too many corrupt pieces
to us. <tt class="docutils literal">ip</tt> is the endpoint to the peer that was banned.</p>
<pre class="literal-block">
struct peer_ban_alert final : peer_alert
{
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::peer;
};
</pre>
<a name="peer_unsnubbed_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+peer_unsnubbed_alert&labels=documentation&body=Documentation+under+heading+%22class+peer_unsnubbed_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="peer-unsnubbed-alert">
<h1>peer_unsnubbed_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This <a class="reference external" href="reference-Alerts.html#alert">alert</a> is generated when a peer is un-snubbed. Essentially when it was snubbed for stalling
sending data, and now it started sending data again.</p>
<pre class="literal-block">
struct peer_unsnubbed_alert final : peer_alert
{
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::peer;
};
</pre>
<a name="peer_snubbed_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+peer_snubbed_alert&labels=documentation&body=Documentation+under+heading+%22class+peer_snubbed_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="peer-snubbed-alert">
<h1>peer_snubbed_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This <a class="reference external" href="reference-Alerts.html#alert">alert</a> is generated when a peer is snubbed, when it stops sending data when we request
it.</p>
<pre class="literal-block">
struct peer_snubbed_alert final : peer_alert
{
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::peer;
};
</pre>
<a name="peer_error_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+peer_error_alert&labels=documentation&body=Documentation+under+heading+%22class+peer_error_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="peer-error-alert">
<h1>peer_error_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This <a class="reference external" href="reference-Alerts.html#alert">alert</a> is generated when a peer sends invalid data over the peer-peer protocol. The peer
will be disconnected, but you get its ip address from the <a class="reference external" href="reference-Alerts.html#alert">alert</a>, to identify it.</p>
<pre class="literal-block">
struct peer_error_alert final : peer_alert
{
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::peer;
   operation_t op;
   error_code const error;
};
</pre>
<a name="op"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_error_alert%3A%3A%5Bop%5D&labels=documentation&body=Documentation+under+heading+%22peer_error_alert%3A%3A%5Bop%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>op</dt>
<dd>a 0-terminated string of the low-level operation that failed, or nullptr if
there was no low level disk operation.</dd>
</dl>
<a name="error"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_error_alert%3A%3A%5Berror%5D&labels=documentation&body=Documentation+under+heading+%22peer_error_alert%3A%3A%5Berror%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>error</dt>
<dd>tells you what error caused this <a class="reference external" href="reference-Alerts.html#alert">alert</a>.</dd>
</dl>
<a name="peer_connect_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+peer_connect_alert&labels=documentation&body=Documentation+under+heading+%22class+peer_connect_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="peer-connect-alert">
<h1>peer_connect_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This <a class="reference external" href="reference-Alerts.html#alert">alert</a> is posted every time an incoming peer connection both
successfully passes the protocol handshake and is associated with a
torrent, or an outgoing peer connection attempt succeeds. For arbitrary
incoming connections, see <a class="reference external" href="reference-Alerts.html#incoming_connection_alert">incoming_connection_alert</a>.</p>
<pre class="literal-block">
struct peer_connect_alert final : peer_alert
{
   std::string <strong>message</strong> () const override;

   enum direction_t
   {
      in,
      out,
   };

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::connect;
   direction_t direction;
   socket_type_t socket_type;
};
</pre>
<a name="direction_t"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+direction_t&labels=documentation&body=Documentation+under+heading+%22enum+direction_t%22+could+be+improved">report issue</a>]</span><div class="section" id="enum-direction-t">
<h2>enum direction_t</h2>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="27%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>in</td>
<td>0</td>
<td>&nbsp;</td>
</tr>
<tr><td>out</td>
<td>1</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<a name="direction"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_connect_alert%3A%3A%5Bdirection%5D&labels=documentation&body=Documentation+under+heading+%22peer_connect_alert%3A%3A%5Bdirection%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>direction</dt>
<dd>Tells you if the peer was incoming or outgoing</dd>
</dl>
<a name="peer_disconnected_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+peer_disconnected_alert&labels=documentation&body=Documentation+under+heading+%22class+peer_disconnected_alert%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="peer-disconnected-alert">
<h1>peer_disconnected_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This <a class="reference external" href="reference-Alerts.html#alert">alert</a> is generated when a peer is disconnected for any reason (other than the ones
covered by <a class="reference external" href="reference-Alerts.html#peer_error_alert">peer_error_alert</a> ).</p>
<pre class="literal-block">
struct peer_disconnected_alert final : peer_alert
{
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::connect;
   socket_type_t const socket_type;
   operation_t const op;
   error_code const error;
   close_reason_t const reason;
};
</pre>
<a name="socket_type"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_disconnected_alert%3A%3A%5Bsocket_type%5D&labels=documentation&body=Documentation+under+heading+%22peer_disconnected_alert%3A%3A%5Bsocket_type%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>socket_type</dt>
<dd>the kind of socket this peer was connected over</dd>
</dl>
<a name="op"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_disconnected_alert%3A%3A%5Bop%5D&labels=documentation&body=Documentation+under+heading+%22peer_disconnected_alert%3A%3A%5Bop%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>op</dt>
<dd>the operation or level where the error occurred. Specified as an
value from the <a class="reference external" href="reference-Alerts.html#operation_t">operation_t</a> enum. Defined in operations.hpp.</dd>
</dl>
<a name="error"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_disconnected_alert%3A%3A%5Berror%5D&labels=documentation&body=Documentation+under+heading+%22peer_disconnected_alert%3A%3A%5Berror%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>error</dt>
<dd>tells you what error caused peer to disconnect.</dd>
</dl>
<a name="reason"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_disconnected_alert%3A%3A%5Breason%5D&labels=documentation&body=Documentation+under+heading+%22peer_disconnected_alert%3A%3A%5Breason%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>reason</dt>
<dd>the reason the peer disconnected (if specified)</dd>
</dl>
<a name="invalid_request_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+invalid_request_alert&labels=documentation&body=Documentation+under+heading+%22class+invalid_request_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="invalid-request-alert">
<h1>invalid_request_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This is a debug <a class="reference external" href="reference-Alerts.html#alert">alert</a> that is generated by an incoming invalid piece request.
<tt class="docutils literal">ip</tt> is the address of the peer and the <tt class="docutils literal">request</tt> is the actual incoming
request from the peer. See <a class="reference external" href="reference-Core.html#peer_request">peer_request</a> for more info.</p>
<pre class="literal-block">
struct invalid_request_alert final : peer_alert
{
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::peer;
   peer_request const request;
   bool const we_have;
   bool const peer_interested;
   bool const withheld;
};
</pre>
<a name="request"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:invalid_request_alert%3A%3A%5Brequest%5D&labels=documentation&body=Documentation+under+heading+%22invalid_request_alert%3A%3A%5Brequest%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>request</dt>
<dd>the request we received from the peer</dd>
</dl>
<a name="we_have"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:invalid_request_alert%3A%3A%5Bwe_have%5D&labels=documentation&body=Documentation+under+heading+%22invalid_request_alert%3A%3A%5Bwe_have%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>we_have</dt>
<dd>true if we have this piece</dd>
</dl>
<a name="peer_interested"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:invalid_request_alert%3A%3A%5Bpeer_interested%5D&labels=documentation&body=Documentation+under+heading+%22invalid_request_alert%3A%3A%5Bpeer_interested%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>peer_interested</dt>
<dd>true if the peer indicated that it was interested to download before
sending the request</dd>
</dl>
<a name="withheld"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:invalid_request_alert%3A%3A%5Bwithheld%5D&labels=documentation&body=Documentation+under+heading+%22invalid_request_alert%3A%3A%5Bwithheld%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>withheld</dt>
<dd>if this is true, the peer is not allowed to download this piece because
of super-seeding rules.</dd>
</dl>
<a name="torrent_finished_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+torrent_finished_alert&labels=documentation&body=Documentation+under+heading+%22class+torrent_finished_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="torrent-finished-alert">
<h1>torrent_finished_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This <a class="reference external" href="reference-Alerts.html#alert">alert</a> is generated when a torrent switches from being a downloader to a seed.
It will only be generated once per torrent. It contains a <a class="reference external" href="reference-Torrent_Handle.html#torrent_handle">torrent_handle</a> to the
torrent in question.</p>
<pre class="literal-block">
struct torrent_finished_alert final : torrent_alert
{
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::status;
};
</pre>
<a name="piece_finished_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+piece_finished_alert&labels=documentation&body=Documentation+under+heading+%22class+piece_finished_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="piece-finished-alert">
<h1>piece_finished_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>this <a class="reference external" href="reference-Alerts.html#alert">alert</a> is posted every time a piece completes downloading
and passes the hash check. This <a class="reference external" href="reference-Alerts.html#alert">alert</a> derives from <a class="reference external" href="reference-Alerts.html#torrent_alert">torrent_alert</a>
which contains the <a class="reference external" href="reference-Torrent_Handle.html#torrent_handle">torrent_handle</a> to the torrent the piece belongs to.
Note that being downloaded and passing the hash check may happen before
the piece is also fully flushed to disk. So <a class="reference external" href="reference-Torrent_Handle.html#have_piece()">torrent_handle::have_piece()</a>
may still return false</p>
<pre class="literal-block">
struct piece_finished_alert final : torrent_alert
{
   std::string <strong>message</strong> () const override;

   piece_index_t const piece_index;
};
</pre>
<a name="piece_index"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:piece_finished_alert%3A%3A%5Bpiece_index%5D&labels=documentation&body=Documentation+under+heading+%22piece_finished_alert%3A%3A%5Bpiece_index%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>piece_index</dt>
<dd>the index of the piece that finished</dd>
</dl>
<a name="request_dropped_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+request_dropped_alert&labels=documentation&body=Documentation+under+heading+%22class+request_dropped_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="request-dropped-alert">
<h1>request_dropped_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This <a class="reference external" href="reference-Alerts.html#alert">alert</a> is generated when a peer rejects or ignores a piece request.</p>
<pre class="literal-block">
struct request_dropped_alert final : peer_alert
{
   std::string <strong>message</strong> () const override;

   int const block_index;
   piece_index_t const piece_index;
};
</pre>
<a name="block_timeout_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+block_timeout_alert&labels=documentation&body=Documentation+under+heading+%22class+block_timeout_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="block-timeout-alert">
<h1>block_timeout_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This <a class="reference external" href="reference-Alerts.html#alert">alert</a> is generated when a block request times out.</p>
<pre class="literal-block">
struct block_timeout_alert final : peer_alert
{
   std::string <strong>message</strong> () const override;

   int const block_index;
   piece_index_t const piece_index;
};
</pre>
<a name="block_finished_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+block_finished_alert&labels=documentation&body=Documentation+under+heading+%22class+block_finished_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="block-finished-alert">
<h1>block_finished_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This <a class="reference external" href="reference-Alerts.html#alert">alert</a> is generated when a block request receives a response.</p>
<pre class="literal-block">
struct block_finished_alert final : peer_alert
{
   std::string <strong>message</strong> () const override;

   int const block_index;
   piece_index_t const piece_index;
};
</pre>
<a name="block_downloading_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+block_downloading_alert&labels=documentation&body=Documentation+under+heading+%22class+block_downloading_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="block-downloading-alert">
<h1>block_downloading_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This <a class="reference external" href="reference-Alerts.html#alert">alert</a> is generated when a block request is sent to a peer.</p>
<pre class="literal-block">
struct block_downloading_alert final : peer_alert
{
   std::string <strong>message</strong> () const override;

   int const block_index;
   piece_index_t const piece_index;
};
</pre>
<a name="unwanted_block_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+unwanted_block_alert&labels=documentation&body=Documentation+under+heading+%22class+unwanted_block_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="unwanted-block-alert">
<h1>unwanted_block_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This <a class="reference external" href="reference-Alerts.html#alert">alert</a> is generated when a block is received that was not requested or
whose request timed out.</p>
<pre class="literal-block">
struct unwanted_block_alert final : peer_alert
{
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::peer;
   int const block_index;
   piece_index_t const piece_index;
};
</pre>
<a name="storage_moved_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+storage_moved_alert&labels=documentation&body=Documentation+under+heading+%22class+storage_moved_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="storage-moved-alert">
<h1>storage_moved_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>The <tt class="docutils literal">storage_moved_alert</tt> is generated when all the disk IO has
completed and the files have been moved, as an effect of a call to
<tt class="docutils literal"><span class="pre">torrent_handle::move_storage</span></tt>. This is useful to synchronize with the
actual disk. The <tt class="docutils literal">storage_path()</tt> member return the new path of the
storage.</p>
<pre class="literal-block">
struct storage_moved_alert final : torrent_alert
{
   std::string <strong>message</strong> () const override;
   char const* <strong>old_path</strong> () const;
   char const* <strong>storage_path</strong> () const;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::storage;
};
</pre>
<a name="old_path()"></a>
<a name="storage_path()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:storage_moved_alert%3A%3A%5Bold_path%28%29+storage_path%28%29%5D&labels=documentation&body=Documentation+under+heading+%22storage_moved_alert%3A%3A%5Bold_path%28%29+storage_path%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="old-path-storage-path">
<h2>old_path() storage_path()</h2>
<pre class="literal-block">
char const* <strong>old_path</strong> () const;
char const* <strong>storage_path</strong> () const;
</pre>
<p>the path the torrent was moved to and from, respectively.</p>
<a name="storage_moved_failed_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+storage_moved_failed_alert&labels=documentation&body=Documentation+under+heading+%22class+storage_moved_failed_alert%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="storage-moved-failed-alert">
<h1>storage_moved_failed_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>The <tt class="docutils literal">storage_moved_failed_alert</tt> is generated when an attempt to move the storage,
via <a class="reference external" href="reference-Torrent_Handle.html#move_storage()">torrent_handle::move_storage()</a>, fails.</p>
<pre class="literal-block">
struct storage_moved_failed_alert final : torrent_alert
{
   std::string <strong>message</strong> () const override;
   char const* <strong>file_path</strong> () const;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::storage;
   error_code const error;
   operation_t op;
};
</pre>
<a name="file_path()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:storage_moved_failed_alert%3A%3A%5Bfile_path%28%29%5D&labels=documentation&body=Documentation+under+heading+%22storage_moved_failed_alert%3A%3A%5Bfile_path%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="file-path">
<h2>file_path()</h2>
<pre class="literal-block">
char const* <strong>file_path</strong> () const;
</pre>
<p>If the error happened for a specific file, this returns its path.</p>
<a name="op"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:storage_moved_failed_alert%3A%3A%5Bop%5D&labels=documentation&body=Documentation+under+heading+%22storage_moved_failed_alert%3A%3A%5Bop%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>op</dt>
<dd>this indicates what underlying operation caused the error</dd>
</dl>
<a name="torrent_deleted_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+torrent_deleted_alert&labels=documentation&body=Documentation+under+heading+%22class+torrent_deleted_alert%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="torrent-deleted-alert">
<h1>torrent_deleted_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This <a class="reference external" href="reference-Alerts.html#alert">alert</a> is generated when a request to delete the files of a torrent complete.</p>
<p>This <a class="reference external" href="reference-Alerts.html#alert">alert</a> is posted in the <tt class="docutils literal"><span class="pre">alert_category::storage</span></tt> category, and that bit
needs to be set in the alert_mask.</p>
<pre class="literal-block">
struct torrent_deleted_alert final : torrent_alert
{
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::storage;
   info_hash_t info_hashes;
};
</pre>
<a name="info_hashes"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_deleted_alert%3A%3A%5Binfo_hashes%5D&labels=documentation&body=Documentation+under+heading+%22torrent_deleted_alert%3A%3A%5Binfo_hashes%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>info_hashes</dt>
<dd>The info-hash of the torrent that was just deleted. Most of
the time the <a class="reference external" href="reference-Torrent_Handle.html#torrent_handle">torrent_handle</a> in the <tt class="docutils literal">torrent_alert</tt> will be invalid by the time
this <a class="reference external" href="reference-Alerts.html#alert">alert</a> arrives, since the torrent is being deleted. The <tt class="docutils literal">info_hashes</tt> member
is hence the main way of identifying which torrent just completed the delete.</dd>
</dl>
<a name="torrent_delete_failed_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+torrent_delete_failed_alert&labels=documentation&body=Documentation+under+heading+%22class+torrent_delete_failed_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="torrent-delete-failed-alert">
<h1>torrent_delete_failed_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This <a class="reference external" href="reference-Alerts.html#alert">alert</a> is generated when a request to delete the files of a torrent fails.
Just removing a torrent from the <a class="reference external" href="reference-Session.html#session">session</a> cannot fail</p>
<pre class="literal-block">
struct torrent_delete_failed_alert final : torrent_alert
{
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::storage
   | alert_category::error;
   error_code const error;
   info_hash_t info_hashes;
};
</pre>
<a name="error"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_delete_failed_alert%3A%3A%5Berror%5D&labels=documentation&body=Documentation+under+heading+%22torrent_delete_failed_alert%3A%3A%5Berror%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>error</dt>
<dd>tells you why it failed.</dd>
</dl>
<a name="info_hashes"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_delete_failed_alert%3A%3A%5Binfo_hashes%5D&labels=documentation&body=Documentation+under+heading+%22torrent_delete_failed_alert%3A%3A%5Binfo_hashes%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>info_hashes</dt>
<dd>the info hash of the torrent whose files failed to be deleted</dd>
</dl>
<a name="save_resume_data_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+save_resume_data_alert&labels=documentation&body=Documentation+under+heading+%22class+save_resume_data_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="save-resume-data-alert">
<h1>save_resume_data_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This <a class="reference external" href="reference-Alerts.html#alert">alert</a> is generated as a response to a <tt class="docutils literal"><span class="pre">torrent_handle::save_resume_data</span></tt> request.
It is generated once the disk IO thread is done writing the state for this torrent.</p>
<pre class="literal-block">
struct save_resume_data_alert final : torrent_alert
{
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::storage;
   add_torrent_params params;
};
</pre>
<a name="params"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:save_resume_data_alert%3A%3A%5Bparams%5D&labels=documentation&body=Documentation+under+heading+%22save_resume_data_alert%3A%3A%5Bparams%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>params</dt>
<dd><p class="first">the <tt class="docutils literal">params</tt> object is populated with the torrent file whose resume
data was saved. It is suitable to be:</p>
<ul class="last simple">
<li>added to a <a class="reference external" href="reference-Session.html#session">session</a> with <a class="reference external" href="reference-Session.html#add_torrent()">add_torrent()</a> or <a class="reference external" href="reference-Session.html#async_add_torrent()">async_add_torrent()</a></li>
<li>saved to disk with <a class="reference external" href="reference-Resume_Data.html#write_resume_data()">write_resume_data()</a></li>
<li>turned into a magnet link with <a class="reference external" href="reference-Core.html#make_magnet_uri()">make_magnet_uri()</a></li>
<li>saved as a .torrent file with <a class="reference external" href="reference-Resume_Data.html#write_torrent_file()">write_torrent_file()</a></li>
</ul>
</dd>
</dl>
<a name="save_resume_data_failed_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+save_resume_data_failed_alert&labels=documentation&body=Documentation+under+heading+%22class+save_resume_data_failed_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="save-resume-data-failed-alert">
<h1>save_resume_data_failed_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This <a class="reference external" href="reference-Alerts.html#alert">alert</a> is generated instead of <tt class="docutils literal">save_resume_data_alert</tt> if there was an error
generating the resume data. <tt class="docutils literal">error</tt> describes what went wrong.</p>
<pre class="literal-block">
struct save_resume_data_failed_alert final : torrent_alert
{
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::storage
   | alert_category::error;
   error_code const error;
};
</pre>
<a name="error"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:save_resume_data_failed_alert%3A%3A%5Berror%5D&labels=documentation&body=Documentation+under+heading+%22save_resume_data_failed_alert%3A%3A%5Berror%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>error</dt>
<dd>the error code from the resume_data failure</dd>
</dl>
<a name="torrent_paused_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+torrent_paused_alert&labels=documentation&body=Documentation+under+heading+%22class+torrent_paused_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="torrent-paused-alert">
<h1>torrent_paused_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This <a class="reference external" href="reference-Alerts.html#alert">alert</a> is generated as a response to a <tt class="docutils literal"><span class="pre">torrent_handle::pause</span></tt> request. It is
generated once all disk IO is complete and the files in the torrent have been closed.
This is useful for synchronizing with the disk.</p>
<pre class="literal-block">
struct torrent_paused_alert final : torrent_alert
{
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::status;
};
</pre>
<a name="torrent_resumed_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+torrent_resumed_alert&labels=documentation&body=Documentation+under+heading+%22class+torrent_resumed_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="torrent-resumed-alert">
<h1>torrent_resumed_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This <a class="reference external" href="reference-Alerts.html#alert">alert</a> is generated as a response to a <a class="reference external" href="reference-Torrent_Handle.html#resume()">torrent_handle::resume()</a> request. It is
generated when a torrent goes from a paused state to an active state.</p>
<pre class="literal-block">
struct torrent_resumed_alert final : torrent_alert
{
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::status;
};
</pre>
<a name="torrent_checked_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+torrent_checked_alert&labels=documentation&body=Documentation+under+heading+%22class+torrent_checked_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="torrent-checked-alert">
<h1>torrent_checked_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This <a class="reference external" href="reference-Alerts.html#alert">alert</a> is posted when a torrent completes checking. i.e. when it transitions
out of the <tt class="docutils literal">checking files</tt> state into a state where it is ready to start downloading</p>
<pre class="literal-block">
struct torrent_checked_alert final : torrent_alert
{
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::status;
};
</pre>
<a name="url_seed_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+url_seed_alert&labels=documentation&body=Documentation+under+heading+%22class+url_seed_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="url-seed-alert">
<h1>url_seed_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This <a class="reference external" href="reference-Alerts.html#alert">alert</a> is generated when a HTTP seed name lookup fails.</p>
<pre class="literal-block">
struct url_seed_alert final : torrent_alert
{
   std::string <strong>message</strong> () const override;
   char const* <strong>server_url</strong> () const;
   char const* <strong>error_message</strong> () const;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::peer | alert_category::error;
   error_code const error;
};
</pre>
<a name="server_url()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:url_seed_alert%3A%3A%5Bserver_url%28%29%5D&labels=documentation&body=Documentation+under+heading+%22url_seed_alert%3A%3A%5Bserver_url%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="server-url">
<h2>server_url()</h2>
<pre class="literal-block">
char const* <strong>server_url</strong> () const;
</pre>
<p>the URL the error is associated with</p>
<a name="error_message()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:url_seed_alert%3A%3A%5Berror_message%28%29%5D&labels=documentation&body=Documentation+under+heading+%22url_seed_alert%3A%3A%5Berror_message%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="error-message-1">
<h2>error_message()</h2>
<pre class="literal-block">
char const* <strong>error_message</strong> () const;
</pre>
<p>in case the web server sent an error message, this function returns
it.</p>
<a name="error"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:url_seed_alert%3A%3A%5Berror%5D&labels=documentation&body=Documentation+under+heading+%22url_seed_alert%3A%3A%5Berror%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>error</dt>
<dd>the error the web seed encountered. If this is not set, the server
sent an error message, call <tt class="docutils literal">error_message()</tt>.</dd>
</dl>
<a name="file_error_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+file_error_alert&labels=documentation&body=Documentation+under+heading+%22class+file_error_alert%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="file-error-alert">
<h1>file_error_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>If the storage fails to read or write files that it needs access to, this <a class="reference external" href="reference-Alerts.html#alert">alert</a> is
generated and the torrent is paused.</p>
<pre class="literal-block">
struct file_error_alert final : torrent_alert
{
   std::string <strong>message</strong> () const override;
   char const* <strong>filename</strong> () const;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::status
   | alert_category::storage;
   error_code const error;
   operation_t op;
};
</pre>
<a name="filename()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:file_error_alert%3A%3A%5Bfilename%28%29%5D&labels=documentation&body=Documentation+under+heading+%22file_error_alert%3A%3A%5Bfilename%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="filename">
<h2>filename()</h2>
<pre class="literal-block">
char const* <strong>filename</strong> () const;
</pre>
<p>the file that experienced the error</p>
<a name="error"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:file_error_alert%3A%3A%5Berror%5D&labels=documentation&body=Documentation+under+heading+%22file_error_alert%3A%3A%5Berror%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>error</dt>
<dd>the error code describing the error.</dd>
</dl>
<a name="op"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:file_error_alert%3A%3A%5Bop%5D&labels=documentation&body=Documentation+under+heading+%22file_error_alert%3A%3A%5Bop%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>op</dt>
<dd>indicates which underlying operation caused the error</dd>
</dl>
<a name="metadata_failed_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+metadata_failed_alert&labels=documentation&body=Documentation+under+heading+%22class+metadata_failed_alert%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="metadata-failed-alert">
<h1>metadata_failed_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This <a class="reference external" href="reference-Alerts.html#alert">alert</a> is generated when the metadata has been completely received and the info-hash
failed to match it. i.e. the metadata that was received was corrupt. libtorrent will
automatically retry to fetch it in this case. This is only relevant when running a
torrent-less download, with the metadata extension provided by libtorrent.</p>
<pre class="literal-block">
struct metadata_failed_alert final : torrent_alert
{
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::error;
   error_code const error;
};
</pre>
<a name="error"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:metadata_failed_alert%3A%3A%5Berror%5D&labels=documentation&body=Documentation+under+heading+%22metadata_failed_alert%3A%3A%5Berror%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>error</dt>
<dd>indicates what failed when parsing the metadata. This error is
what's returned from lazy_bdecode().</dd>
</dl>
<a name="metadata_received_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+metadata_received_alert&labels=documentation&body=Documentation+under+heading+%22class+metadata_received_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="metadata-received-alert">
<h1>metadata_received_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This <a class="reference external" href="reference-Alerts.html#alert">alert</a> is generated when the metadata has been completely received and the torrent
can start downloading. It is not generated on torrents that are started with metadata, but
only those that needs to download it from peers (when utilizing the libtorrent extension).</p>
<p>There are no additional data members in this <a class="reference external" href="reference-Alerts.html#alert">alert</a>.</p>
<p>Typically, when receiving this <a class="reference external" href="reference-Alerts.html#alert">alert</a>, you would want to save the torrent file in order
to load it back up again when the <a class="reference external" href="reference-Session.html#session">session</a> is restarted. Here's an example snippet of
code to do that:</p>
<pre class="code c++ literal-block">
<span class="name">torrent_handle</span><span class="whitespace"> </span><span class="name">h</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">alert</span><span class="operator">-&gt;</span><span class="name">handle</span><span class="punctuation">;</span><span class="whitespace">
</span><span class="name">std</span><span class="operator">::</span><span class="name">shared_ptr</span><span class="operator">&lt;</span><span class="name">torrent_info</span><span class="whitespace"> </span><span class="keyword">const</span><span class="operator">&gt;</span><span class="whitespace"> </span><span class="name">ti</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">h</span><span class="punctuation">.</span><span class="name">torrent_file</span><span class="punctuation">();</span><span class="whitespace">
</span><span class="name">create_torrent</span><span class="whitespace"> </span><span class="name function">ct</span><span class="punctuation">(</span><span class="operator">*</span><span class="name">ti</span><span class="punctuation">);</span><span class="whitespace">
</span><span class="name">entry</span><span class="whitespace"> </span><span class="name">te</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">ct</span><span class="punctuation">.</span><span class="name">generate</span><span class="punctuation">();</span><span class="whitespace">
</span><span class="name">std</span><span class="operator">::</span><span class="name">vector</span><span class="operator">&lt;</span><span class="keyword type">char</span><span class="operator">&gt;</span><span class="whitespace"> </span><span class="name">buffer</span><span class="punctuation">;</span><span class="whitespace">
</span><span class="name">bencode</span><span class="punctuation">(</span><span class="name">std</span><span class="operator">::</span><span class="name">back_inserter</span><span class="punctuation">(</span><span class="name">buffer</span><span class="punctuation">),</span><span class="whitespace"> </span><span class="name">te</span><span class="punctuation">);</span><span class="whitespace">
</span><span class="keyword type">FILE</span><span class="operator">*</span><span class="whitespace"> </span><span class="name">f</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">fopen</span><span class="punctuation">((</span><span class="name">to_hex</span><span class="punctuation">(</span><span class="name">ti</span><span class="operator">-&gt;</span><span class="name">info_hashes</span><span class="punctuation">().</span><span class="name">get_best</span><span class="punctuation">().</span><span class="name">to_string</span><span class="punctuation">())</span><span class="whitespace"> </span><span class="operator">+</span><span class="whitespace"> </span><span class="literal string">&quot;.torrent&quot;</span><span class="punctuation">).</span><span class="name">c_str</span><span class="punctuation">(),</span><span class="whitespace"> </span><span class="literal string">&quot;wb+&quot;</span><span class="punctuation">);</span><span class="whitespace">
</span><span class="keyword">if</span><span class="whitespace"> </span><span class="punctuation">(</span><span class="name">f</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="punctuation">{</span><span class="whitespace">
        </span><span class="name">fwrite</span><span class="punctuation">(</span><span class="operator">&amp;</span><span class="name">buffer</span><span class="punctuation">[</span><span class="literal number integer">0</span><span class="punctuation">],</span><span class="whitespace"> </span><span class="literal number integer">1</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">buffer</span><span class="punctuation">.</span><span class="name">size</span><span class="punctuation">(),</span><span class="whitespace"> </span><span class="name">f</span><span class="punctuation">);</span><span class="whitespace">
        </span><span class="name">fclose</span><span class="punctuation">(</span><span class="name">f</span><span class="punctuation">);</span><span class="whitespace">
</span><span class="punctuation">}</span>
</pre>
<pre class="literal-block">
struct metadata_received_alert final : torrent_alert
{
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::status;
};
</pre>
<a name="udp_error_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+udp_error_alert&labels=documentation&body=Documentation+under+heading+%22class+udp_error_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="udp-error-alert">
<h1>udp_error_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This <a class="reference external" href="reference-Alerts.html#alert">alert</a> is posted when there is an error on a UDP socket. The
UDP sockets are used for all uTP, DHT and UDP tracker traffic. They are
global to the <a class="reference external" href="reference-Session.html#session">session</a>.</p>
<pre class="literal-block">
struct udp_error_alert final : alert
{
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::error;
   aux::noexcept_movable&lt;udp::endpoint&gt; endpoint;
   operation_t operation;
   error_code const error;
};
</pre>
<a name="endpoint"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:udp_error_alert%3A%3A%5Bendpoint%5D&labels=documentation&body=Documentation+under+heading+%22udp_error_alert%3A%3A%5Bendpoint%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>endpoint</dt>
<dd>the source address associated with the error (if any)</dd>
</dl>
<a name="operation"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:udp_error_alert%3A%3A%5Boperation%5D&labels=documentation&body=Documentation+under+heading+%22udp_error_alert%3A%3A%5Boperation%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>operation</dt>
<dd>the operation that failed</dd>
</dl>
<a name="error"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:udp_error_alert%3A%3A%5Berror%5D&labels=documentation&body=Documentation+under+heading+%22udp_error_alert%3A%3A%5Berror%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>error</dt>
<dd>the error code describing the error</dd>
</dl>
<a name="external_ip_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+external_ip_alert&labels=documentation&body=Documentation+under+heading+%22class+external_ip_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="external-ip-alert">
<h1>external_ip_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>Whenever libtorrent learns about the machines external IP, this <a class="reference external" href="reference-Alerts.html#alert">alert</a> is
generated. The external IP address can be acquired from the tracker (if it
supports that) or from peers that supports the extension protocol.
The address can be accessed through the <tt class="docutils literal">external_address</tt> member.</p>
<pre class="literal-block">
struct external_ip_alert final : alert
{
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::status;
   aux::noexcept_movable&lt;address&gt; external_address;
};
</pre>
<a name="external_address"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:external_ip_alert%3A%3A%5Bexternal_address%5D&labels=documentation&body=Documentation+under+heading+%22external_ip_alert%3A%3A%5Bexternal_address%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>external_address</dt>
<dd>the IP address that is believed to be our external IP</dd>
</dl>
<a name="listen_failed_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+listen_failed_alert&labels=documentation&body=Documentation+under+heading+%22class+listen_failed_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="listen-failed-alert">
<h1>listen_failed_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This <a class="reference external" href="reference-Alerts.html#alert">alert</a> is generated when none of the ports, given in the port range, to
<a class="reference external" href="reference-Session.html#session">session</a> can be opened for listening. The <tt class="docutils literal">listen_interface</tt> member is the
interface that failed, <tt class="docutils literal">error</tt> is the error code describing the failure.</p>
<p>In the case an endpoint was created before generating the <a class="reference external" href="reference-Alerts.html#alert">alert</a>, it is
represented by <tt class="docutils literal">address</tt> and <tt class="docutils literal">port</tt>. The combinations of socket type
and operation in which such address and port are not valid are:
accept  - i2p
accept  - socks5
enum_if - tcp</p>
<p>libtorrent may sometimes try to listen on port 0, if all other ports failed.
Port 0 asks the operating system to pick a port that's free). If that fails
you may see a <a class="reference external" href="reference-Alerts.html#listen_failed_alert">listen_failed_alert</a> with port 0 even if you didn't ask to
listen on it.</p>
<pre class="literal-block">
struct listen_failed_alert final : alert
{
   std::string <strong>message</strong> () const override;
   char const* <strong>listen_interface</strong> () const;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::status | alert_category::error;
   error_code const error;
   operation_t op;
   lt::socket_type_t const socket_type;
   aux::noexcept_movable&lt;lt::address&gt; address;
   int const port;
};
</pre>
<a name="listen_interface()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:listen_failed_alert%3A%3A%5Blisten_interface%28%29%5D&labels=documentation&body=Documentation+under+heading+%22listen_failed_alert%3A%3A%5Blisten_interface%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="listen-interface">
<h2>listen_interface()</h2>
<pre class="literal-block">
char const* <strong>listen_interface</strong> () const;
</pre>
<p>the network device libtorrent attempted to listen on, or the IP address</p>
<a name="error"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:listen_failed_alert%3A%3A%5Berror%5D&labels=documentation&body=Documentation+under+heading+%22listen_failed_alert%3A%3A%5Berror%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>error</dt>
<dd>the error the system returned</dd>
</dl>
<a name="op"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:listen_failed_alert%3A%3A%5Bop%5D&labels=documentation&body=Documentation+under+heading+%22listen_failed_alert%3A%3A%5Bop%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>op</dt>
<dd>the underlying operation that failed</dd>
</dl>
<a name="socket_type"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:listen_failed_alert%3A%3A%5Bsocket_type%5D&labels=documentation&body=Documentation+under+heading+%22listen_failed_alert%3A%3A%5Bsocket_type%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>socket_type</dt>
<dd>the type of listen socket this <a class="reference external" href="reference-Alerts.html#alert">alert</a> refers to.</dd>
</dl>
<a name="address"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:listen_failed_alert%3A%3A%5Baddress%5D&labels=documentation&body=Documentation+under+heading+%22listen_failed_alert%3A%3A%5Baddress%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>address</dt>
<dd>the address libtorrent attempted to listen on
see <a class="reference external" href="reference-Alerts.html#alert">alert</a> documentation for validity of this value</dd>
</dl>
<a name="port"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:listen_failed_alert%3A%3A%5Bport%5D&labels=documentation&body=Documentation+under+heading+%22listen_failed_alert%3A%3A%5Bport%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>port</dt>
<dd>the port libtorrent attempted to listen on
see <a class="reference external" href="reference-Alerts.html#alert">alert</a> documentation for validity of this value</dd>
</dl>
<a name="listen_succeeded_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+listen_succeeded_alert&labels=documentation&body=Documentation+under+heading+%22class+listen_succeeded_alert%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="listen-succeeded-alert">
<h1>listen_succeeded_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This <a class="reference external" href="reference-Alerts.html#alert">alert</a> is posted when the listen port succeeds to be opened on a
particular interface. <tt class="docutils literal">address</tt> and <tt class="docutils literal">port</tt> is the endpoint that
successfully was opened for listening.</p>
<pre class="literal-block">
struct listen_succeeded_alert final : alert
{
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::status;
   aux::noexcept_movable&lt;lt::address&gt; address;
   int const port;
   lt::socket_type_t const socket_type;
};
</pre>
<a name="address"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:listen_succeeded_alert%3A%3A%5Baddress%5D&labels=documentation&body=Documentation+under+heading+%22listen_succeeded_alert%3A%3A%5Baddress%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>address</dt>
<dd>the address libtorrent ended up listening on. This address
refers to the local interface.</dd>
</dl>
<a name="port"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:listen_succeeded_alert%3A%3A%5Bport%5D&labels=documentation&body=Documentation+under+heading+%22listen_succeeded_alert%3A%3A%5Bport%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>port</dt>
<dd>the port libtorrent ended up listening on.</dd>
</dl>
<a name="socket_type"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:listen_succeeded_alert%3A%3A%5Bsocket_type%5D&labels=documentation&body=Documentation+under+heading+%22listen_succeeded_alert%3A%3A%5Bsocket_type%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>socket_type</dt>
<dd>the type of listen socket this <a class="reference external" href="reference-Alerts.html#alert">alert</a> refers to.</dd>
</dl>
<a name="portmap_error_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+portmap_error_alert&labels=documentation&body=Documentation+under+heading+%22class+portmap_error_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="portmap-error-alert">
<h1>portmap_error_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This <a class="reference external" href="reference-Alerts.html#alert">alert</a> is generated when a NAT router was successfully found but some
part of the port mapping request failed. It contains a text message that
may help the user figure out what is wrong. This <a class="reference external" href="reference-Alerts.html#alert">alert</a> is not generated in
case it appears the client is not running on a NAT:ed network or if it
appears there is no NAT router that can be remote controlled to add port
mappings.</p>
<pre class="literal-block">
struct portmap_error_alert final : alert
{
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::port_mapping
   | alert_category::error;
   port_mapping_t const mapping;
   portmap_transport map_transport;
   aux::noexcept_movable&lt;address&gt; local_address;
   error_code const error;
};
</pre>
<a name="mapping"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:portmap_error_alert%3A%3A%5Bmapping%5D&labels=documentation&body=Documentation+under+heading+%22portmap_error_alert%3A%3A%5Bmapping%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>mapping</dt>
<dd>refers to the mapping index of the port map that failed, i.e.
the index returned from add_mapping().</dd>
</dl>
<a name="map_transport"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:portmap_error_alert%3A%3A%5Bmap_transport%5D&labels=documentation&body=Documentation+under+heading+%22portmap_error_alert%3A%3A%5Bmap_transport%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>map_transport</dt>
<dd>UPnP or NAT-PMP</dd>
</dl>
<a name="local_address"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:portmap_error_alert%3A%3A%5Blocal_address%5D&labels=documentation&body=Documentation+under+heading+%22portmap_error_alert%3A%3A%5Blocal_address%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>local_address</dt>
<dd>the local network the port mapper is running on</dd>
</dl>
<a name="error"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:portmap_error_alert%3A%3A%5Berror%5D&labels=documentation&body=Documentation+under+heading+%22portmap_error_alert%3A%3A%5Berror%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>error</dt>
<dd>tells you what failed.</dd>
</dl>
<a name="portmap_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+portmap_alert&labels=documentation&body=Documentation+under+heading+%22class+portmap_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="portmap-alert">
<h1>portmap_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This <a class="reference external" href="reference-Alerts.html#alert">alert</a> is generated when a NAT router was successfully found and
a port was successfully mapped on it. On a NAT:ed network with a NAT-PMP
capable router, this is typically generated once when mapping the TCP
port and, if DHT is enabled, when the UDP port is mapped.</p>
<pre class="literal-block">
struct portmap_alert final : alert
{
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::port_mapping;
   port_mapping_t const mapping;
   int const external_port;
   portmap_protocol const map_protocol;
   portmap_transport const map_transport;
   aux::noexcept_movable&lt;address&gt; local_address;
};
</pre>
<a name="mapping"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:portmap_alert%3A%3A%5Bmapping%5D&labels=documentation&body=Documentation+under+heading+%22portmap_alert%3A%3A%5Bmapping%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>mapping</dt>
<dd>refers to the mapping index of the port map that failed, i.e.
the index returned from add_mapping().</dd>
</dl>
<a name="external_port"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:portmap_alert%3A%3A%5Bexternal_port%5D&labels=documentation&body=Documentation+under+heading+%22portmap_alert%3A%3A%5Bexternal_port%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>external_port</dt>
<dd>the external port allocated for the mapping.</dd>
</dl>
<a name="local_address"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:portmap_alert%3A%3A%5Blocal_address%5D&labels=documentation&body=Documentation+under+heading+%22portmap_alert%3A%3A%5Blocal_address%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>local_address</dt>
<dd>the local network the port mapper is running on</dd>
</dl>
<a name="portmap_log_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+portmap_log_alert&labels=documentation&body=Documentation+under+heading+%22class+portmap_log_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="portmap-log-alert">
<h1>portmap_log_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This <a class="reference external" href="reference-Alerts.html#alert">alert</a> is generated to log informational events related to either
UPnP or NAT-PMP. They contain a log line and the type (0 = NAT-PMP
and 1 = UPnP). Displaying these messages to an end user is only useful
for debugging the UPnP or NAT-PMP implementation. This <a class="reference external" href="reference-Alerts.html#alert">alert</a> is only
posted if the alert_category::port_mapping_log flag is enabled in
the <a class="reference external" href="reference-Alerts.html#alert">alert</a> mask.</p>
<pre class="literal-block">
struct portmap_log_alert final : alert
{
   std::string <strong>message</strong> () const override;
   char const* <strong>log_message</strong> () const;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::port_mapping_log;
   portmap_transport const map_transport;
   aux::noexcept_movable&lt;address&gt; local_address;
};
</pre>
<a name="log_message()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:portmap_log_alert%3A%3A%5Blog_message%28%29%5D&labels=documentation&body=Documentation+under+heading+%22portmap_log_alert%3A%3A%5Blog_message%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="log-message">
<h2>log_message()</h2>
<pre class="literal-block">
char const* <strong>log_message</strong> () const;
</pre>
<p>the message associated with this log line</p>
<a name="local_address"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:portmap_log_alert%3A%3A%5Blocal_address%5D&labels=documentation&body=Documentation+under+heading+%22portmap_log_alert%3A%3A%5Blocal_address%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>local_address</dt>
<dd>the local network the port mapper is running on</dd>
</dl>
<a name="fastresume_rejected_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+fastresume_rejected_alert&labels=documentation&body=Documentation+under+heading+%22class+fastresume_rejected_alert%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="fastresume-rejected-alert">
<h1>fastresume_rejected_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This <a class="reference external" href="reference-Alerts.html#alert">alert</a> is generated when a fast resume file has been passed to
<a class="reference external" href="reference-Session.html#add_torrent()">add_torrent()</a> but the files on disk did not match the fast resume file.
The error_code explains the reason why the resume file was rejected.</p>
<pre class="literal-block">
struct fastresume_rejected_alert final : torrent_alert
{
   std::string <strong>message</strong> () const override;
   char const* <strong>file_path</strong> () const;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::status
   | alert_category::error;
   error_code error;
   operation_t op;
};
</pre>
<a name="file_path()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:fastresume_rejected_alert%3A%3A%5Bfile_path%28%29%5D&labels=documentation&body=Documentation+under+heading+%22fastresume_rejected_alert%3A%3A%5Bfile_path%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="file-path-1">
<h2>file_path()</h2>
<pre class="literal-block">
char const* <strong>file_path</strong> () const;
</pre>
<p>If the error happened to a specific file, this returns the path to it.</p>
<a name="op"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:fastresume_rejected_alert%3A%3A%5Bop%5D&labels=documentation&body=Documentation+under+heading+%22fastresume_rejected_alert%3A%3A%5Bop%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>op</dt>
<dd>the underlying operation that failed</dd>
</dl>
<a name="peer_blocked_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+peer_blocked_alert&labels=documentation&body=Documentation+under+heading+%22class+peer_blocked_alert%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="peer-blocked-alert">
<h1>peer_blocked_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This <a class="reference external" href="reference-Alerts.html#alert">alert</a> is posted when an incoming peer connection, or a peer that's about to be added
to our peer list, is blocked for some reason. This could be any of:</p>
<ul class="simple">
<li>the IP filter</li>
<li>i2p mixed mode restrictions (a normal peer is not allowed on an i2p swarm)</li>
<li>the port filter</li>
<li>the peer has a low port and <tt class="docutils literal">no_connect_privileged_ports</tt> is enabled</li>
<li>the protocol of the peer is blocked (uTP/TCP blocking)</li>
</ul>
<pre class="literal-block">
struct peer_blocked_alert final : peer_alert
{
   std::string <strong>message</strong> () const override;

   enum reason_t
   {
      ip_filter,
      port_filter,
      i2p_mixed,
      privileged_ports,
      utp_disabled,
      tcp_disabled,
      invalid_local_interface,
      ssrf_mitigation,
   };

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::ip_block;
   int const reason;
};
</pre>
<a name="reason_t"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+reason_t&labels=documentation&body=Documentation+under+heading+%22enum+reason_t%22+could+be+improved">report issue</a>]</span><div class="section" id="enum-reason-t">
<h2>enum reason_t</h2>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="56%" />
<col width="16%" />
<col width="29%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>ip_filter</td>
<td>0</td>
<td>&nbsp;</td>
</tr>
<tr><td>port_filter</td>
<td>1</td>
<td>&nbsp;</td>
</tr>
<tr><td>i2p_mixed</td>
<td>2</td>
<td>&nbsp;</td>
</tr>
<tr><td>privileged_ports</td>
<td>3</td>
<td>&nbsp;</td>
</tr>
<tr><td>utp_disabled</td>
<td>4</td>
<td>&nbsp;</td>
</tr>
<tr><td>tcp_disabled</td>
<td>5</td>
<td>&nbsp;</td>
</tr>
<tr><td>invalid_local_interface</td>
<td>6</td>
<td>&nbsp;</td>
</tr>
<tr><td>ssrf_mitigation</td>
<td>7</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<a name="reason"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_blocked_alert%3A%3A%5Breason%5D&labels=documentation&body=Documentation+under+heading+%22peer_blocked_alert%3A%3A%5Breason%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>reason</dt>
<dd>the reason for the peer being blocked. Is one of the values from the
<a class="reference external" href="reference-Alerts.html#reason_t">reason_t</a> enum.</dd>
</dl>
<a name="dht_announce_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+dht_announce_alert&labels=documentation&body=Documentation+under+heading+%22class+dht_announce_alert%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="dht-announce-alert">
<h1>dht_announce_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This <a class="reference external" href="reference-Alerts.html#alert">alert</a> is generated when a DHT node announces to an info-hash on our
DHT node. It belongs to the <tt class="docutils literal"><span class="pre">alert_category::dht</span></tt> category.</p>
<pre class="literal-block">
struct dht_announce_alert final : alert
{
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::dht;
   aux::noexcept_movable&lt;address&gt; ip;
   int port;
   sha1_hash info_hash;
};
</pre>
<a name="dht_get_peers_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+dht_get_peers_alert&labels=documentation&body=Documentation+under+heading+%22class+dht_get_peers_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="dht-get-peers-alert">
<h1>dht_get_peers_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This <a class="reference external" href="reference-Alerts.html#alert">alert</a> is generated when a DHT node sends a <tt class="docutils literal">get_peers</tt> message to
our DHT node. It belongs to the <tt class="docutils literal"><span class="pre">alert_category::dht</span></tt> category.</p>
<pre class="literal-block">
struct dht_get_peers_alert final : alert
{
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::dht;
   sha1_hash info_hash;
};
</pre>
<a name="cache_flushed_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+cache_flushed_alert&labels=documentation&body=Documentation+under+heading+%22class+cache_flushed_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="cache-flushed-alert">
<h1>cache_flushed_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This <a class="reference external" href="reference-Alerts.html#alert">alert</a> is posted when the disk cache has been flushed for a specific
torrent as a result of a call to <a class="reference external" href="reference-Torrent_Handle.html#flush_cache()">torrent_handle::flush_cache()</a>. This
<a class="reference external" href="reference-Alerts.html#alert">alert</a> belongs to the <tt class="docutils literal"><span class="pre">alert_category::storage</span></tt> category, which must be
enabled to let this <a class="reference external" href="reference-Alerts.html#alert">alert</a> through. The <a class="reference external" href="reference-Alerts.html#alert">alert</a> is also posted when removing
a torrent from the <a class="reference external" href="reference-Session.html#session">session</a>, once the outstanding cache flush is complete
and the torrent does no longer have any files open.</p>
<pre class="literal-block">
struct cache_flushed_alert final : torrent_alert
{
   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::storage;
};
</pre>
<a name="lsd_peer_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+lsd_peer_alert&labels=documentation&body=Documentation+under+heading+%22class+lsd_peer_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="lsd-peer-alert">
<h1>lsd_peer_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This <a class="reference external" href="reference-Alerts.html#alert">alert</a> is generated when we receive a local service discovery message
from a peer for a torrent we're currently participating in.</p>
<pre class="literal-block">
struct lsd_peer_alert final : peer_alert
{
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::peer;
};
</pre>
<a name="trackerid_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+trackerid_alert&labels=documentation&body=Documentation+under+heading+%22class+trackerid_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="trackerid-alert">
<h1>trackerid_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This <a class="reference external" href="reference-Alerts.html#alert">alert</a> is posted whenever a tracker responds with a <tt class="docutils literal">trackerid</tt>.
The tracker ID is like a cookie. libtorrent will store the tracker ID
for this tracker and repeat it in subsequent announces.</p>
<pre class="literal-block">
struct trackerid_alert final : tracker_alert
{
   std::string <strong>message</strong> () const override;
   char const* <strong>tracker_id</strong> () const;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::status;
};
</pre>
<a name="tracker_id()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:trackerid_alert%3A%3A%5Btracker_id%28%29%5D&labels=documentation&body=Documentation+under+heading+%22trackerid_alert%3A%3A%5Btracker_id%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="tracker-id">
<h2>tracker_id()</h2>
<pre class="literal-block">
char const* <strong>tracker_id</strong> () const;
</pre>
<p>The tracker ID returned by the tracker</p>
<a name="dht_bootstrap_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+dht_bootstrap_alert&labels=documentation&body=Documentation+under+heading+%22class+dht_bootstrap_alert%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="dht-bootstrap-alert">
<h1>dht_bootstrap_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This <a class="reference external" href="reference-Alerts.html#alert">alert</a> is posted when the initial DHT bootstrap is done.</p>
<pre class="literal-block">
struct dht_bootstrap_alert final : alert
{
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::dht;
};
</pre>
<a name="torrent_error_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+torrent_error_alert&labels=documentation&body=Documentation+under+heading+%22class+torrent_error_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="torrent-error-alert">
<h1>torrent_error_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This is posted whenever a torrent is transitioned into the error state.
If the error code is duplicate_torrent (<a class="reference external" href="reference-Error_Codes.html#error_code_enum">error_code_enum</a>) error, it suggests two magnet
links ended up resolving to the same hybrid torrent. For more details,
see <a class="reference external" href="manual-ref.html#bittorrent-v2-torrents">BitTorrent v2 torrents</a>.</p>
<pre class="literal-block">
struct torrent_error_alert final : torrent_alert
{
   std::string <strong>message</strong> () const override;
   char const* <strong>filename</strong> () const;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::error | alert_category::status;
   error_code const error;
};
</pre>
<a name="filename()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_error_alert%3A%3A%5Bfilename%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_error_alert%3A%3A%5Bfilename%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="filename-1">
<h2>filename()</h2>
<pre class="literal-block">
char const* <strong>filename</strong> () const;
</pre>
<p>the filename (or object) the error occurred on.</p>
<a name="error"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_error_alert%3A%3A%5Berror%5D&labels=documentation&body=Documentation+under+heading+%22torrent_error_alert%3A%3A%5Berror%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>error</dt>
<dd>specifies which error the torrent encountered.</dd>
</dl>
<a name="torrent_need_cert_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+torrent_need_cert_alert&labels=documentation&body=Documentation+under+heading+%22class+torrent_need_cert_alert%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="torrent-need-cert-alert">
<h1>torrent_need_cert_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This is always posted for SSL torrents. This is a reminder to the client that
the torrent won't work unless <a class="reference external" href="reference-Torrent_Handle.html#set_ssl_certificate()">torrent_handle::set_ssl_certificate()</a> is called with
a valid certificate. Valid certificates MUST be signed by the SSL certificate
in the .torrent file.</p>
<pre class="literal-block">
struct torrent_need_cert_alert final : torrent_alert
{
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::status;
};
</pre>
<a name="incoming_connection_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+incoming_connection_alert&labels=documentation&body=Documentation+under+heading+%22class+incoming_connection_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="incoming-connection-alert">
<h1>incoming_connection_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>The incoming connection <a class="reference external" href="reference-Alerts.html#alert">alert</a> is posted every time we successfully accept
an incoming connection, through any mean. The most straight-forward ways
of accepting incoming connections are through the TCP listen socket and
the UDP listen socket for uTP sockets. However, connections may also be
accepted through a Socks5 or i2p listen socket, or via an SSL listen
socket.</p>
<pre class="literal-block">
struct incoming_connection_alert final : alert
{
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::peer;
   socket_type_t socket_type;
   aux::noexcept_movable&lt;<a class="reference external" href="tcp::endpoint">tcp::endpoint</a>&gt; endpoint;
};
</pre>
<a name="socket_type"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:incoming_connection_alert%3A%3A%5Bsocket_type%5D&labels=documentation&body=Documentation+under+heading+%22incoming_connection_alert%3A%3A%5Bsocket_type%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>socket_type</dt>
<dd>tells you what kind of socket the connection was accepted</dd>
</dl>
<a name="endpoint"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:incoming_connection_alert%3A%3A%5Bendpoint%5D&labels=documentation&body=Documentation+under+heading+%22incoming_connection_alert%3A%3A%5Bendpoint%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>endpoint</dt>
<dd>is the IP address and port the connection came from.</dd>
</dl>
<a name="add_torrent_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+add_torrent_alert&labels=documentation&body=Documentation+under+heading+%22class+add_torrent_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="add-torrent-alert">
<h1>add_torrent_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This <a class="reference external" href="reference-Alerts.html#alert">alert</a> is always posted when a torrent was attempted to be added
and contains the return status of the add operation. The torrent handle of the new
torrent can be found as the <tt class="docutils literal">handle</tt> member in the base class. If adding
the torrent failed, <tt class="docutils literal">error</tt> contains the error code.</p>
<pre class="literal-block">
struct add_torrent_alert final : torrent_alert
{
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::status;
   add_torrent_params params;
   error_code error;
};
</pre>
<a name="params"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_alert%3A%3A%5Bparams%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_alert%3A%3A%5Bparams%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>params</dt>
<dd><p class="first">This contains copies of the most important fields from the original
<a class="reference external" href="reference-Add_Torrent.html#add_torrent_params">add_torrent_params</a> object, passed to <a class="reference external" href="reference-Session.html#add_torrent()">add_torrent()</a> or
<a class="reference external" href="reference-Session.html#async_add_torrent()">async_add_torrent()</a>. Specifically, these fields are copied:</p>
<ul class="simple">
<li>version</li>
<li>ti</li>
<li>name</li>
<li>save_path</li>
<li>userdata</li>
<li>tracker_id</li>
<li>flags</li>
<li>info_hash</li>
</ul>
<p class="last">the info_hash field will be updated with the info-hash of the torrent
specified by <tt class="docutils literal">ti</tt>.</p>
</dd>
</dl>
<a name="error"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_alert%3A%3A%5Berror%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_alert%3A%3A%5Berror%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>error</dt>
<dd>set to the error, if one occurred while adding the torrent.</dd>
</dl>
<a name="state_update_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+state_update_alert&labels=documentation&body=Documentation+under+heading+%22class+state_update_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="state-update-alert">
<h1>state_update_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This <a class="reference external" href="reference-Alerts.html#alert">alert</a> is only posted when requested by the user, by calling
session::post_torrent_updates() on the <a class="reference external" href="reference-Session.html#session">session</a>. It contains the torrent
status of all torrents that changed since last time this message was
posted. Its category is <tt class="docutils literal"><span class="pre">alert_category::status</span></tt>, but it's not subject to
filtering, since it's only manually posted anyway.</p>
<pre class="literal-block">
struct state_update_alert final : alert
{
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::status;
   std::vector&lt;torrent_status&gt; status;
};
</pre>
<a name="status"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:state_update_alert%3A%3A%5Bstatus%5D&labels=documentation&body=Documentation+under+heading+%22state_update_alert%3A%3A%5Bstatus%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>status</dt>
<dd>contains the torrent status of all torrents that changed since last
time this message was posted. Note that you can map a torrent status
to a specific torrent via its <tt class="docutils literal">handle</tt> member. The receiving end is
suggested to have all torrents sorted by the <a class="reference external" href="reference-Torrent_Handle.html#torrent_handle">torrent_handle</a> or hashed
by it, for efficient updates.</dd>
</dl>
<a name="session_stats_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+session_stats_alert&labels=documentation&body=Documentation+under+heading+%22class+session_stats_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="session-stats-alert">
<h1>session_stats_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>The <a class="reference external" href="reference-Alerts.html#session_stats_alert">session_stats_alert</a> is posted when the user requests <a class="reference external" href="reference-Session.html#session">session</a> statistics by
calling <a class="reference external" href="reference-Session.html#post_session_stats()">post_session_stats()</a> on the <a class="reference external" href="reference-Session.html#session">session</a> object. This <a class="reference external" href="reference-Alerts.html#alert">alert</a> does not
have a category, since it's only posted in response to an API call. It
is not subject to the alert_mask filter.</p>
<p>the <tt class="docutils literal">message()</tt> member function returns a string representation of the values that
properly match the line returned in <tt class="docutils literal"><span class="pre">session_stats_header_alert::message()</span></tt>.</p>
<p>this specific output is parsed by tools/parse_session_stats.py
if this is changed, that parser should also be changed</p>
<pre class="literal-block">
struct session_stats_alert final : alert
{
   std::string <strong>message</strong> () const override;
   span&lt;std::int64_t const&gt; <strong>counters</strong> () const;

   static constexpr alert_category_t <strong>static_category</strong>  = {};
};
</pre>
<a name="counters()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session_stats_alert%3A%3A%5Bcounters%28%29%5D&labels=documentation&body=Documentation+under+heading+%22session_stats_alert%3A%3A%5Bcounters%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="counters">
<h2>counters()</h2>
<pre class="literal-block">
span&lt;std::int64_t const&gt; <strong>counters</strong> () const;
</pre>
<p>An array are a mix of <em>counters</em> and <em>gauges</em>, which meanings can be
queries via the <a class="reference external" href="reference-Stats.html#session_stats_metrics()">session_stats_metrics()</a> function on the <a class="reference external" href="reference-Session.html#session">session</a>. The
mapping from a specific metric to an index into this array is constant
for a specific version of libtorrent, but may differ for other
versions. The intended usage is to request the mapping, i.e. call
<a class="reference external" href="reference-Stats.html#session_stats_metrics()">session_stats_metrics()</a>, once on startup, and then use that mapping to
interpret these values throughout the process' runtime.</p>
<p>For more information, see the <a class="reference external" href="manual-ref.html#session-statistics">session statistics</a> section.</p>
<a name="dht_error_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+dht_error_alert&labels=documentation&body=Documentation+under+heading+%22class+dht_error_alert%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="dht-error-alert">
<h1>dht_error_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>posted when something fails in the DHT. This is not necessarily a fatal
error, but it could prevent proper operation</p>
<pre class="literal-block">
struct dht_error_alert final : alert
{
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::error | alert_category::dht;
   error_code error;
   operation_t op;
};
</pre>
<a name="error"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_error_alert%3A%3A%5Berror%5D&labels=documentation&body=Documentation+under+heading+%22dht_error_alert%3A%3A%5Berror%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>error</dt>
<dd>the error code</dd>
</dl>
<a name="op"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_error_alert%3A%3A%5Bop%5D&labels=documentation&body=Documentation+under+heading+%22dht_error_alert%3A%3A%5Bop%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>op</dt>
<dd>the operation that failed</dd>
</dl>
<a name="dht_immutable_item_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+dht_immutable_item_alert&labels=documentation&body=Documentation+under+heading+%22class+dht_immutable_item_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="dht-immutable-item-alert">
<h1>dht_immutable_item_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>this <a class="reference external" href="reference-Alerts.html#alert">alert</a> is posted as a response to a call to session::get_item(),
specifically the overload for looking up immutable items in the DHT.</p>
<pre class="literal-block">
struct dht_immutable_item_alert final : alert
{
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::dht;
   sha1_hash target;
   entry item;
};
</pre>
<a name="target"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_immutable_item_alert%3A%3A%5Btarget%5D&labels=documentation&body=Documentation+under+heading+%22dht_immutable_item_alert%3A%3A%5Btarget%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>target</dt>
<dd>the target hash of the immutable item. This must
match the SHA-1 hash of the bencoded form of <tt class="docutils literal">item</tt>.</dd>
</dl>
<a name="item"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_immutable_item_alert%3A%3A%5Bitem%5D&labels=documentation&body=Documentation+under+heading+%22dht_immutable_item_alert%3A%3A%5Bitem%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>item</dt>
<dd>the data for this item</dd>
</dl>
<a name="dht_mutable_item_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+dht_mutable_item_alert&labels=documentation&body=Documentation+under+heading+%22class+dht_mutable_item_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="dht-mutable-item-alert">
<h1>dht_mutable_item_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>this <a class="reference external" href="reference-Alerts.html#alert">alert</a> is posted as a response to a call to session::get_item(),
specifically the overload for looking up mutable items in the DHT.</p>
<pre class="literal-block">
struct dht_mutable_item_alert final : alert
{
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::dht;
   std::array&lt;char, 32&gt; key;
   std::array&lt;char, 64&gt; signature;
   std::int64_t seq;
   std::string salt;
   entry item;
   bool authoritative;
};
</pre>
<a name="key"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_mutable_item_alert%3A%3A%5Bkey%5D&labels=documentation&body=Documentation+under+heading+%22dht_mutable_item_alert%3A%3A%5Bkey%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>key</dt>
<dd>the public key that was looked up</dd>
</dl>
<a name="signature"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_mutable_item_alert%3A%3A%5Bsignature%5D&labels=documentation&body=Documentation+under+heading+%22dht_mutable_item_alert%3A%3A%5Bsignature%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>signature</dt>
<dd>the signature of the data. This is not the signature of the
plain encoded form of the item, but it includes the sequence number
and possibly the hash as well. See the dht_store document for more
information. This is primarily useful for echoing back in a store
request.</dd>
</dl>
<a name="seq"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_mutable_item_alert%3A%3A%5Bseq%5D&labels=documentation&body=Documentation+under+heading+%22dht_mutable_item_alert%3A%3A%5Bseq%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>seq</dt>
<dd>the sequence number of this item</dd>
</dl>
<a name="salt"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_mutable_item_alert%3A%3A%5Bsalt%5D&labels=documentation&body=Documentation+under+heading+%22dht_mutable_item_alert%3A%3A%5Bsalt%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>salt</dt>
<dd>the salt, if any, used to lookup and store this item. If no
salt was used, this is an empty string</dd>
</dl>
<a name="item"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_mutable_item_alert%3A%3A%5Bitem%5D&labels=documentation&body=Documentation+under+heading+%22dht_mutable_item_alert%3A%3A%5Bitem%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>item</dt>
<dd>the data for this item</dd>
</dl>
<a name="authoritative"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_mutable_item_alert%3A%3A%5Bauthoritative%5D&labels=documentation&body=Documentation+under+heading+%22dht_mutable_item_alert%3A%3A%5Bauthoritative%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>authoritative</dt>
<dd>the last response for mutable data is authoritative.</dd>
</dl>
<a name="dht_put_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+dht_put_alert&labels=documentation&body=Documentation+under+heading+%22class+dht_put_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="dht-put-alert">
<h1>dht_put_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>this is posted when a DHT put operation completes. This is useful if the
client is waiting for a put to complete before shutting down for instance.</p>
<pre class="literal-block">
struct dht_put_alert final : alert
{
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::dht;
   sha1_hash target;
   std::array&lt;char, 32&gt; public_key;
   std::array&lt;char, 64&gt; signature;
   std::string salt;
   std::int64_t seq;
   int num_success;
};
</pre>
<a name="target"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_put_alert%3A%3A%5Btarget%5D&labels=documentation&body=Documentation+under+heading+%22dht_put_alert%3A%3A%5Btarget%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>target</dt>
<dd>the target hash the item was stored under if this was an <em>immutable</em>
item.</dd>
</dl>
<a name="public_key"></a>
<a name="signature"></a>
<a name="salt"></a>
<a name="seq"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_put_alert%3A%3A%5Bpublic_key+signature+salt+seq%5D&labels=documentation&body=Documentation+under+heading+%22dht_put_alert%3A%3A%5Bpublic_key+signature+salt+seq%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>public_key signature salt seq</dt>
<dd>if a mutable item was stored, these are the public key, signature,
salt and sequence number the item was stored under.</dd>
</dl>
<a name="num_success"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_put_alert%3A%3A%5Bnum_success%5D&labels=documentation&body=Documentation+under+heading+%22dht_put_alert%3A%3A%5Bnum_success%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>num_success</dt>
<dd>DHT put operation usually writes item to k nodes, maybe the node
is stale so no response, or the node doesn't support 'put', or the
token for write is out of date, etc. num_success is the number of
successful responses we got from the puts.</dd>
</dl>
<a name="i2p_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+i2p_alert&labels=documentation&body=Documentation+under+heading+%22class+i2p_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="i2p-alert">
<h1>i2p_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>this <a class="reference external" href="reference-Alerts.html#alert">alert</a> is used to report errors in the i2p SAM connection</p>
<pre class="literal-block">
struct i2p_alert final : alert
{
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::error;
   error_code error;
};
</pre>
<a name="error"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:i2p_alert%3A%3A%5Berror%5D&labels=documentation&body=Documentation+under+heading+%22i2p_alert%3A%3A%5Berror%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>error</dt>
<dd>the error that occurred in the i2p SAM connection</dd>
</dl>
<a name="dht_outgoing_get_peers_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+dht_outgoing_get_peers_alert&labels=documentation&body=Documentation+under+heading+%22class+dht_outgoing_get_peers_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="dht-outgoing-get-peers-alert">
<h1>dht_outgoing_get_peers_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This <a class="reference external" href="reference-Alerts.html#alert">alert</a> is generated when we send a get_peers request
It belongs to the <tt class="docutils literal"><span class="pre">alert_category::dht</span></tt> category.</p>
<pre class="literal-block">
struct dht_outgoing_get_peers_alert final : alert
{
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::dht;
   sha1_hash info_hash;
   sha1_hash obfuscated_info_hash;
   aux::noexcept_movable&lt;udp::endpoint&gt; endpoint;
};
</pre>
<a name="info_hash"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_outgoing_get_peers_alert%3A%3A%5Binfo_hash%5D&labels=documentation&body=Documentation+under+heading+%22dht_outgoing_get_peers_alert%3A%3A%5Binfo_hash%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>info_hash</dt>
<dd>the info_hash of the torrent we're looking for peers for.</dd>
</dl>
<a name="obfuscated_info_hash"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_outgoing_get_peers_alert%3A%3A%5Bobfuscated_info_hash%5D&labels=documentation&body=Documentation+under+heading+%22dht_outgoing_get_peers_alert%3A%3A%5Bobfuscated_info_hash%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>obfuscated_info_hash</dt>
<dd>if this was an obfuscated lookup, this is the info-hash target
actually sent to the node.</dd>
</dl>
<a name="endpoint"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_outgoing_get_peers_alert%3A%3A%5Bendpoint%5D&labels=documentation&body=Documentation+under+heading+%22dht_outgoing_get_peers_alert%3A%3A%5Bendpoint%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>endpoint</dt>
<dd>the endpoint we're sending this query to</dd>
</dl>
<a name="log_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+log_alert&labels=documentation&body=Documentation+under+heading+%22class+log_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="log-alert">
<h1>log_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This <a class="reference external" href="reference-Alerts.html#alert">alert</a> is posted by some <a class="reference external" href="reference-Session.html#session">session</a> wide event. Its main purpose is
trouble shooting and debugging. It's not enabled by the default <a class="reference external" href="reference-Alerts.html#alert">alert</a>
mask and is enabled by the <tt class="docutils literal"><span class="pre">alert_category::session_log</span></tt> bit.
Furthermore, it's by default disabled as a build configuration.</p>
<pre class="literal-block">
struct log_alert final : alert
{
   std::string <strong>message</strong> () const override;
   char const* <strong>log_message</strong> () const;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::session_log;
};
</pre>
<a name="log_message()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:log_alert%3A%3A%5Blog_message%28%29%5D&labels=documentation&body=Documentation+under+heading+%22log_alert%3A%3A%5Blog_message%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="log-message-1">
<h2>log_message()</h2>
<pre class="literal-block">
char const* <strong>log_message</strong> () const;
</pre>
<p>returns the log message</p>
<a name="torrent_log_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+torrent_log_alert&labels=documentation&body=Documentation+under+heading+%22class+torrent_log_alert%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="torrent-log-alert">
<h1>torrent_log_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This <a class="reference external" href="reference-Alerts.html#alert">alert</a> is posted by torrent wide events. It's meant to be used for
trouble shooting and debugging. It's not enabled by the default <a class="reference external" href="reference-Alerts.html#alert">alert</a>
mask and is enabled by the <tt class="docutils literal"><span class="pre">alert_category::torrent_log</span></tt> bit. By
default it is disabled as a build configuration.</p>
<pre class="literal-block">
struct torrent_log_alert final : torrent_alert
{
   std::string <strong>message</strong> () const override;
   char const* <strong>log_message</strong> () const;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::torrent_log;
};
</pre>
<a name="log_message()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_log_alert%3A%3A%5Blog_message%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_log_alert%3A%3A%5Blog_message%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="log-message-2">
<h2>log_message()</h2>
<pre class="literal-block">
char const* <strong>log_message</strong> () const;
</pre>
<p>returns the log message</p>
<a name="peer_log_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+peer_log_alert&labels=documentation&body=Documentation+under+heading+%22class+peer_log_alert%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="peer-log-alert">
<h1>peer_log_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This <a class="reference external" href="reference-Alerts.html#alert">alert</a> is posted by events specific to a peer. It's meant to be used
for trouble shooting and debugging. It's not enabled by the default <a class="reference external" href="reference-Alerts.html#alert">alert</a>
mask and is enabled by the <tt class="docutils literal"><span class="pre">alert_category::peer_log</span></tt> bit. By
default it is disabled as a build configuration.</p>
<pre class="literal-block">
struct peer_log_alert final : peer_alert
{
   std::string <strong>message</strong> () const override;
   char const* <strong>log_message</strong> () const;

   enum direction_t
   {
      incoming_message,
      outgoing_message,
      incoming,
      outgoing,
      info,
   };

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::peer_log;
   char const* event_type;
   direction_t direction;
};
</pre>
<a name="log_message()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_log_alert%3A%3A%5Blog_message%28%29%5D&labels=documentation&body=Documentation+under+heading+%22peer_log_alert%3A%3A%5Blog_message%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="log-message-3">
<h2>log_message()</h2>
<pre class="literal-block">
char const* <strong>log_message</strong> () const;
</pre>
<p>returns the log message</p>
<a name="direction_t"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+direction_t&labels=documentation&body=Documentation+under+heading+%22enum+direction_t%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-direction-t-1">
<h2>enum direction_t</h2>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="47%" />
<col width="18%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>incoming_message</td>
<td>0</td>
<td>&nbsp;</td>
</tr>
<tr><td>outgoing_message</td>
<td>1</td>
<td>&nbsp;</td>
</tr>
<tr><td>incoming</td>
<td>2</td>
<td>&nbsp;</td>
</tr>
<tr><td>outgoing</td>
<td>3</td>
<td>&nbsp;</td>
</tr>
<tr><td>info</td>
<td>4</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<a name="event_type"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_log_alert%3A%3A%5Bevent_type%5D&labels=documentation&body=Documentation+under+heading+%22peer_log_alert%3A%3A%5Bevent_type%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>event_type</dt>
<dd>string literal indicating the kind of event. For messages, this is the
message name.</dd>
</dl>
<a name="lsd_error_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+lsd_error_alert&labels=documentation&body=Documentation+under+heading+%22class+lsd_error_alert%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="lsd-error-alert">
<h1>lsd_error_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>posted if the local service discovery socket fails to start properly.
it's categorized as <tt class="docutils literal"><span class="pre">alert_category::error</span></tt>.</p>
<pre class="literal-block">
struct lsd_error_alert final : alert
{
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::error;
   aux::noexcept_movable&lt;address&gt; local_address;
   error_code error;
};
</pre>
<a name="local_address"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:lsd_error_alert%3A%3A%5Blocal_address%5D&labels=documentation&body=Documentation+under+heading+%22lsd_error_alert%3A%3A%5Blocal_address%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>local_address</dt>
<dd>the local network the corresponding local service discovery is running
on</dd>
</dl>
<a name="error"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:lsd_error_alert%3A%3A%5Berror%5D&labels=documentation&body=Documentation+under+heading+%22lsd_error_alert%3A%3A%5Berror%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>error</dt>
<dd>The error code</dd>
</dl>
<a name="dht_lookup"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+dht_lookup&labels=documentation&body=Documentation+under+heading+%22class+dht_lookup%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="dht-lookup">
<h1>dht_lookup</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>holds statistics about a current <a class="reference external" href="reference-Alerts.html#dht_lookup">dht_lookup</a> operation.
a DHT lookup is the traversal of nodes, looking up a
set of target nodes in the DHT for retrieving and possibly
storing information in the DHT</p>
<pre class="literal-block">
struct dht_lookup
{
   char const* type;
   int outstanding_requests;
   int timeouts;
   int responses;
   int branch_factor;
   int nodes_left;
   int last_sent;
   int first_timeout;
   sha1_hash target;
};
</pre>
<a name="type"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_lookup%3A%3A%5Btype%5D&labels=documentation&body=Documentation+under+heading+%22dht_lookup%3A%3A%5Btype%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>type</dt>
<dd>string literal indicating which kind of lookup this is</dd>
</dl>
<a name="outstanding_requests"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_lookup%3A%3A%5Boutstanding_requests%5D&labels=documentation&body=Documentation+under+heading+%22dht_lookup%3A%3A%5Boutstanding_requests%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>outstanding_requests</dt>
<dd>the number of outstanding request to individual nodes
this lookup has right now</dd>
</dl>
<a name="timeouts"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_lookup%3A%3A%5Btimeouts%5D&labels=documentation&body=Documentation+under+heading+%22dht_lookup%3A%3A%5Btimeouts%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>timeouts</dt>
<dd>the total number of requests that have timed out so far
for this lookup</dd>
</dl>
<a name="responses"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_lookup%3A%3A%5Bresponses%5D&labels=documentation&body=Documentation+under+heading+%22dht_lookup%3A%3A%5Bresponses%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>responses</dt>
<dd>the total number of responses we have received for this
lookup so far for this lookup</dd>
</dl>
<a name="branch_factor"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_lookup%3A%3A%5Bbranch_factor%5D&labels=documentation&body=Documentation+under+heading+%22dht_lookup%3A%3A%5Bbranch_factor%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>branch_factor</dt>
<dd>the branch factor for this lookup. This is the number of
nodes we keep outstanding requests to in parallel by default.
when nodes time out we may increase this.</dd>
</dl>
<a name="nodes_left"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_lookup%3A%3A%5Bnodes_left%5D&labels=documentation&body=Documentation+under+heading+%22dht_lookup%3A%3A%5Bnodes_left%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>nodes_left</dt>
<dd>the number of nodes left that could be queries for this
lookup. Many of these are likely to be part of the trail
while performing the lookup and would never end up actually
being queried.</dd>
</dl>
<a name="last_sent"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_lookup%3A%3A%5Blast_sent%5D&labels=documentation&body=Documentation+under+heading+%22dht_lookup%3A%3A%5Blast_sent%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>last_sent</dt>
<dd>the number of seconds ago the
last message was sent that's still
outstanding</dd>
</dl>
<a name="first_timeout"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_lookup%3A%3A%5Bfirst_timeout%5D&labels=documentation&body=Documentation+under+heading+%22dht_lookup%3A%3A%5Bfirst_timeout%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>first_timeout</dt>
<dd>the number of outstanding requests
that have exceeded the short timeout
and are considered timed out in the
sense that they increased the branch
factor</dd>
</dl>
<a name="target"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_lookup%3A%3A%5Btarget%5D&labels=documentation&body=Documentation+under+heading+%22dht_lookup%3A%3A%5Btarget%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>target</dt>
<dd>the node-id or info-hash target for this lookup</dd>
</dl>
<a name="dht_stats_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+dht_stats_alert&labels=documentation&body=Documentation+under+heading+%22class+dht_stats_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="dht-stats-alert">
<h1>dht_stats_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>contains current DHT state. Posted in response to session::post_dht_stats().</p>
<pre class="literal-block">
struct dht_stats_alert final : alert
{
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = {};
   std::vector&lt;dht_lookup&gt; active_requests;
   std::vector&lt;dht_routing_bucket&gt; routing_table;
   sha1_hash nid;
   aux::noexcept_movable&lt;udp::endpoint&gt; local_endpoint;
};
</pre>
<a name="active_requests"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_stats_alert%3A%3A%5Bactive_requests%5D&labels=documentation&body=Documentation+under+heading+%22dht_stats_alert%3A%3A%5Bactive_requests%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>active_requests</dt>
<dd>a vector of the currently running DHT lookups.</dd>
</dl>
<a name="routing_table"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_stats_alert%3A%3A%5Brouting_table%5D&labels=documentation&body=Documentation+under+heading+%22dht_stats_alert%3A%3A%5Brouting_table%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>routing_table</dt>
<dd>contains information about every bucket in the DHT routing
table.</dd>
</dl>
<a name="nid"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_stats_alert%3A%3A%5Bnid%5D&labels=documentation&body=Documentation+under+heading+%22dht_stats_alert%3A%3A%5Bnid%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>nid</dt>
<dd>the node ID of the DHT node instance</dd>
</dl>
<a name="local_endpoint"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_stats_alert%3A%3A%5Blocal_endpoint%5D&labels=documentation&body=Documentation+under+heading+%22dht_stats_alert%3A%3A%5Blocal_endpoint%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>local_endpoint</dt>
<dd>the local socket this DHT node is running on</dd>
</dl>
<a name="incoming_request_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+incoming_request_alert&labels=documentation&body=Documentation+under+heading+%22class+incoming_request_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="incoming-request-alert">
<h1>incoming_request_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>posted every time an incoming request from a peer is accepted and queued
up for being serviced. This <a class="reference external" href="reference-Alerts.html#alert">alert</a> is only posted if
the alert_category::incoming_request flag is enabled in the <a class="reference external" href="reference-Alerts.html#alert">alert</a>
mask.</p>
<pre class="literal-block">
struct incoming_request_alert final : peer_alert
{
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::incoming_request;
   peer_request req;
};
</pre>
<a name="req"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:incoming_request_alert%3A%3A%5Breq%5D&labels=documentation&body=Documentation+under+heading+%22incoming_request_alert%3A%3A%5Breq%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>req</dt>
<dd>the request this peer sent to us</dd>
</dl>
<a name="dht_log_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+dht_log_alert&labels=documentation&body=Documentation+under+heading+%22class+dht_log_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="dht-log-alert">
<h1>dht_log_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>debug logging of the DHT when alert_category::dht_log is set in the <a class="reference external" href="reference-Alerts.html#alert">alert</a>
mask.</p>
<pre class="literal-block">
struct dht_log_alert final : alert
{
   std::string <strong>message</strong> () const override;
   char const* <strong>log_message</strong> () const;

   enum dht_module_t
   {
      tracker,
      node,
      routing_table,
      rpc_manager,
      traversal,
   };

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::dht_log;
   dht_module_t module;
};
</pre>
<a name="log_message()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_log_alert%3A%3A%5Blog_message%28%29%5D&labels=documentation&body=Documentation+under+heading+%22dht_log_alert%3A%3A%5Blog_message%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="log-message-4">
<h2>log_message()</h2>
<pre class="literal-block">
char const* <strong>log_message</strong> () const;
</pre>
<p>the log message</p>
<a name="dht_module_t"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+dht_module_t&labels=documentation&body=Documentation+under+heading+%22enum+dht_module_t%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-dht-module-t">
<h2>enum dht_module_t</h2>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="43%" />
<col width="20%" />
<col width="37%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>tracker</td>
<td>0</td>
<td>&nbsp;</td>
</tr>
<tr><td>node</td>
<td>1</td>
<td>&nbsp;</td>
</tr>
<tr><td>routing_table</td>
<td>2</td>
<td>&nbsp;</td>
</tr>
<tr><td>rpc_manager</td>
<td>3</td>
<td>&nbsp;</td>
</tr>
<tr><td>traversal</td>
<td>4</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<a name="module"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_log_alert%3A%3A%5Bmodule%5D&labels=documentation&body=Documentation+under+heading+%22dht_log_alert%3A%3A%5Bmodule%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>module</dt>
<dd>the module, or part, of the DHT that produced this log message.</dd>
</dl>
<a name="dht_pkt_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+dht_pkt_alert&labels=documentation&body=Documentation+under+heading+%22class+dht_pkt_alert%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="dht-pkt-alert">
<h1>dht_pkt_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This <a class="reference external" href="reference-Alerts.html#alert">alert</a> is posted every time a DHT message is sent or received. It is
only posted if the <tt class="docutils literal"><span class="pre">alert_category::dht_log</span></tt> <a class="reference external" href="reference-Alerts.html#alert">alert</a> category is
enabled. It contains a verbatim copy of the message.</p>
<pre class="literal-block">
struct dht_pkt_alert final : alert
{
   std::string <strong>message</strong> () const override;
   span&lt;char const&gt; <strong>pkt_buf</strong> () const;

   enum direction_t
   {
      incoming,
      outgoing,
   };

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::dht_log;
   direction_t direction;
   aux::noexcept_movable&lt;udp::endpoint&gt; node;
};
</pre>
<a name="pkt_buf()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_pkt_alert%3A%3A%5Bpkt_buf%28%29%5D&labels=documentation&body=Documentation+under+heading+%22dht_pkt_alert%3A%3A%5Bpkt_buf%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="pkt-buf">
<h2>pkt_buf()</h2>
<pre class="literal-block">
span&lt;char const&gt; <strong>pkt_buf</strong> () const;
</pre>
<p>returns a pointer to the packet buffer and size of the packet,
respectively. This buffer is only valid for as long as the <a class="reference external" href="reference-Alerts.html#alert">alert</a> itself
is valid, which is owned by libtorrent and reclaimed whenever
<a class="reference external" href="reference-Session.html#pop_alerts()">pop_alerts()</a> is called on the <a class="reference external" href="reference-Session.html#session">session</a>.</p>
<a name="direction_t"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+direction_t&labels=documentation&body=Documentation+under+heading+%22enum+direction_t%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-direction-t-2">
<h2>enum direction_t</h2>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="23%" />
<col width="43%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>incoming</td>
<td>0</td>
<td>&nbsp;</td>
</tr>
<tr><td>outgoing</td>
<td>1</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<a name="direction"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_pkt_alert%3A%3A%5Bdirection%5D&labels=documentation&body=Documentation+under+heading+%22dht_pkt_alert%3A%3A%5Bdirection%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>direction</dt>
<dd>whether this is an incoming or outgoing packet.</dd>
</dl>
<a name="node"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_pkt_alert%3A%3A%5Bnode%5D&labels=documentation&body=Documentation+under+heading+%22dht_pkt_alert%3A%3A%5Bnode%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>node</dt>
<dd>the DHT node we received this packet from, or sent this packet to
(depending on <tt class="docutils literal">direction</tt>).</dd>
</dl>
<a name="dht_get_peers_reply_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+dht_get_peers_reply_alert&labels=documentation&body=Documentation+under+heading+%22class+dht_get_peers_reply_alert%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="dht-get-peers-reply-alert">
<h1>dht_get_peers_reply_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>Posted when we receive a response to a DHT get_peers request.</p>
<pre class="literal-block">
struct dht_get_peers_reply_alert final : alert
{
   std::string <strong>message</strong> () const override;
   int <strong>num_peers</strong> () const;
   std::vector&lt;<a class="reference external" href="tcp::endpoint">tcp::endpoint</a>&gt; <strong>peers</strong> () const;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::dht_operation;
   sha1_hash info_hash;
};
</pre>
<a name="dht_direct_response_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+dht_direct_response_alert&labels=documentation&body=Documentation+under+heading+%22class+dht_direct_response_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="dht-direct-response-alert">
<h1>dht_direct_response_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This is posted exactly once for every call to session_handle::dht_direct_request.
If the request failed, <a class="reference external" href="reference-Alerts.html#response()">response()</a> will return a default constructed <a class="reference external" href="reference-Bdecoding.html#bdecode_node">bdecode_node</a>.</p>
<pre class="literal-block">
struct dht_direct_response_alert final : alert
{
   std::string <strong>message</strong> () const override;
   bdecode_node <strong>response</strong> () const;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::dht;
   client_data_t userdata;
   aux::noexcept_movable&lt;udp::endpoint&gt; endpoint;
};
</pre>
<a name="picker_log_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+picker_log_alert&labels=documentation&body=Documentation+under+heading+%22class+picker_log_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="picker-log-alert">
<h1>picker_log_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>this is posted when one or more blocks are picked by the piece picker,
assuming the verbose piece picker logging is enabled (see
alert_category::picker_log).</p>
<pre class="literal-block">
struct picker_log_alert final : peer_alert
{
   std::string <strong>message</strong> () const override;
   std::vector&lt;piece_block&gt; <strong>blocks</strong> () const;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::picker_log;
   static constexpr picker_flags_t <strong>partial_ratio</strong>  = 0_bit;
   static constexpr picker_flags_t <strong>prioritize_partials</strong>  = 1_bit;
   static constexpr picker_flags_t <strong>rarest_first_partials</strong>  = 2_bit;
   static constexpr picker_flags_t <strong>rarest_first</strong>  = 3_bit;
   static constexpr picker_flags_t <strong>reverse_rarest_first</strong>  = 4_bit;
   static constexpr picker_flags_t <strong>suggested_pieces</strong>  = 5_bit;
   static constexpr picker_flags_t <strong>prio_sequential_pieces</strong>  = 6_bit;
   static constexpr picker_flags_t <strong>sequential_pieces</strong>  = 7_bit;
   static constexpr picker_flags_t <strong>reverse_pieces</strong>  = 8_bit;
   static constexpr picker_flags_t <strong>time_critical</strong>  = 9_bit;
   static constexpr picker_flags_t <strong>random_pieces</strong>  = 10_bit;
   static constexpr picker_flags_t <strong>prefer_contiguous</strong>  = 11_bit;
   static constexpr picker_flags_t <strong>reverse_sequential</strong>  = 12_bit;
   static constexpr picker_flags_t <strong>backup1</strong>  = 13_bit;
   static constexpr picker_flags_t <strong>backup2</strong>  = 14_bit;
   static constexpr picker_flags_t <strong>end_game</strong>  = 15_bit;
   static constexpr picker_flags_t <strong>extent_affinity</strong>  = 16_bit;
   picker_flags_t const picker_flags;
};
</pre>
<a name="picker_flags"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:picker_log_alert%3A%3A%5Bpicker_flags%5D&labels=documentation&body=Documentation+under+heading+%22picker_log_alert%3A%3A%5Bpicker_flags%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>picker_flags</dt>
<dd>this is a bitmask of which features were enabled for this particular
pick. The bits are defined in the picker_flags_t enum.</dd>
</dl>
<a name="session_error_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+session_error_alert&labels=documentation&body=Documentation+under+heading+%22class+session_error_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="session-error-alert">
<h1>session_error_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>this <a class="reference external" href="reference-Alerts.html#alert">alert</a> is posted when the <a class="reference external" href="reference-Session.html#session">session</a> encounters a serious error,
potentially fatal</p>
<pre class="literal-block">
struct session_error_alert final : alert
{
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::error;
   error_code const error;
};
</pre>
<a name="error"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session_error_alert%3A%3A%5Berror%5D&labels=documentation&body=Documentation+under+heading+%22session_error_alert%3A%3A%5Berror%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>error</dt>
<dd>The error code, if one is associated with this error</dd>
</dl>
<a name="dht_live_nodes_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+dht_live_nodes_alert&labels=documentation&body=Documentation+under+heading+%22class+dht_live_nodes_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="dht-live-nodes-alert">
<h1>dht_live_nodes_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>posted in response to a call to session::dht_live_nodes(). It contains the
live nodes from the DHT routing table of one of the DHT nodes running
locally.</p>
<pre class="literal-block">
struct dht_live_nodes_alert final : alert
{
   std::string <strong>message</strong> () const override;
   int <strong>num_nodes</strong> () const;
   std::vector&lt;std::pair&lt;sha1_hash, udp::endpoint&gt;&gt; <strong>nodes</strong> () const;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::dht;
   sha1_hash node_id;
};
</pre>
<a name="nodes()"></a>
<a name="num_nodes()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_live_nodes_alert%3A%3A%5Bnodes%28%29+num_nodes%28%29%5D&labels=documentation&body=Documentation+under+heading+%22dht_live_nodes_alert%3A%3A%5Bnodes%28%29+num_nodes%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="nodes-num-nodes">
<h2>nodes() num_nodes()</h2>
<pre class="literal-block">
int <strong>num_nodes</strong> () const;
std::vector&lt;std::pair&lt;sha1_hash, udp::endpoint&gt;&gt; <strong>nodes</strong> () const;
</pre>
<p>the number of nodes in the routing table and the actual nodes.</p>
<a name="node_id"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_live_nodes_alert%3A%3A%5Bnode_id%5D&labels=documentation&body=Documentation+under+heading+%22dht_live_nodes_alert%3A%3A%5Bnode_id%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>node_id</dt>
<dd>the local DHT node's node-ID this routing table belongs to</dd>
</dl>
<a name="session_stats_header_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+session_stats_header_alert&labels=documentation&body=Documentation+under+heading+%22class+session_stats_header_alert%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="session-stats-header-alert">
<h1>session_stats_header_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>The session_stats_header <a class="reference external" href="reference-Alerts.html#alert">alert</a> is posted the first time
<a class="reference external" href="reference-Session.html#post_session_stats()">post_session_stats()</a> is called</p>
<p>the <tt class="docutils literal">message()</tt> member function returns a string representation of the
header that properly match the stats values string returned in
<tt class="docutils literal"><span class="pre">session_stats_alert::message()</span></tt>.</p>
<p>this specific output is parsed by tools/parse_session_stats.py
if this is changed, that parser should also be changed</p>
<pre class="literal-block">
struct session_stats_header_alert final : alert
{
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = {};
};
</pre>
<a name="dht_sample_infohashes_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+dht_sample_infohashes_alert&labels=documentation&body=Documentation+under+heading+%22class+dht_sample_infohashes_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="dht-sample-infohashes-alert">
<h1>dht_sample_infohashes_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>posted as a response to a call to session::dht_sample_infohashes() with
the information from the DHT response message.</p>
<pre class="literal-block">
struct dht_sample_infohashes_alert final : alert
{
   std::string <strong>message</strong> () const override;
   std::vector&lt;sha1_hash&gt; <strong>samples</strong> () const;
   int <strong>num_samples</strong> () const;
   int <strong>num_nodes</strong> () const;
   std::vector&lt;std::pair&lt;sha1_hash, udp::endpoint&gt;&gt; <strong>nodes</strong> () const;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::dht_operation;
   sha1_hash node_id;
   aux::noexcept_movable&lt;udp::endpoint&gt; endpoint;
   time_duration const interval;
   int const num_infohashes;
};
</pre>
<a name="num_samples()"></a>
<a name="samples()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_sample_infohashes_alert%3A%3A%5Bnum_samples%28%29+samples%28%29%5D&labels=documentation&body=Documentation+under+heading+%22dht_sample_infohashes_alert%3A%3A%5Bnum_samples%28%29+samples%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="num-samples-samples">
<h2>num_samples() samples()</h2>
<pre class="literal-block">
std::vector&lt;sha1_hash&gt; <strong>samples</strong> () const;
int <strong>num_samples</strong> () const;
</pre>
<p>returns the number of info-hashes returned by the node, as well as the
actual info-hashes. <tt class="docutils literal">num_samples()</tt> is more efficient than
<tt class="docutils literal"><span class="pre">samples().size()</span></tt>.</p>
<a name="num_nodes()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_sample_infohashes_alert%3A%3A%5Bnum_nodes%28%29%5D&labels=documentation&body=Documentation+under+heading+%22dht_sample_infohashes_alert%3A%3A%5Bnum_nodes%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="num-nodes">
<h2>num_nodes()</h2>
<pre class="literal-block">
int <strong>num_nodes</strong> () const;
</pre>
<p>The total number of nodes returned by <tt class="docutils literal">nodes()</tt>.</p>
<a name="nodes()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_sample_infohashes_alert%3A%3A%5Bnodes%28%29%5D&labels=documentation&body=Documentation+under+heading+%22dht_sample_infohashes_alert%3A%3A%5Bnodes%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="nodes">
<h2>nodes()</h2>
<pre class="literal-block">
std::vector&lt;std::pair&lt;sha1_hash, udp::endpoint&gt;&gt; <strong>nodes</strong> () const;
</pre>
<p>This is the set of more DHT nodes returned by the request.</p>
<p>The information is included so that indexing nodes can perform a key
space traversal with a single RPC per node by adjusting the target
value for each RPC.</p>
<a name="node_id"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_sample_infohashes_alert%3A%3A%5Bnode_id%5D&labels=documentation&body=Documentation+under+heading+%22dht_sample_infohashes_alert%3A%3A%5Bnode_id%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>node_id</dt>
<dd>id of the node the request was sent to (and this response was received from)</dd>
</dl>
<a name="endpoint"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_sample_infohashes_alert%3A%3A%5Bendpoint%5D&labels=documentation&body=Documentation+under+heading+%22dht_sample_infohashes_alert%3A%3A%5Bendpoint%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>endpoint</dt>
<dd>the node the request was sent to (and this response was received from)</dd>
</dl>
<a name="interval"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_sample_infohashes_alert%3A%3A%5Binterval%5D&labels=documentation&body=Documentation+under+heading+%22dht_sample_infohashes_alert%3A%3A%5Binterval%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>interval</dt>
<dd>the interval to wait before making another request to this node</dd>
</dl>
<a name="num_infohashes"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_sample_infohashes_alert%3A%3A%5Bnum_infohashes%5D&labels=documentation&body=Documentation+under+heading+%22dht_sample_infohashes_alert%3A%3A%5Bnum_infohashes%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>num_infohashes</dt>
<dd>This field indicates how many info-hash keys are currently in the node's storage.
If the value is larger than the number of returned samples it indicates that the
indexer may obtain additional samples after waiting out the interval.</dd>
</dl>
<a name="block_uploaded_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+block_uploaded_alert&labels=documentation&body=Documentation+under+heading+%22class+block_uploaded_alert%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="block-uploaded-alert">
<h1>block_uploaded_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>This <a class="reference external" href="reference-Alerts.html#alert">alert</a> is posted when a block intended to be sent to a peer is placed in the
send buffer. Note that if the connection is closed before the send buffer is sent,
the <a class="reference external" href="reference-Alerts.html#alert">alert</a> may be posted without the bytes having been sent to the peer.
It belongs to the <tt class="docutils literal"><span class="pre">alert_category::upload</span></tt> category.</p>
<pre class="literal-block">
struct block_uploaded_alert final : peer_alert
{
   std::string <strong>message</strong> () const override;

   int const block_index;
   piece_index_t const piece_index;
};
</pre>
<a name="alerts_dropped_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+alerts_dropped_alert&labels=documentation&body=Documentation+under+heading+%22class+alerts_dropped_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="alerts-dropped-alert">
<h1>alerts_dropped_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>this <a class="reference external" href="reference-Alerts.html#alert">alert</a> is posted to indicate to the client that some alerts were
dropped. Dropped meaning that the <a class="reference external" href="reference-Alerts.html#alert">alert</a> failed to be delivered to the
client. The most common cause of such failure is that the internal <a class="reference external" href="reference-Alerts.html#alert">alert</a>
queue grew too big (controlled by alert_queue_size).</p>
<pre class="literal-block">
struct alerts_dropped_alert final : alert
{
   <strong>static_assert</strong> (num_alert_types &lt;= abi_alert_count, &quot;need to increase bitset. This is an ABI break&quot;);
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::error;
   std::bitset&lt;abi_alert_count&gt; dropped_alerts;
};
</pre>
<a name="dropped_alerts"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:alerts_dropped_alert%3A%3A%5Bdropped_alerts%5D&labels=documentation&body=Documentation+under+heading+%22alerts_dropped_alert%3A%3A%5Bdropped_alerts%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>dropped_alerts</dt>
<dd>a bitmask indicating which alerts were dropped. Each bit represents the
<a class="reference external" href="reference-Alerts.html#alert">alert</a> type ID, where bit 0 represents whether any <a class="reference external" href="reference-Alerts.html#alert">alert</a> of type 0 has
been dropped, and so on.</dd>
</dl>
<a name="socks5_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+socks5_alert&labels=documentation&body=Documentation+under+heading+%22class+socks5_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="socks5-alert">
<h1>socks5_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>this <a class="reference external" href="reference-Alerts.html#alert">alert</a> is posted with SOCKS5 related errors, when a SOCKS5 proxy is
configured. It's enabled with the alert_category::error <a class="reference external" href="reference-Alerts.html#alert">alert</a> category.</p>
<pre class="literal-block">
struct socks5_alert final : alert
{
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::error;
   error_code error;
   operation_t op;
   aux::noexcept_movable&lt;<a class="reference external" href="tcp::endpoint">tcp::endpoint</a>&gt; ip;
};
</pre>
<a name="error"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:socks5_alert%3A%3A%5Berror%5D&labels=documentation&body=Documentation+under+heading+%22socks5_alert%3A%3A%5Berror%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>error</dt>
<dd>the error</dd>
</dl>
<a name="op"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:socks5_alert%3A%3A%5Bop%5D&labels=documentation&body=Documentation+under+heading+%22socks5_alert%3A%3A%5Bop%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>op</dt>
<dd>the operation that failed</dd>
</dl>
<a name="ip"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:socks5_alert%3A%3A%5Bip%5D&labels=documentation&body=Documentation+under+heading+%22socks5_alert%3A%3A%5Bip%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>ip</dt>
<dd>the endpoint configured as the proxy</dd>
</dl>
<a name="file_prio_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+file_prio_alert&labels=documentation&body=Documentation+under+heading+%22class+file_prio_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="file-prio-alert">
<h1>file_prio_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>posted when a <a class="reference external" href="reference-Torrent_Handle.html#prioritize_files()">prioritize_files()</a> or <a class="reference external" href="reference-Torrent_Handle.html#file_priority()">file_priority()</a> update of the file
priorities complete, which requires a round-trip to the disk thread.</p>
<p>If the disk operation fails this <a class="reference external" href="reference-Alerts.html#alert">alert</a> won't be posted, but a
<a class="reference external" href="reference-Alerts.html#file_error_alert">file_error_alert</a> is posted instead, and the torrent is stopped.</p>
<pre class="literal-block">
struct file_prio_alert final : torrent_alert
{
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::storage;
   error_code error;
   operation_t op;
};
</pre>
<a name="error"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:file_prio_alert%3A%3A%5Berror%5D&labels=documentation&body=Documentation+under+heading+%22file_prio_alert%3A%3A%5Berror%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>error</dt>
<dd>the error</dd>
</dl>
<a name="op"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:file_prio_alert%3A%3A%5Bop%5D&labels=documentation&body=Documentation+under+heading+%22file_prio_alert%3A%3A%5Bop%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>op</dt>
<dd>the operation that failed</dd>
</dl>
<a name="oversized_file_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+oversized_file_alert&labels=documentation&body=Documentation+under+heading+%22class+oversized_file_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="oversized-file-alert">
<h1>oversized_file_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>this <a class="reference external" href="reference-Alerts.html#alert">alert</a> may be posted when the initial checking of resume data and files
on disk (just existence, not piece hashes) completes. If a file belonging
to the torrent is found on disk, but is larger than the file in the
torrent, that's when this <a class="reference external" href="reference-Alerts.html#alert">alert</a> is posted.
the client may want to call <a class="reference external" href="reference-Core.html#truncate_files()">truncate_files()</a> in that case, or perhaps
interpret it as a sign that some other file is in the way, that shouldn't
be overwritten.</p>
<pre class="literal-block">
struct oversized_file_alert final : torrent_alert
{
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::storage;
};
</pre>
<a name="torrent_conflict_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+torrent_conflict_alert&labels=documentation&body=Documentation+under+heading+%22class+torrent_conflict_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="torrent-conflict-alert">
<h1>torrent_conflict_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>this <a class="reference external" href="reference-Alerts.html#alert">alert</a> is posted when two separate torrents (magnet links) resolve to
the same torrent, thus causing the same torrent being added twice. In
that case, both torrents enter an error state with <tt class="docutils literal">duplicate_torrent</tt>
as the error code. This <a class="reference external" href="reference-Alerts.html#alert">alert</a> is posted containing the metadata. For more
information, see <a class="reference external" href="manual-ref.html#bittorrent-v2-torrents">BitTorrent v2 torrents</a>.
The torrent this <a class="reference external" href="reference-Alerts.html#alert">alert</a> originated from was the one that downloaded the</p>
<p>metadata (i.e. the <cite>handle</cite> member from the <a class="reference external" href="reference-Alerts.html#torrent_alert">torrent_alert</a> base class).</p>
<pre class="literal-block">
struct torrent_conflict_alert final : torrent_alert
{
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::error;
   torrent_handle conflicting_torrent;
   std::shared_ptr&lt;torrent_info&gt; metadata;
};
</pre>
<a name="conflicting_torrent"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_conflict_alert%3A%3A%5Bconflicting_torrent%5D&labels=documentation&body=Documentation+under+heading+%22torrent_conflict_alert%3A%3A%5Bconflicting_torrent%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>conflicting_torrent</dt>
<dd>the handle to the torrent in conflict. The swarm associated with this
torrent handle did not download the metadata, but the downloaded
metadata collided with this swarm's info-hash.</dd>
</dl>
<a name="metadata"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_conflict_alert%3A%3A%5Bmetadata%5D&labels=documentation&body=Documentation+under+heading+%22torrent_conflict_alert%3A%3A%5Bmetadata%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>metadata</dt>
<dd>the metadata that was received by one of the torrents in conflict.
One way to resolve the conflict is to remove both failing torrents
and re-add it using this metadata</dd>
</dl>
<a name="peer_info_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+peer_info_alert&labels=documentation&body=Documentation+under+heading+%22class+peer_info_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="peer-info-alert">
<h1>peer_info_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>posted when <a class="reference external" href="reference-Torrent_Handle.html#post_peer_info()">torrent_handle::post_peer_info()</a> is called</p>
<pre class="literal-block">
struct peer_info_alert final : torrent_alert
{
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::status;
   std::vector&lt;lt::peer_info&gt; peer_info;
};
</pre>
<a name="peer_info"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info_alert%3A%3A%5Bpeer_info%5D&labels=documentation&body=Documentation+under+heading+%22peer_info_alert%3A%3A%5Bpeer_info%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>peer_info</dt>
<dd>the list of the currently connected peers</dd>
</dl>
<a name="file_progress_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+file_progress_alert&labels=documentation&body=Documentation+under+heading+%22class+file_progress_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="file-progress-alert">
<h1>file_progress_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>posted when <a class="reference external" href="reference-Torrent_Handle.html#post_file_progress()">torrent_handle::post_file_progress()</a> is called</p>
<pre class="literal-block">
struct file_progress_alert final : torrent_alert
{
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::file_progress;
   aux::vector&lt;std::int64_t, file_index_t&gt; files;
};
</pre>
<a name="files"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:file_progress_alert%3A%3A%5Bfiles%5D&labels=documentation&body=Documentation+under+heading+%22file_progress_alert%3A%3A%5Bfiles%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>files</dt>
<dd>the list of the files in the torrent</dd>
</dl>
<a name="piece_info_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+piece_info_alert&labels=documentation&body=Documentation+under+heading+%22class+piece_info_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="piece-info-alert">
<h1>piece_info_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>posted when <a class="reference external" href="reference-Torrent_Handle.html#post_download_queue()">torrent_handle::post_download_queue()</a> is called</p>
<pre class="literal-block">
struct piece_info_alert final : torrent_alert
{
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::piece_progress;
   std::vector&lt;partial_piece_info&gt; piece_info;
   std::vector&lt;block_info&gt; block_data;
};
</pre>
<a name="piece_info"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:piece_info_alert%3A%3A%5Bpiece_info%5D&labels=documentation&body=Documentation+under+heading+%22piece_info_alert%3A%3A%5Bpiece_info%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>piece_info</dt>
<dd>info about pieces being downloaded for the torrent</dd>
</dl>
<a name="block_data"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:piece_info_alert%3A%3A%5Bblock_data%5D&labels=documentation&body=Documentation+under+heading+%22piece_info_alert%3A%3A%5Bblock_data%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>block_data</dt>
<dd>storage for <a class="reference external" href="reference-Torrent_Handle.html#block_info">block_info</a> pointers in <a class="reference external" href="reference-Torrent_Handle.html#partial_piece_info">partial_piece_info</a> objects</dd>
</dl>
<a name="piece_availability_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+piece_availability_alert&labels=documentation&body=Documentation+under+heading+%22class+piece_availability_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="piece-availability-alert">
<h1>piece_availability_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>posted when <a class="reference external" href="reference-Torrent_Handle.html#post_piece_availability()">torrent_handle::post_piece_availability()</a> is called</p>
<pre class="literal-block">
struct piece_availability_alert final : torrent_alert
{
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::status;
   std::vector&lt;int&gt; piece_availability;
};
</pre>
<a name="piece_availability"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:piece_availability_alert%3A%3A%5Bpiece_availability%5D&labels=documentation&body=Documentation+under+heading+%22piece_availability_alert%3A%3A%5Bpiece_availability%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>piece_availability</dt>
<dd>info about pieces being downloaded for the torrent</dd>
</dl>
<a name="tracker_list_alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+tracker_list_alert&labels=documentation&body=Documentation+under+heading+%22class+tracker_list_alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="tracker-list-alert">
<h1>tracker_list_alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<p>posted when <a class="reference external" href="reference-Torrent_Handle.html#post_trackers()">torrent_handle::post_trackers()</a> is called</p>
<pre class="literal-block">
struct tracker_list_alert final : torrent_alert
{
   std::string <strong>message</strong> () const override;

   static constexpr alert_category_t <strong>static_category</strong>  = alert_category::status;
   std::vector&lt;announce_entry&gt; trackers;
};
</pre>
<a name="trackers"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:tracker_list_alert%3A%3A%5Btrackers%5D&labels=documentation&body=Documentation+under+heading+%22tracker_list_alert%3A%3A%5Btrackers%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>trackers</dt>
<dd>list of trackers and their status for the torrent</dd>
</dl>
<a name="alert"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+alert&labels=documentation&body=Documentation+under+heading+%22class+alert%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="alert">
<h1>alert</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert.hpp">libtorrent/alert.hpp</a>&quot;</p>
<p>The <tt class="docutils literal">alert</tt> class is the base class that specific messages are derived from.
<a class="reference external" href="reference-Alerts.html#alert">alert</a> types are not copyable, and cannot be constructed by the client. The
pointers returned by libtorrent are short lived (the details are described
under <a class="reference external" href="reference-Session.html#pop_alerts()">session_handle::pop_alerts()</a>)</p>
<pre class="literal-block">
struct alert
{
   time_point <strong>timestamp</strong> () const;
   virtual int <strong>type</strong> () const noexcept = 0;
   virtual char const* <strong>what</strong> () const noexcept = 0;
   virtual std::string <strong>message</strong> () const = 0;
   virtual alert_category_t <strong>category</strong> () const noexcept = 0;

   static constexpr alert_category_t <strong>error_notification</strong>  = 0_bit;
   static constexpr alert_category_t <strong>peer_notification</strong>  = 1_bit;
   static constexpr alert_category_t <strong>port_mapping_notification</strong>  = 2_bit;
   static constexpr alert_category_t <strong>storage_notification</strong>  = 3_bit;
   static constexpr alert_category_t <strong>tracker_notification</strong>  = 4_bit;
   static constexpr alert_category_t <strong>connect_notification</strong>  = 5_bit;
   static constexpr alert_category_t <strong>status_notification</strong>  = 6_bit;
   static constexpr alert_category_t <strong>ip_block_notification</strong>  = 8_bit;
   static constexpr alert_category_t <strong>performance_warning</strong>  = 9_bit;
   static constexpr alert_category_t <strong>dht_notification</strong>  = 10_bit;
   static constexpr alert_category_t <strong>session_log_notification</strong>  = 13_bit;
   static constexpr alert_category_t <strong>torrent_log_notification</strong>  = 14_bit;
   static constexpr alert_category_t <strong>peer_log_notification</strong>  = 15_bit;
   static constexpr alert_category_t <strong>incoming_request_notification</strong>  = 16_bit;
   static constexpr alert_category_t <strong>dht_log_notification</strong>  = 17_bit;
   static constexpr alert_category_t <strong>dht_operation_notification</strong>  = 18_bit;
   static constexpr alert_category_t <strong>port_mapping_log_notification</strong>  = 19_bit;
   static constexpr alert_category_t <strong>picker_log_notification</strong>  = 20_bit;
   static constexpr alert_category_t <strong>file_progress_notification</strong>  = 21_bit;
   static constexpr alert_category_t <strong>piece_progress_notification</strong>  = 22_bit;
   static constexpr alert_category_t <strong>upload_notification</strong>  = 23_bit;
   static constexpr alert_category_t <strong>block_progress_notification</strong>  = 24_bit;
   static constexpr alert_category_t <strong>all_categories</strong>  = alert_category_t::all();
};
</pre>
<a name="timestamp()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:alert%3A%3A%5Btimestamp%28%29%5D&labels=documentation&body=Documentation+under+heading+%22alert%3A%3A%5Btimestamp%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="timestamp">
<h2>timestamp()</h2>
<pre class="literal-block">
time_point <strong>timestamp</strong> () const;
</pre>
<p>a timestamp is automatically created in the constructor</p>
<a name="type()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:alert%3A%3A%5Btype%28%29%5D&labels=documentation&body=Documentation+under+heading+%22alert%3A%3A%5Btype%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="type">
<h2>type()</h2>
<pre class="literal-block">
virtual int <strong>type</strong> () const noexcept = 0;
</pre>
<p>returns an integer that is unique to this <a class="reference external" href="reference-Alerts.html#alert">alert</a> type. It can be
compared against a specific <a class="reference external" href="reference-Alerts.html#alert">alert</a> by querying a static constant called <tt class="docutils literal">alert_type</tt>
in the <a class="reference external" href="reference-Alerts.html#alert">alert</a>. It can be used to determine the run-time type of an alert* in
order to cast to that <a class="reference external" href="reference-Alerts.html#alert">alert</a> type and access specific members.</p>
<p>e.g:</p>
<pre class="code c++ literal-block">
<span class="name">std</span><span class="operator">::</span><span class="name">vector</span><span class="operator">&lt;</span><span class="name">alert</span><span class="operator">*&gt;</span><span class="whitespace"> </span><span class="name">alerts</span><span class="punctuation">;</span><span class="whitespace">
</span><span class="name">ses</span><span class="punctuation">.</span><span class="name">pop_alerts</span><span class="punctuation">(</span><span class="operator">&amp;</span><span class="name">alerts</span><span class="punctuation">);</span><span class="whitespace">
</span><span class="keyword">for</span><span class="whitespace"> </span><span class="punctuation">(</span><span class="name">alert</span><span class="operator">*</span><span class="whitespace"> </span><span class="name">a</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="name">alerts</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="punctuation">{</span><span class="whitespace">
        </span><span class="keyword">switch</span><span class="whitespace"> </span><span class="punctuation">(</span><span class="name">a</span><span class="operator">-&gt;</span><span class="name">type</span><span class="punctuation">())</span><span class="whitespace"> </span><span class="punctuation">{</span><span class="whitespace">

                </span><span class="keyword">case</span><span class="whitespace"> </span><span class="name constant">read_piece_alert</span><span class="operator">::</span><span class="name constant">alert_type</span><span class="punctuation">:</span><span class="whitespace">
                </span><span class="punctuation">{</span><span class="whitespace">
                        </span><span class="keyword">auto</span><span class="operator">*</span><span class="whitespace"> </span><span class="name">p</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="keyword">static_cast</span><span class="operator">&lt;</span><span class="name">read_piece_alert</span><span class="operator">*&gt;</span><span class="punctuation">(</span><span class="name">a</span><span class="punctuation">);</span><span class="whitespace">
                        </span><span class="keyword">if</span><span class="whitespace"> </span><span class="punctuation">(</span><span class="name">p</span><span class="operator">-&gt;</span><span class="name">ec</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="punctuation">{</span><span class="whitespace">
                                </span><span class="comment single">// read_piece failed
</span><span class="whitespace">                                </span><span class="keyword">break</span><span class="punctuation">;</span><span class="whitespace">
                        </span><span class="punctuation">}</span><span class="whitespace">
                        </span><span class="comment single">// use p
</span><span class="whitespace">                        </span><span class="keyword">break</span><span class="punctuation">;</span><span class="whitespace">
                </span><span class="punctuation">}</span><span class="whitespace">
                </span><span class="keyword">case</span><span class="whitespace"> </span><span class="name constant">file_renamed_alert</span><span class="operator">::</span><span class="name constant">alert_type</span><span class="punctuation">:</span><span class="whitespace">
                </span><span class="punctuation">{</span><span class="whitespace">
                        </span><span class="comment single">// etc...
</span><span class="whitespace">                </span><span class="punctuation">}</span><span class="whitespace">
        </span><span class="punctuation">}</span><span class="whitespace">
</span><span class="punctuation">}</span>
</pre>
<a name="what()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:alert%3A%3A%5Bwhat%28%29%5D&labels=documentation&body=Documentation+under+heading+%22alert%3A%3A%5Bwhat%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="what">
<h2>what()</h2>
<pre class="literal-block">
virtual char const* <strong>what</strong> () const noexcept = 0;
</pre>
<p>returns a string literal describing the type of the <a class="reference external" href="reference-Alerts.html#alert">alert</a>. It does
not include any information that might be bundled with the <a class="reference external" href="reference-Alerts.html#alert">alert</a>.</p>
<a name="message()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:alert%3A%3A%5Bmessage%28%29%5D&labels=documentation&body=Documentation+under+heading+%22alert%3A%3A%5Bmessage%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="message-1">
<h2>message()</h2>
<pre class="literal-block">
virtual std::string <strong>message</strong> () const = 0;
</pre>
<p>generate a string describing the <a class="reference external" href="reference-Alerts.html#alert">alert</a> and the information bundled
with it. This is mainly intended for debug and development use. It is not suitable
to use this for applications that may be localized. Instead, handle each <a class="reference external" href="reference-Alerts.html#alert">alert</a>
type individually and extract and render the information from the <a class="reference external" href="reference-Alerts.html#alert">alert</a> depending
on the locale.</p>
<a name="category()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:alert%3A%3A%5Bcategory%28%29%5D&labels=documentation&body=Documentation+under+heading+%22alert%3A%3A%5Bcategory%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="category">
<h2>category()</h2>
<pre class="literal-block">
virtual alert_category_t <strong>category</strong> () const noexcept = 0;
</pre>
<p>returns a bitmask specifying which categories this <a class="reference external" href="reference-Alerts.html#alert">alert</a> belong to.</p>
<a name="alert_cast()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:alert_cast%28%29&labels=documentation&body=Documentation+under+heading+%22alert_cast%28%29%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="alert-cast">
<h1>alert_cast()</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert.hpp">libtorrent/alert.hpp</a>&quot;</p>
<pre class="literal-block">
template &lt;typename T&gt; T const* <strong>alert_cast</strong> (alert const* a);
template &lt;typename T&gt; T* <strong>alert_cast</strong> (alert* a);
</pre>
<p>When you get an <a class="reference external" href="reference-Alerts.html#alert">alert</a>, you can use <tt class="docutils literal">alert_cast&lt;&gt;</tt> to attempt to cast the
pointer to a specific <a class="reference external" href="reference-Alerts.html#alert">alert</a> type, in order to query it for more
information.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><tt class="docutils literal">alert_cast&lt;&gt;</tt> can only cast to an exact <a class="reference external" href="reference-Alerts.html#alert">alert</a> type, not a base class</p>
</div>
<a name="operation_name()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:operation_name%28%29&labels=documentation&body=Documentation+under+heading+%22operation_name%28%29%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="operation-name">
<h1>operation_name()</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/operations.hpp">libtorrent/operations.hpp</a>&quot;</p>
<pre class="literal-block">
char const* <strong>operation_name</strong> (operation_t op);
</pre>
<p>maps an operation id (from <a class="reference external" href="reference-Alerts.html#peer_error_alert">peer_error_alert</a> and <a class="reference external" href="reference-Alerts.html#peer_disconnected_alert">peer_disconnected_alert</a>)
to its name. See <a class="reference external" href="reference-Alerts.html#operation_t">operation_t</a> for the constants</p>
<a name="operation_t"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+operation_t&labels=documentation&body=Documentation+under+heading+%22enum+operation_t%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-operation-t">
<h1>enum operation_t</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/operations.hpp">libtorrent/operations.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="7%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>unknown</td>
<td>0</td>
<td>the error was unexpected and it is unknown which operation caused it</td>
</tr>
<tr><td>bittorrent</td>
<td>1</td>
<td>this is used when the bittorrent logic
determines to disconnect</td>
</tr>
<tr><td>iocontrol</td>
<td>2</td>
<td>a call to iocontrol failed</td>
</tr>
<tr><td>getpeername</td>
<td>3</td>
<td>a call to <tt class="docutils literal">getpeername()</tt> failed (querying the remote IP of a
connection)</td>
</tr>
<tr><td>getname</td>
<td>4</td>
<td>a call to getname failed (querying the local IP of a
connection)</td>
</tr>
<tr><td>alloc_recvbuf</td>
<td>5</td>
<td>an attempt to allocate a receive buffer failed</td>
</tr>
<tr><td>alloc_sndbuf</td>
<td>6</td>
<td>an attempt to allocate a send buffer failed</td>
</tr>
<tr><td>file_write</td>
<td>7</td>
<td>writing to a file failed</td>
</tr>
<tr><td>file_read</td>
<td>8</td>
<td>reading from a file failed</td>
</tr>
<tr><td>file</td>
<td>9</td>
<td>a non-read and non-write file operation failed</td>
</tr>
<tr><td>sock_write</td>
<td>10</td>
<td>a socket write operation failed</td>
</tr>
<tr><td>sock_read</td>
<td>11</td>
<td>a socket read operation failed</td>
</tr>
<tr><td>sock_open</td>
<td>12</td>
<td>a call to open(), to create a socket socket failed</td>
</tr>
<tr><td>sock_bind</td>
<td>13</td>
<td>a call to bind() on a socket failed</td>
</tr>
<tr><td>available</td>
<td>14</td>
<td>an attempt to query the number of bytes available to read from a socket
failed</td>
</tr>
<tr><td>encryption</td>
<td>15</td>
<td>a call related to bittorrent protocol encryption failed</td>
</tr>
<tr><td>connect</td>
<td>16</td>
<td>an attempt to connect a socket failed</td>
</tr>
<tr><td>ssl_handshake</td>
<td>17</td>
<td>establishing an SSL connection failed</td>
</tr>
<tr><td>get_interface</td>
<td>18</td>
<td>a connection failed to satisfy the bind interface setting</td>
</tr>
<tr><td>sock_listen</td>
<td>19</td>
<td>a call to listen() on a socket</td>
</tr>
<tr><td>sock_bind_to_device</td>
<td>20</td>
<td>a call to the ioctl to bind a socket to a specific network device or
adapter</td>
</tr>
<tr><td>sock_accept</td>
<td>21</td>
<td>a call to accept() on a socket</td>
</tr>
<tr><td>parse_address</td>
<td>22</td>
<td>convert a string into a valid network address</td>
</tr>
<tr><td>enum_if</td>
<td>23</td>
<td>enumeration network devices or adapters</td>
</tr>
<tr><td>file_stat</td>
<td>24</td>
<td>invoking stat() on a file</td>
</tr>
<tr><td>file_copy</td>
<td>25</td>
<td>copying a file</td>
</tr>
<tr><td>file_fallocate</td>
<td>26</td>
<td>allocating storage for a file</td>
</tr>
<tr><td>file_hard_link</td>
<td>27</td>
<td>creating a hard link</td>
</tr>
<tr><td>file_remove</td>
<td>28</td>
<td>removing a file</td>
</tr>
<tr><td>file_rename</td>
<td>29</td>
<td>renaming a file</td>
</tr>
<tr><td>file_open</td>
<td>30</td>
<td>opening a file</td>
</tr>
<tr><td>mkdir</td>
<td>31</td>
<td>creating a directory</td>
</tr>
<tr><td>check_resume</td>
<td>32</td>
<td>check fast resume data against files on disk</td>
</tr>
<tr><td>exception</td>
<td>33</td>
<td>an unknown exception</td>
</tr>
<tr><td>alloc_cache_piece</td>
<td>34</td>
<td>allocate space for a piece in the cache</td>
</tr>
<tr><td>partfile_move</td>
<td>35</td>
<td>move a part-file</td>
</tr>
<tr><td>partfile_read</td>
<td>36</td>
<td>read from a part file</td>
</tr>
<tr><td>partfile_write</td>
<td>37</td>
<td>write to a part-file</td>
</tr>
<tr><td>hostname_lookup</td>
<td>38</td>
<td>a hostname lookup</td>
</tr>
<tr><td>symlink</td>
<td>39</td>
<td>create or read a symlink</td>
</tr>
<tr><td>handshake</td>
<td>40</td>
<td>handshake with a peer or server</td>
</tr>
<tr><td>sock_option</td>
<td>41</td>
<td>set socket option</td>
</tr>
<tr><td>enum_route</td>
<td>42</td>
<td>enumeration of network routes</td>
</tr>
<tr><td>file_seek</td>
<td>43</td>
<td>moving read/write position in a file, <a class="reference external" href="reference-Alerts.html#hostname_lookup">operation_t::hostname_lookup</a></td>
</tr>
<tr><td>timer</td>
<td>44</td>
<td>an async wait operation on a timer</td>
</tr>
<tr><td>file_mmap</td>
<td>45</td>
<td>call to mmap() (or windows counterpart)</td>
</tr>
<tr><td>file_truncate</td>
<td>46</td>
<td>call to ftruncate() (or SetEndOfFile() on windows)</td>
</tr>
</tbody>
</table>
<a name="int"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:int&labels=documentation&body=Documentation+under+heading+%22int%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="int">
<h1>int</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert_types.hpp">libtorrent/alert_types.hpp</a>&quot;</p>
<a name="int::user_alert_id"></a><dl class="docutils">
<dt>user_alert_id</dt>
<dd>user defined alerts should use IDs greater than this</dd>
</dl>
<a name="int::num_alert_types"></a><dl class="docutils">
<dt>num_alert_types</dt>
<dd>this constant represents &quot;max_alert_index&quot; + 1</dd>
</dl>
<a name="alert_category_t"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:alert_category_t&labels=documentation&body=Documentation+under+heading+%22alert_category_t%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="alert-category-t">
<h1>alert_category_t</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/alert.hpp">libtorrent/alert.hpp</a>&quot;</p>
<a name="alert_category_t::error"></a><dl class="docutils">
<dt>error</dt>
<dd><p class="first">Enables alerts that report an error. This includes:</p>
<ul class="last simple">
<li>tracker errors</li>
<li>tracker warnings</li>
<li>file errors</li>
<li>resume data failures</li>
<li>web seed errors</li>
<li>.torrent files errors</li>
<li>listen socket errors</li>
<li>port mapping errors</li>
</ul>
</dd>
</dl>
<a name="alert_category_t::peer"></a><dl class="docutils">
<dt>peer</dt>
<dd>Enables alerts when peers send invalid requests, get banned or
snubbed.</dd>
</dl>
<a name="alert_category_t::port_mapping"></a><dl class="docutils">
<dt>port_mapping</dt>
<dd>Enables alerts for port mapping events. For NAT-PMP and UPnP.</dd>
</dl>
<a name="alert_category_t::storage"></a><dl class="docutils">
<dt>storage</dt>
<dd>Enables alerts for events related to the storage. File errors and
synchronization events for moving the storage, renaming files etc.</dd>
</dl>
<a name="alert_category_t::tracker"></a><dl class="docutils">
<dt>tracker</dt>
<dd>Enables all tracker events. Includes announcing to trackers,
receiving responses, warnings and errors.</dd>
</dl>
<a name="alert_category_t::connect"></a><dl class="docutils">
<dt>connect</dt>
<dd>Low level alerts for when peers are connected and disconnected.</dd>
</dl>
<a name="alert_category_t::status"></a><dl class="docutils">
<dt>status</dt>
<dd>Enables alerts for when a torrent or the <a class="reference external" href="reference-Session.html#session">session</a> changes state.</dd>
</dl>
<a name="alert_category_t::ip_block"></a><dl class="docutils">
<dt>ip_block</dt>
<dd>Alerts when a peer is blocked by the ip blocker or port blocker.</dd>
</dl>
<a name="alert_category_t::performance_warning"></a><dl class="docutils">
<dt>performance_warning</dt>
<dd>Alerts when some limit is reached that might limit the download
or upload rate.</dd>
</dl>
<a name="alert_category_t::dht"></a><dl class="docutils">
<dt>dht</dt>
<dd>Alerts on events in the DHT node. For incoming searches or
bootstrapping being done etc.</dd>
</dl>
<a name="alert_category_t::stats"></a><dl class="docutils">
<dt>stats</dt>
<dd>If you enable these alerts, you will receive a stats_alert
approximately once every second, for every active torrent.
These alerts contain all statistics <a class="reference external" href="reference-Stats.html#counters">counters</a> for the interval since
the lasts stats <a class="reference external" href="reference-Alerts.html#alert">alert</a>.</dd>
</dl>
<a name="alert_category_t::session_log"></a><dl class="docutils">
<dt>session_log</dt>
<dd>Enables debug logging alerts. These are available unless libtorrent
was built with logging disabled (<tt class="docutils literal">TORRENT_DISABLE_LOGGING</tt>). The
alerts being posted are <a class="reference external" href="reference-Alerts.html#log_alert">log_alert</a> and are <a class="reference external" href="reference-Session.html#session">session</a> wide.</dd>
</dl>
<a name="alert_category_t::torrent_log"></a><dl class="docutils">
<dt>torrent_log</dt>
<dd>Enables debug logging alerts for torrents. These are available
unless libtorrent was built with logging disabled
(<tt class="docutils literal">TORRENT_DISABLE_LOGGING</tt>). The alerts being posted are
<a class="reference external" href="reference-Alerts.html#torrent_log_alert">torrent_log_alert</a> and are torrent wide debug events.</dd>
</dl>
<a name="alert_category_t::peer_log"></a><dl class="docutils">
<dt>peer_log</dt>
<dd>Enables debug logging alerts for peers. These are available unless
libtorrent was built with logging disabled
(<tt class="docutils literal">TORRENT_DISABLE_LOGGING</tt>). The alerts being posted are
<a class="reference external" href="reference-Alerts.html#peer_log_alert">peer_log_alert</a> and low-level peer events and messages.</dd>
</dl>
<a name="alert_category_t::incoming_request"></a><dl class="docutils">
<dt>incoming_request</dt>
<dd>enables the <a class="reference external" href="reference-Alerts.html#incoming_request_alert">incoming_request_alert</a>.</dd>
</dl>
<a name="alert_category_t::dht_log"></a><dl class="docutils">
<dt>dht_log</dt>
<dd>enables <a class="reference external" href="reference-Alerts.html#dht_log_alert">dht_log_alert</a>, debug logging for the DHT</dd>
</dl>
<a name="alert_category_t::dht_operation"></a><dl class="docutils">
<dt>dht_operation</dt>
<dd>enable events from pure dht operations not related to torrents</dd>
</dl>
<a name="alert_category_t::port_mapping_log"></a><dl class="docutils">
<dt>port_mapping_log</dt>
<dd>enables port mapping log events. This log is useful
for debugging the UPnP or NAT-PMP implementation</dd>
</dl>
<a name="alert_category_t::picker_log"></a><dl class="docutils">
<dt>picker_log</dt>
<dd>enables verbose logging from the piece picker.</dd>
</dl>
<a name="alert_category_t::file_progress"></a><dl class="docutils">
<dt>file_progress</dt>
<dd>alerts when files complete downloading</dd>
</dl>
<a name="alert_category_t::piece_progress"></a><dl class="docutils">
<dt>piece_progress</dt>
<dd>alerts when pieces complete downloading or fail hash check</dd>
</dl>
<a name="alert_category_t::upload"></a><dl class="docutils">
<dt>upload</dt>
<dd>alerts when we upload blocks to other peers</dd>
</dl>
<a name="alert_category_t::block_progress"></a><dl class="docutils">
<dt>block_progress</dt>
<dd>alerts on individual blocks being requested, downloading, finished,
rejected, time-out and cancelled. This is likely to post alerts at a
high rate.</dd>
</dl>
<a name="alert_category_t::all"></a><dl class="docutils">
<dt>all</dt>
<dd><p class="first">The full bitmask, representing all available categories.</p>
<p class="last">since the enum is signed, make sure this isn't
interpreted as -1. For instance, boost.python
does that and fails when assigning it to an
unsigned parameter.</p>
</dd>
</dl>
<a name="hasher"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+hasher&labels=documentation&body=Documentation+under+heading+%22class+hasher%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="hasher">
<h1>hasher</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/hasher.hpp">libtorrent/hasher.hpp</a>&quot;</p>
<p>this is a SHA-1 hash class.</p>
<p>You use it by first instantiating it, then call <tt class="docutils literal">update()</tt> to feed it
with data. i.e. you don't have to keep the entire buffer of which you want to
create the hash in memory. You can feed the <a class="reference external" href="reference-Utility.html#hasher">hasher</a> parts of it at a time. When
You have fed the <a class="reference external" href="reference-Utility.html#hasher">hasher</a> with all the data, you call <tt class="docutils literal">final()</tt> and it
will return the sha1-hash of the data.</p>
<p>The constructor that takes a <tt class="docutils literal">char const*</tt> and an integer will construct the
sha1 context and feed it the data passed in.</p>
<p>If you want to reuse the <a class="reference external" href="reference-Utility.html#hasher">hasher</a> object once you have created a hash, you have to
call <tt class="docutils literal">reset()</tt> to reinitialize it.</p>
<p>The built-in software version of sha1-algorithm was implemented
by Steve Reid and released as public domain.
For more info, see <tt class="docutils literal">src/sha1.cpp</tt>.</p>
<pre class="literal-block">
class hasher
{
   <strong>hasher</strong> ();
   hasher&amp; <strong>operator=</strong> (hasher const&amp;) &amp;;
   <strong>hasher</strong> (hasher const&amp;);
   explicit <strong>hasher</strong> (span&lt;char const&gt; data);
   <strong>hasher</strong> (char const* data, int len);
   hasher&amp; <strong>update</strong> (span&lt;char const&gt; data);
   hasher&amp; <strong>update</strong> (char const* data, int len);
   sha1_hash <strong>final</strong> ();
   void <strong>reset</strong> ();
};
</pre>
<a name="operator=()"></a>
<a name="hasher()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:hasher%3A%3A%5Boperator%3D%28%29+hasher%28%29%5D&labels=documentation&body=Documentation+under+heading+%22hasher%3A%3A%5Boperator%3D%28%29+hasher%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="operator-hasher">
<h2>operator=() hasher()</h2>
<pre class="literal-block">
hasher&amp; <strong>operator=</strong> (hasher const&amp;) &amp;;
<strong>hasher</strong> (hasher const&amp;);
explicit <strong>hasher</strong> (span&lt;char const&gt; data);
<strong>hasher</strong> (char const* data, int len);
</pre>
<p>this is the same as default constructing followed by a call to
<tt class="docutils literal">update(data, len)</tt>.</p>
<a name="update()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:hasher%3A%3A%5Bupdate%28%29%5D&labels=documentation&body=Documentation+under+heading+%22hasher%3A%3A%5Bupdate%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="update">
<h2>update()</h2>
<pre class="literal-block">
hasher&amp; <strong>update</strong> (span&lt;char const&gt; data);
hasher&amp; <strong>update</strong> (char const* data, int len);
</pre>
<p>append the following bytes to what is being hashed</p>
<a name="final()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:hasher%3A%3A%5Bfinal%28%29%5D&labels=documentation&body=Documentation+under+heading+%22hasher%3A%3A%5Bfinal%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="final">
<h2>final()</h2>
<pre class="literal-block">
sha1_hash <strong>final</strong> ();
</pre>
<p>returns the SHA-1 digest of the buffers previously passed to
<a class="reference external" href="reference-Utility.html#update()">update()</a> and the <a class="reference external" href="reference-Utility.html#hasher">hasher</a> constructor.</p>
<a name="reset()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:hasher%3A%3A%5Breset%28%29%5D&labels=documentation&body=Documentation+under+heading+%22hasher%3A%3A%5Breset%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="reset-1">
<h2>reset()</h2>
<pre class="literal-block">
void <strong>reset</strong> ();
</pre>
<p>restore the <a class="reference external" href="reference-Utility.html#hasher">hasher</a> state to be as if the <a class="reference external" href="reference-Utility.html#hasher">hasher</a> has just been
default constructed.</p>
<a name="hasher256"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+hasher256&labels=documentation&body=Documentation+under+heading+%22class+hasher256%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="hasher256">
<h1>hasher256</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/hasher.hpp">libtorrent/hasher.hpp</a>&quot;</p>
<pre class="literal-block">
class hasher256
{
   <strong>hasher256</strong> ();
   hasher256&amp; <strong>operator=</strong> (hasher256 const&amp;) &amp;;
   explicit <strong>hasher256</strong> (span&lt;char const&gt; data);
   <strong>hasher256</strong> (hasher256 const&amp;);
   <strong>hasher256</strong> (char const* data, int len);
   hasher256&amp; <strong>update</strong> (char const* data, int len);
   hasher256&amp; <strong>update</strong> (span&lt;char const&gt; data);
   sha256_hash <strong>final</strong> ();
   void <strong>reset</strong> ();
   <strong>~hasher256</strong> ();
};
</pre>
<a name="operator=()"></a>
<a name="hasher256()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:hasher256%3A%3A%5Boperator%3D%28%29+hasher256%28%29%5D&labels=documentation&body=Documentation+under+heading+%22hasher256%3A%3A%5Boperator%3D%28%29+hasher256%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="operator-hasher256">
<h2>operator=() hasher256()</h2>
<pre class="literal-block">
hasher256&amp; <strong>operator=</strong> (hasher256 const&amp;) &amp;;
explicit <strong>hasher256</strong> (span&lt;char const&gt; data);
<strong>hasher256</strong> (hasher256 const&amp;);
<strong>hasher256</strong> (char const* data, int len);
</pre>
<p>this is the same as default constructing followed by a call to
<tt class="docutils literal">update(data, len)</tt>.</p>
<a name="update()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:hasher256%3A%3A%5Bupdate%28%29%5D&labels=documentation&body=Documentation+under+heading+%22hasher256%3A%3A%5Bupdate%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="update-1">
<h2>update()</h2>
<pre class="literal-block">
hasher256&amp; <strong>update</strong> (char const* data, int len);
hasher256&amp; <strong>update</strong> (span&lt;char const&gt; data);
</pre>
<p>append the following bytes to what is being hashed</p>
<a name="final()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:hasher256%3A%3A%5Bfinal%28%29%5D&labels=documentation&body=Documentation+under+heading+%22hasher256%3A%3A%5Bfinal%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="final-1">
<h2>final()</h2>
<pre class="literal-block">
sha256_hash <strong>final</strong> ();
</pre>
<p>returns the SHA-1 digest of the buffers previously passed to
<a class="reference external" href="reference-Utility.html#update()">update()</a> and the <a class="reference external" href="reference-Utility.html#hasher">hasher</a> constructor.</p>
<a name="reset()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:hasher256%3A%3A%5Breset%28%29%5D&labels=documentation&body=Documentation+under+heading+%22hasher256%3A%3A%5Breset%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="reset-2">
<h2>reset()</h2>
<pre class="literal-block">
void <strong>reset</strong> ();
</pre>
<p>restore the <a class="reference external" href="reference-Utility.html#hasher">hasher</a> state to be as if the <a class="reference external" href="reference-Utility.html#hasher">hasher</a> has just been
default constructed.</p>
<a name="bitfield"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+bitfield&labels=documentation&body=Documentation+under+heading+%22class+bitfield%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="bitfield">
<h1>bitfield</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/bitfield.hpp">libtorrent/bitfield.hpp</a>&quot;</p>
<p>The <a class="reference external" href="reference-Utility.html#bitfield">bitfield</a> type stores any number of bits as a <a class="reference external" href="reference-Utility.html#bitfield">bitfield</a>
in a heap allocated array.</p>
<pre class="literal-block">
struct bitfield
{
   <strong>bitfield</strong> (int bits, bool val);
   <strong>bitfield</strong> () noexcept = default;
   explicit <strong>bitfield</strong> (int bits);
   <strong>bitfield</strong> (bitfield&amp;&amp; rhs) noexcept = default;
   <strong>bitfield</strong> (bitfield const&amp; rhs);
   <strong>bitfield</strong> (char const* b, int bits);
   void <strong>assign</strong> (char const* b, int const bits);
   bool <strong>operator[]</strong> (int index) const noexcept;
   bool <strong>get_bit</strong> (int index) const noexcept;
   void <strong>set_bit</strong> (int index) noexcept;
   void <strong>clear_bit</strong> (int index) noexcept;
   bool <strong>all_set</strong> () const noexcept;
   bool <strong>none_set</strong> () const noexcept;
   int <strong>size</strong> () const noexcept;
   int <strong>num_words</strong> () const noexcept;
   int <strong>num_bytes</strong> () const noexcept;
   bool <strong>empty</strong> () const noexcept;
   char* <strong>data</strong> () noexcept;
   char const* <strong>data</strong> () const noexcept;
   void <strong>swap</strong> (bitfield&amp; rhs) noexcept;
   int <strong>count</strong> () const noexcept;
   int <strong>find_first_set</strong> () const noexcept;
   int <strong>find_last_clear</strong> () const noexcept;
   bool <strong>operator==</strong> (lt::bitfield const&amp; rhs) const;
};
</pre>
<a name="bitfield()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:bitfield%3A%3A%5Bbitfield%28%29%5D&labels=documentation&body=Documentation+under+heading+%22bitfield%3A%3A%5Bbitfield%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="bitfield-1">
<h2>bitfield()</h2>
<pre class="literal-block">
<strong>bitfield</strong> (int bits, bool val);
<strong>bitfield</strong> () noexcept = default;
explicit <strong>bitfield</strong> (int bits);
<strong>bitfield</strong> (bitfield&amp;&amp; rhs) noexcept = default;
<strong>bitfield</strong> (bitfield const&amp; rhs);
<strong>bitfield</strong> (char const* b, int bits);
</pre>
<p>constructs a new <a class="reference external" href="reference-Utility.html#bitfield">bitfield</a>. The default constructor creates an empty
<a class="reference external" href="reference-Utility.html#bitfield">bitfield</a>. <tt class="docutils literal">bits</tt> is the size of the <a class="reference external" href="reference-Utility.html#bitfield">bitfield</a> (specified in bits).
<tt class="docutils literal">val</tt> is the value to initialize the bits to. If not specified
all bits are initialized to 0.</p>
<p>The constructor taking a pointer <tt class="docutils literal">b</tt> and <tt class="docutils literal">bits</tt> copies a <a class="reference external" href="reference-Utility.html#bitfield">bitfield</a>
from the specified buffer, and <tt class="docutils literal">bits</tt> number of bits (rounded up to
the nearest byte boundary).</p>
<a name="assign()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:bitfield%3A%3A%5Bassign%28%29%5D&labels=documentation&body=Documentation+under+heading+%22bitfield%3A%3A%5Bassign%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="assign">
<h2>assign()</h2>
<pre class="literal-block">
void <strong>assign</strong> (char const* b, int const bits);
</pre>
<p>copy <a class="reference external" href="reference-Utility.html#bitfield">bitfield</a> from buffer <tt class="docutils literal">b</tt> of <tt class="docutils literal">bits</tt> number of bits, rounded up to
the nearest byte boundary.</p>
<a name="operator[]()"></a>
<a name="get_bit()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:bitfield%3A%3A%5Boperator%5B%5D%28%29+get_bit%28%29%5D&labels=documentation&body=Documentation+under+heading+%22bitfield%3A%3A%5Boperator%5B%5D%28%29+get_bit%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="operator-get-bit">
<h2>operator[]() get_bit()</h2>
<pre class="literal-block">
bool <strong>operator[]</strong> (int index) const noexcept;
bool <strong>get_bit</strong> (int index) const noexcept;
</pre>
<p>query bit at <tt class="docutils literal">index</tt>. Returns true if bit is 1, otherwise false.</p>
<a name="set_bit()"></a>
<a name="clear_bit()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:bitfield%3A%3A%5Bset_bit%28%29+clear_bit%28%29%5D&labels=documentation&body=Documentation+under+heading+%22bitfield%3A%3A%5Bset_bit%28%29+clear_bit%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="set-bit-clear-bit">
<h2>set_bit() clear_bit()</h2>
<pre class="literal-block">
void <strong>set_bit</strong> (int index) noexcept;
void <strong>clear_bit</strong> (int index) noexcept;
</pre>
<p>set bit at <tt class="docutils literal">index</tt> to 0 (clear_bit) or 1 (set_bit).</p>
<a name="all_set()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:bitfield%3A%3A%5Ball_set%28%29%5D&labels=documentation&body=Documentation+under+heading+%22bitfield%3A%3A%5Ball_set%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="all-set">
<h2>all_set()</h2>
<pre class="literal-block">
bool <strong>all_set</strong> () const noexcept;
</pre>
<p>returns true if all bits in the <a class="reference external" href="reference-Utility.html#bitfield">bitfield</a> are set</p>
<a name="none_set()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:bitfield%3A%3A%5Bnone_set%28%29%5D&labels=documentation&body=Documentation+under+heading+%22bitfield%3A%3A%5Bnone_set%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="none-set">
<h2>none_set()</h2>
<pre class="literal-block">
bool <strong>none_set</strong> () const noexcept;
</pre>
<p>returns true if no bit in the <a class="reference external" href="reference-Utility.html#bitfield">bitfield</a> is set</p>
<a name="size()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:bitfield%3A%3A%5Bsize%28%29%5D&labels=documentation&body=Documentation+under+heading+%22bitfield%3A%3A%5Bsize%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="size">
<h2>size()</h2>
<pre class="literal-block">
int <strong>size</strong> () const noexcept;
</pre>
<p>returns the size of the <a class="reference external" href="reference-Utility.html#bitfield">bitfield</a> in bits.</p>
<a name="num_words()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:bitfield%3A%3A%5Bnum_words%28%29%5D&labels=documentation&body=Documentation+under+heading+%22bitfield%3A%3A%5Bnum_words%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="num-words">
<h2>num_words()</h2>
<pre class="literal-block">
int <strong>num_words</strong> () const noexcept;
</pre>
<p>returns the number of 32 bit words are needed to represent all bits in
this <a class="reference external" href="reference-Utility.html#bitfield">bitfield</a>.</p>
<a name="num_bytes()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:bitfield%3A%3A%5Bnum_bytes%28%29%5D&labels=documentation&body=Documentation+under+heading+%22bitfield%3A%3A%5Bnum_bytes%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="num-bytes">
<h2>num_bytes()</h2>
<pre class="literal-block">
int <strong>num_bytes</strong> () const noexcept;
</pre>
<p>returns the number of bytes needed to represent all bits in this
<a class="reference external" href="reference-Utility.html#bitfield">bitfield</a></p>
<a name="empty()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:bitfield%3A%3A%5Bempty%28%29%5D&labels=documentation&body=Documentation+under+heading+%22bitfield%3A%3A%5Bempty%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="empty">
<h2>empty()</h2>
<pre class="literal-block">
bool <strong>empty</strong> () const noexcept;
</pre>
<p>returns true if the <a class="reference external" href="reference-Utility.html#bitfield">bitfield</a> has zero size.</p>
<a name="data()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:bitfield%3A%3A%5Bdata%28%29%5D&labels=documentation&body=Documentation+under+heading+%22bitfield%3A%3A%5Bdata%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="data-1">
<h2>data()</h2>
<pre class="literal-block">
char* <strong>data</strong> () noexcept;
char const* <strong>data</strong> () const noexcept;
</pre>
<p>returns a pointer to the internal buffer of the <a class="reference external" href="reference-Utility.html#bitfield">bitfield</a>, or
<tt class="docutils literal">nullptr</tt> if it's empty.</p>
<a name="swap()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:bitfield%3A%3A%5Bswap%28%29%5D&labels=documentation&body=Documentation+under+heading+%22bitfield%3A%3A%5Bswap%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="swap-1">
<h2>swap()</h2>
<pre class="literal-block">
void <strong>swap</strong> (bitfield&amp; rhs) noexcept;
</pre>
<p>swaps the bit-fields two variables refer to</p>
<a name="count()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:bitfield%3A%3A%5Bcount%28%29%5D&labels=documentation&body=Documentation+under+heading+%22bitfield%3A%3A%5Bcount%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="count">
<h2>count()</h2>
<pre class="literal-block">
int <strong>count</strong> () const noexcept;
</pre>
<p>count the number of bits in the <a class="reference external" href="reference-Utility.html#bitfield">bitfield</a> that are set to 1.</p>
<a name="find_first_set()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:bitfield%3A%3A%5Bfind_first_set%28%29%5D&labels=documentation&body=Documentation+under+heading+%22bitfield%3A%3A%5Bfind_first_set%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="find-first-set">
<h2>find_first_set()</h2>
<pre class="literal-block">
int <strong>find_first_set</strong> () const noexcept;
</pre>
<p>returns the index of the first set bit in the <a class="reference external" href="reference-Utility.html#bitfield">bitfield</a>, i.e. 1 bit.</p>
<a name="find_last_clear()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:bitfield%3A%3A%5Bfind_last_clear%28%29%5D&labels=documentation&body=Documentation+under+heading+%22bitfield%3A%3A%5Bfind_last_clear%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="find-last-clear">
<h2>find_last_clear()</h2>
<pre class="literal-block">
int <strong>find_last_clear</strong> () const noexcept;
</pre>
<p>returns the index to the last cleared bit in the <a class="reference external" href="reference-Utility.html#bitfield">bitfield</a>, i.e. 0 bit.</p>
<p>libtorrent has a <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> interface for implementing extensions to the protocol.
These can be general extensions for transferring metadata or peer exchange
extensions, or it could be used to provide a way to customize the protocol
to fit a particular (closed) network.</p>
<p>In short, the <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> interface makes it possible to:</p>
<ul class="simple">
<li>register extension messages (sent in the extension handshake), see
<a class="reference external" href="manual-ref.html#extensions">extensions</a>.</li>
<li>add data and parse data from the extension handshake.</li>
<li>send extension messages and standard bittorrent messages.</li>
<li>override or block the handling of standard bittorrent messages.</li>
<li>save and restore state via the <a class="reference external" href="reference-Session.html#session">session</a> state</li>
<li>see all alerts that are posted</li>
</ul>
</div>
</div>
<div class="section" id="a-word-of-caution">
<h1>a word of caution</h1>
<p>Writing your own <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> is a very easy way to introduce serious bugs such as
dead locks and race conditions. Since a <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> has access to internal
structures it is also quite easy to sabotage libtorrent's operation.</p>
<p>All the callbacks are always called from the libtorrent network thread. In
case portions of your <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> are called from other threads, typically the main
thread, you cannot use any of the member functions on the internal structures
in libtorrent, since those require being called from the libtorrent network
thread . Furthermore, you also need to synchronize your own shared data
within the <a class="reference external" href="reference-Plugins.html#plugin">plugin</a>, to make sure it is not accessed at the same time from the
libtorrent thread (through a callback). If you need to send out a message
from another thread, it is advised to use an internal queue, and do the
actual sending in <tt class="docutils literal">tick()</tt>.</p>
<p>Since the <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> interface gives you easy access to internal structures, it
is not supported as a stable API. Plugins should be considered specific to a
specific version of libtorrent. Although, in practice the internals mostly
don't change that dramatically.</p>
</div>
<div class="section" id="plugin-interface">
<h1>plugin-interface</h1>
<p>The <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> interface consists of three base classes that the <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> may
implement. These are called <a class="reference external" href="reference-Plugins.html#plugin">plugin</a>, <a class="reference external" href="reference-Plugins.html#torrent_plugin">torrent_plugin</a> and <a class="reference external" href="reference-Plugins.html#peer_plugin">peer_plugin</a>.
They are found in the <tt class="docutils literal">&lt;libtorrent/extensions.hpp&gt;</tt> header.</p>
<p>These plugins are instantiated for each <a class="reference external" href="reference-Session.html#session">session</a>, torrent and possibly each peer,
respectively.</p>
<p>For plugins that only need per torrent state, it is enough to only implement
<tt class="docutils literal">torrent_plugin</tt> and pass a constructor function or function object to
<tt class="docutils literal"><span class="pre">session::add_extension()</span></tt> or <tt class="docutils literal"><span class="pre">torrent_handle::add_extension()</span></tt> (if the
torrent has already been started and you want to hook in the extension at
run-time).</p>
<p>The signature of the function is:</p>
<pre class="code c++ literal-block">
<span class="name">std</span><span class="operator">::</span><span class="name">shared_ptr</span><span class="operator">&lt;</span><span class="name">torrent_plugin</span><span class="operator">&gt;</span><span class="whitespace"> </span><span class="punctuation">(</span><span class="operator">*</span><span class="punctuation">)(</span><span class="name">torrent_handle</span><span class="whitespace"> </span><span class="keyword">const</span><span class="operator">&amp;</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">client_data_t</span><span class="punctuation">);</span>
</pre>
<p>The second argument is the userdata passed to <tt class="docutils literal"><span class="pre">session::add_torrent()</span></tt> or
<tt class="docutils literal"><span class="pre">torrent_handle::add_extension()</span></tt>.</p>
<p>The function should return a <tt class="docutils literal"><span class="pre">std::shared_ptr&lt;torrent_plugin&gt;</span></tt> which
may or may not be 0. If it is a nullptr, the extension is simply ignored
for this torrent. If it is a valid pointer (to a class inheriting
<tt class="docutils literal">torrent_plugin</tt>), it will be associated with this torrent and callbacks
will be made on torrent events.</p>
<p>For more elaborate plugins which require <a class="reference external" href="reference-Session.html#session">session</a> wide state, you would
implement <tt class="docutils literal">plugin</tt>, construct an object (in a <tt class="docutils literal"><span class="pre">std::shared_ptr</span></tt>) and pass
it in to <tt class="docutils literal"><span class="pre">session::add_extension()</span></tt>.</p>
</div>
<div class="section" id="custom-alerts">
<h1>custom alerts</h1>
<p>Since plugins are running within internal libtorrent threads, one convenient
way to communicate with the client is to post custom alerts.</p>
<p>The expected interface of any <a class="reference external" href="reference-Alerts.html#alert">alert</a>, apart from deriving from the <a class="reference external" href="reference-Alerts.html#alert">alert</a>
base class, looks like this:</p>
<pre class="literal-block">
static const int alert_type = <em>&lt;unique alert ID&gt;</em>;
virtual int type() const { return alert_type; }

virtual std::string message() const;

static const alert_category_t static_category = <em>&lt;bitmask of alert::category_t flags&gt;</em>;
virtual alert_category_t category() const { return static_category; }

virtual char const* what() const { return <em>&lt;string literal of the name of this alert&gt;</em>; }
</pre>
<p>The <tt class="docutils literal">alert_type</tt> is used for the type-checking in <tt class="docutils literal">alert_cast</tt>. It must
not collide with any other <a class="reference external" href="reference-Alerts.html#alert">alert</a>. The built-in alerts in libtorrent will
not use <a class="reference external" href="reference-Alerts.html#alert">alert</a> type IDs greater than <tt class="docutils literal">user_alert_id</tt>. When defining your
own <a class="reference external" href="reference-Alerts.html#alert">alert</a>, make sure it's greater than this constant.</p>
<p><tt class="docutils literal">type()</tt> is the run-time equivalence of the <tt class="docutils literal">alert_type</tt>.</p>
<p>The <tt class="docutils literal">message()</tt> virtual function is expected to construct a useful
string representation of the <a class="reference external" href="reference-Alerts.html#alert">alert</a> and the event or data it represents.
Something convenient to put in a log file for instance.</p>
<p><tt class="docutils literal">clone()</tt> is used internally to copy alerts. The suggested implementation
of simply allocating a new instance as a copy of <tt class="docutils literal">*this</tt> is all that's
expected.</p>
<p>The static category is required for checking whether or not the category
for a specific <a class="reference external" href="reference-Alerts.html#alert">alert</a> is enabled or not, without instantiating the <a class="reference external" href="reference-Alerts.html#alert">alert</a>.
The <tt class="docutils literal">category</tt> virtual function is the run-time equivalence.</p>
<p>The <tt class="docutils literal">what()</tt> virtual function may simply be a string literal of the class
name of your <a class="reference external" href="reference-Alerts.html#alert">alert</a>.</p>
<p>For more information, see the <a class="reference external" href="reference-Alerts.html">alert section</a>.</p>
<a name="peer_connection_handle"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+peer_connection_handle&labels=documentation&body=Documentation+under+heading+%22class+peer_connection_handle%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="peer-connection-handle">
<h1>peer_connection_handle</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/peer_connection_handle.hpp">libtorrent/peer_connection_handle.hpp</a>&quot;</p>
<p>the <a class="reference external" href="reference-Plugins.html#peer_connection_handle">peer_connection_handle</a> class provides a handle to the internal peer
connection object, to be used by plugins. This is a low level interface that
may not be stable across libtorrent versions</p>
<pre class="literal-block">
struct peer_connection_handle
{
   explicit <strong>peer_connection_handle</strong> (std::weak_ptr&lt;peer_connection&gt; impl);
   connection_type <strong>type</strong> () const;
   peer_plugin const* <strong>find_plugin</strong> (string_view type) const;
   void <strong>add_extension</strong> (std::shared_ptr&lt;peer_plugin&gt;);
   bool <strong>is_seed</strong> () const;
   bool <strong>upload_only</strong> () const;
   bool <strong>has_piece</strong> (piece_index_t i) const;
   peer_id const&amp; <strong>pid</strong> () const;
   bool <strong>is_interesting</strong> () const;
   bool <strong>is_choked</strong> () const;
   bool <strong>has_peer_choked</strong> () const;
   bool <strong>is_peer_interested</strong> () const;
   void <strong>choke_this_peer</strong> ();
   void <strong>maybe_unchoke_this_peer</strong> ();
   void <strong>get_peer_info</strong> (peer_info&amp; p) const;
   torrent_handle <strong>associated_torrent</strong> () const;
   <a class="reference external" href="tcp::endpoint">tcp::endpoint</a> const&amp; <strong>remote</strong> () const;
   <a class="reference external" href="tcp::endpoint">tcp::endpoint</a> <strong>local_endpoint</strong> () const;
   bool <strong>is_disconnecting</strong> () const;
   bool <strong>is_outgoing</strong> () const;
   void <strong>disconnect</strong> (error_code const&amp; ec, operation_t op
      , disconnect_severity_t = peer_connection_interface::normal);
   bool <strong>is_connecting</strong> () const;
   bool <strong>on_local_network</strong> () const;
   bool <strong>ignore_unchoke_slots</strong> () const;
   bool <strong>failed</strong> () const;
   void <strong>peer_log</strong> (peer_log_alert::direction_t direction
      , char const* event, char const* fmt = &quot;&quot;, ...) const TORRENT_FORMAT(4,5);
   bool <strong>should_log</strong> (peer_log_alert::direction_t direction) const;
   bool <strong>can_disconnect</strong> (error_code const&amp; ec) const;
   bool <strong>has_metadata</strong> () const;
   bool <strong>in_handshake</strong> () const;
   void <strong>send_buffer</strong> (char const* begin, int size);
   time_point <strong>time_of_last_unchoke</strong> () const;
   std::time_t <strong>last_seen_complete</strong> () const;
   bool <strong>operator==</strong> (peer_connection_handle const&amp; o) const;
   bool <strong>operator&lt;</strong> (peer_connection_handle const&amp; o) const;
   bool <strong>operator!=</strong> (peer_connection_handle const&amp; o) const;
   std::shared_ptr&lt;peer_connection&gt; <strong>native_handle</strong> () const;
};
</pre>
<a name="bt_peer_connection_handle"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+bt_peer_connection_handle&labels=documentation&body=Documentation+under+heading+%22class+bt_peer_connection_handle%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="bt-peer-connection-handle">
<h1>bt_peer_connection_handle</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/peer_connection_handle.hpp">libtorrent/peer_connection_handle.hpp</a>&quot;</p>
<p>The <a class="reference external" href="reference-Plugins.html#bt_peer_connection_handle">bt_peer_connection_handle</a> provides a handle to the internal bittorrent
peer connection object to plugins. It's low level and may not be a stable API
across libtorrent versions.</p>
<pre class="literal-block">
struct bt_peer_connection_handle : peer_connection_handle
{
   explicit <strong>bt_peer_connection_handle</strong> (peer_connection_handle pc);
   bool <strong>support_extensions</strong> () const;
   bool <strong>packet_finished</strong> () const;
   bool <strong>supports_encryption</strong> () const;
   void <strong>switch_recv_crypto</strong> (std::shared_ptr&lt;crypto_plugin&gt; crypto);
   void <strong>switch_send_crypto</strong> (std::shared_ptr&lt;crypto_plugin&gt; crypto);
   std::shared_ptr&lt;bt_peer_connection&gt; <strong>native_handle</strong> () const;
};
</pre>
<a name="plugin"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+plugin&labels=documentation&body=Documentation+under+heading+%22class+plugin%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="plugin">
<h1>plugin</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/extensions.hpp">libtorrent/extensions.hpp</a>&quot;</p>
<p>this is the base class for a <a class="reference external" href="reference-Session.html#session">session</a> <a class="reference external" href="reference-Plugins.html#plugin">plugin</a>. One primary feature
is that it is notified of all torrents that are added to the <a class="reference external" href="reference-Session.html#session">session</a>,
and can add its own torrent_plugins.</p>
<pre class="literal-block">
struct plugin
{
   virtual feature_flags_t <strong>implemented_features</strong> ();
   virtual std::shared_ptr&lt;torrent_plugin&gt; <strong>new_torrent</strong> (torrent_handle const&amp;, client_data_t);
   virtual void <strong>added</strong> (session_handle const&amp;);
   virtual void <strong>abort</strong> ();
   virtual bool <strong>on_dht_request</strong> (string_view <em>/* query */</em>
      , udp::endpoint const&amp; <em>/* source */</em>, bdecode_node const&amp; <em>/* message */</em>
      , entry&amp; <em>/* response */</em>);
   virtual void <strong>on_alert</strong> (alert const*);
   virtual bool <strong>on_unknown_torrent</strong> (info_hash_t const&amp; <em>/* info_hash */</em>
      , peer_connection_handle const&amp; <em>/* pc */</em>, add_torrent_params&amp; <em>/* p */</em>);
   virtual void <strong>on_tick</strong> ();
   virtual uint64_t <strong>get_unchoke_priority</strong> (peer_connection_handle const&amp; <em>/* peer */</em>);
   virtual std::map&lt;std::string, std::string&gt; <strong>save_state</strong> () const;
   virtual void <strong>load_state</strong> (std::map&lt;std::string, std::string&gt; const&amp;);

   static constexpr feature_flags_t <strong>optimistic_unchoke_feature</strong>  = 1_bit;
   static constexpr feature_flags_t <strong>tick_feature</strong>  = 2_bit;
   static constexpr feature_flags_t <strong>dht_request_feature</strong>  = 3_bit;
   static constexpr feature_flags_t <strong>alert_feature</strong>  = 4_bit;
   static constexpr feature_flags_t <strong>unknown_torrent_feature</strong>  = 5_bit;
};
</pre>
<a name="implemented_features()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:plugin%3A%3A%5Bimplemented_features%28%29%5D&labels=documentation&body=Documentation+under+heading+%22plugin%3A%3A%5Bimplemented_features%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="implemented-features">
<h2>implemented_features()</h2>
<pre class="literal-block">
virtual feature_flags_t <strong>implemented_features</strong> ();
</pre>
<p>This function is expected to return a bitmask indicating which features
this <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> implements. Some callbacks on this object may not be called
unless the corresponding feature flag is returned here. Note that
callbacks may still be called even if the corresponding feature is not
specified in the return value here. See feature_flags_t for possible
flags to return.</p>
<a name="new_torrent()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:plugin%3A%3A%5Bnew_torrent%28%29%5D&labels=documentation&body=Documentation+under+heading+%22plugin%3A%3A%5Bnew_torrent%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="new-torrent-1">
<h2>new_torrent()</h2>
<pre class="literal-block">
virtual std::shared_ptr&lt;torrent_plugin&gt; <strong>new_torrent</strong> (torrent_handle const&amp;, client_data_t);
</pre>
<p>this is called by the <a class="reference external" href="reference-Session.html#session">session</a> every time a new torrent is added.
The <tt class="docutils literal">torrent*</tt> points to the internal torrent object created
for the new torrent. The <a class="reference external" href="reference-Add_Torrent.html#client_data_t">client_data_t</a> is the userdata pointer as
passed in via <a class="reference external" href="reference-Add_Torrent.html#add_torrent_params">add_torrent_params</a>.</p>
<p>If the <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> returns a <a class="reference external" href="reference-Plugins.html#torrent_plugin">torrent_plugin</a> instance, it will be added
to the new torrent. Otherwise, return an empty shared_ptr to a
<a class="reference external" href="reference-Plugins.html#torrent_plugin">torrent_plugin</a> (the default).</p>
<a name="added()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:plugin%3A%3A%5Badded%28%29%5D&labels=documentation&body=Documentation+under+heading+%22plugin%3A%3A%5Badded%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="added">
<h2>added()</h2>
<pre class="literal-block">
virtual void <strong>added</strong> (session_handle const&amp;);
</pre>
<p>called when <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> is added to a <a class="reference external" href="reference-Session.html#session">session</a></p>
<a name="abort()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:plugin%3A%3A%5Babort%28%29%5D&labels=documentation&body=Documentation+under+heading+%22plugin%3A%3A%5Babort%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="abort-1">
<h2>abort()</h2>
<pre class="literal-block">
virtual void <strong>abort</strong> ();
</pre>
<p>called when the <a class="reference external" href="reference-Session.html#session">session</a> is aborted
the <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> should perform any cleanup necessary to allow the session's
destruction (e.g. cancel outstanding async operations)</p>
<a name="on_dht_request()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:plugin%3A%3A%5Bon_dht_request%28%29%5D&labels=documentation&body=Documentation+under+heading+%22plugin%3A%3A%5Bon_dht_request%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="on-dht-request">
<h2>on_dht_request()</h2>
<pre class="literal-block">
virtual bool <strong>on_dht_request</strong> (string_view <em>/* query */</em>
      , udp::endpoint const&amp; <em>/* source */</em>, bdecode_node const&amp; <em>/* message */</em>
      , entry&amp; <em>/* response */</em>);
</pre>
<p>called when a dht request is received.
If your <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> expects this to be called, make sure to include the flag
<tt class="docutils literal">dht_request_feature</tt> in the return value from <a class="reference external" href="reference-Plugins.html#implemented_features()">implemented_features()</a>.</p>
<a name="on_alert()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:plugin%3A%3A%5Bon_alert%28%29%5D&labels=documentation&body=Documentation+under+heading+%22plugin%3A%3A%5Bon_alert%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="on-alert">
<h2>on_alert()</h2>
<pre class="literal-block">
virtual void <strong>on_alert</strong> (alert const*);
</pre>
<p>called when an <a class="reference external" href="reference-Alerts.html#alert">alert</a> is posted alerts that are filtered are not posted.
If your <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> expects this to be called, make sure to include the flag
<tt class="docutils literal">alert_feature</tt> in the return value from <a class="reference external" href="reference-Plugins.html#implemented_features()">implemented_features()</a>.</p>
<a name="on_unknown_torrent()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:plugin%3A%3A%5Bon_unknown_torrent%28%29%5D&labels=documentation&body=Documentation+under+heading+%22plugin%3A%3A%5Bon_unknown_torrent%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="on-unknown-torrent">
<h2>on_unknown_torrent()</h2>
<pre class="literal-block">
virtual bool <strong>on_unknown_torrent</strong> (info_hash_t const&amp; <em>/* info_hash */</em>
      , peer_connection_handle const&amp; <em>/* pc */</em>, add_torrent_params&amp; <em>/* p */</em>);
</pre>
<p>return true if the <a class="reference external" href="reference-Add_Torrent.html#add_torrent_params">add_torrent_params</a> should be added</p>
<a name="on_tick()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:plugin%3A%3A%5Bon_tick%28%29%5D&labels=documentation&body=Documentation+under+heading+%22plugin%3A%3A%5Bon_tick%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="on-tick">
<h2>on_tick()</h2>
<pre class="literal-block">
virtual void <strong>on_tick</strong> ();
</pre>
<p>called once per second.
If your <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> expects this to be called, make sure to include the flag
<tt class="docutils literal">tick_feature</tt> in the return value from <a class="reference external" href="reference-Plugins.html#implemented_features()">implemented_features()</a>.</p>
<a name="get_unchoke_priority()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:plugin%3A%3A%5Bget_unchoke_priority%28%29%5D&labels=documentation&body=Documentation+under+heading+%22plugin%3A%3A%5Bget_unchoke_priority%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="get-unchoke-priority">
<h2>get_unchoke_priority()</h2>
<pre class="literal-block">
virtual uint64_t <strong>get_unchoke_priority</strong> (peer_connection_handle const&amp; <em>/* peer */</em>);
</pre>
<p>called when choosing peers to optimistically unchoke. The return value
indicates the peer's priority for unchoking. Lower return values
correspond to higher priority. Priorities above 2^63-1 are reserved.
If your <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> has no priority to assign a peer it should return 2^64-1.
If your <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> expects this to be called, make sure to include the flag
<tt class="docutils literal">optimistic_unchoke_feature</tt> in the return value from <a class="reference external" href="reference-Plugins.html#implemented_features()">implemented_features()</a>.
If multiple plugins implement this function the lowest return value
(i.e. the highest priority) is used.</p>
<a name="load_state()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:plugin%3A%3A%5Bload_state%28%29%5D&labels=documentation&body=Documentation+under+heading+%22plugin%3A%3A%5Bload_state%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="load-state">
<h2>load_state()</h2>
<pre class="literal-block">
virtual void <strong>load_state</strong> (std::map&lt;std::string, std::string&gt; const&amp;);
</pre>
<p>called on startup while loading settings state from the <a class="reference external" href="reference-Session.html#session_params">session_params</a></p>
<a name="optimistic_unchoke_feature"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:plugin%3A%3A%5Boptimistic_unchoke_feature%5D&labels=documentation&body=Documentation+under+heading+%22plugin%3A%3A%5Boptimistic_unchoke_feature%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>optimistic_unchoke_feature</dt>
<dd>include this bit if your <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> needs to alter the order of the
optimistic unchoke of peers. i.e. have the on_optimistic_unchoke()
callback be called.</dd>
</dl>
<a name="tick_feature"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:plugin%3A%3A%5Btick_feature%5D&labels=documentation&body=Documentation+under+heading+%22plugin%3A%3A%5Btick_feature%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>tick_feature</dt>
<dd>include this bit if your <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> needs to have <a class="reference external" href="reference-Plugins.html#on_tick()">on_tick()</a> called</dd>
</dl>
<a name="dht_request_feature"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:plugin%3A%3A%5Bdht_request_feature%5D&labels=documentation&body=Documentation+under+heading+%22plugin%3A%3A%5Bdht_request_feature%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>dht_request_feature</dt>
<dd>include this bit if your <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> needs to have <a class="reference external" href="reference-Plugins.html#on_dht_request()">on_dht_request()</a>
called</dd>
</dl>
<a name="alert_feature"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:plugin%3A%3A%5Balert_feature%5D&labels=documentation&body=Documentation+under+heading+%22plugin%3A%3A%5Balert_feature%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>alert_feature</dt>
<dd>include this bit if your <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> needs to have <a class="reference external" href="reference-Plugins.html#on_alert()">on_alert()</a>
called</dd>
</dl>
<a name="unknown_torrent_feature"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:plugin%3A%3A%5Bunknown_torrent_feature%5D&labels=documentation&body=Documentation+under+heading+%22plugin%3A%3A%5Bunknown_torrent_feature%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>unknown_torrent_feature</dt>
<dd>include this bit if your <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> needs to have <a class="reference external" href="reference-Plugins.html#on_unknown_torrent()">on_unknown_torrent()</a>
called even if there is no active torrent in the <a class="reference external" href="reference-Session.html#session">session</a></dd>
</dl>
<a name="torrent_plugin"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+torrent_plugin&labels=documentation&body=Documentation+under+heading+%22class+torrent_plugin%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="torrent-plugin">
<h1>torrent_plugin</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/extensions.hpp">libtorrent/extensions.hpp</a>&quot;</p>
<p>Torrent plugins are associated with a single torrent and have a number
of functions called at certain events. Many of its functions have the
ability to change or override the default libtorrent behavior.</p>
<pre class="literal-block">
struct torrent_plugin
{
   virtual std::shared_ptr&lt;peer_plugin&gt; <strong>new_connection</strong> (peer_connection_handle const&amp;);
   virtual void <strong>on_piece_pass</strong> (piece_index_t);
   virtual void <strong>on_piece_failed</strong> (piece_index_t);
   virtual void <strong>tick</strong> ();
   virtual bool <strong>on_pause</strong> ();
   virtual bool <strong>on_resume</strong> ();
   virtual void <strong>on_files_checked</strong> ();
   virtual void <strong>on_state</strong> (torrent_status::state_t);
   virtual void <strong>on_add_peer</strong> (tcp::endpoint const&amp;,
      peer_source_flags_t, add_peer_flags_t);

   static constexpr add_peer_flags_t <strong>first_time</strong>  = 1_bit;
   static constexpr add_peer_flags_t <strong>filtered</strong>  = 2_bit;
};
</pre>
<a name="new_connection()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_plugin%3A%3A%5Bnew_connection%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_plugin%3A%3A%5Bnew_connection%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="new-connection">
<h2>new_connection()</h2>
<pre class="literal-block">
virtual std::shared_ptr&lt;peer_plugin&gt; <strong>new_connection</strong> (peer_connection_handle const&amp;);
</pre>
<p>This function is called each time a new peer is connected to the torrent. You
may choose to ignore this by just returning a default constructed
<tt class="docutils literal">shared_ptr</tt> (in which case you don't need to override this member
function).</p>
<p>If you need an extension to the peer connection (which most plugins do) you
are supposed to return an instance of your <a class="reference external" href="reference-Plugins.html#peer_plugin">peer_plugin</a> class. Which in
turn will have its hook functions called on event specific to that peer.</p>
<p>The <tt class="docutils literal">peer_connection_handle</tt> will be valid as long as the <tt class="docutils literal">shared_ptr</tt>
is being held by the torrent object. So, it is generally a good idea to not
keep a <tt class="docutils literal">shared_ptr</tt> to your own <a class="reference external" href="reference-Plugins.html#peer_plugin">peer_plugin</a>. If you want to keep references
to it, use <tt class="docutils literal">weak_ptr</tt>.</p>
<p>If this function throws an exception, the connection will be closed.</p>
<a name="on_piece_pass()"></a>
<a name="on_piece_failed()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_plugin%3A%3A%5Bon_piece_pass%28%29+on_piece_failed%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_plugin%3A%3A%5Bon_piece_pass%28%29+on_piece_failed%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="on-piece-pass-on-piece-failed">
<h2>on_piece_pass() on_piece_failed()</h2>
<pre class="literal-block">
virtual void <strong>on_piece_pass</strong> (piece_index_t);
virtual void <strong>on_piece_failed</strong> (piece_index_t);
</pre>
<p>These hooks are called when a piece passes the hash check or fails the hash
check, respectively. The <tt class="docutils literal">index</tt> is the piece index that was downloaded.
It is possible to access the list of peers that participated in sending the
piece through the <tt class="docutils literal">torrent</tt> and the <tt class="docutils literal">piece_picker</tt>.</p>
<a name="tick()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_plugin%3A%3A%5Btick%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_plugin%3A%3A%5Btick%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="tick">
<h2>tick()</h2>
<pre class="literal-block">
virtual void <strong>tick</strong> ();
</pre>
<p>This hook is called approximately once per second. It is a way of making it
easy for plugins to do timed events, for sending messages or whatever.</p>
<a name="on_resume()"></a>
<a name="on_pause()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_plugin%3A%3A%5Bon_resume%28%29+on_pause%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_plugin%3A%3A%5Bon_resume%28%29+on_pause%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="on-resume-on-pause">
<h2>on_resume() on_pause()</h2>
<pre class="literal-block">
virtual bool <strong>on_pause</strong> ();
virtual bool <strong>on_resume</strong> ();
</pre>
<p>These hooks are called when the torrent is paused and resumed respectively.
The return value indicates if the event was handled. A return value of
<tt class="docutils literal">true</tt> indicates that it was handled, and no other <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> after this one
will have this hook function called, and the standard handler will also not be
invoked. So, returning true effectively overrides the standard behavior of
pause or resume.</p>
<p>Note that if you call <tt class="docutils literal">pause()</tt> or <tt class="docutils literal">resume()</tt> on the torrent from your
handler it will recurse back into your handler, so in order to invoke the
standard handler, you have to keep your own state on whether you want standard
behavior or overridden behavior.</p>
<a name="on_files_checked()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_plugin%3A%3A%5Bon_files_checked%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_plugin%3A%3A%5Bon_files_checked%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="on-files-checked">
<h2>on_files_checked()</h2>
<pre class="literal-block">
virtual void <strong>on_files_checked</strong> ();
</pre>
<p>This function is called when the initial files of the torrent have been
checked. If there are no files to check, this function is called immediately.</p>
<p>i.e. This function is always called when the torrent is in a state where it
can start downloading.</p>
<a name="on_state()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_plugin%3A%3A%5Bon_state%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_plugin%3A%3A%5Bon_state%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="on-state">
<h2>on_state()</h2>
<pre class="literal-block">
virtual void <strong>on_state</strong> (torrent_status::state_t);
</pre>
<p>called when the torrent changes state
the state is one of <a class="reference external" href="reference-Torrent_Status.html#state_t">torrent_status::state_t</a>
enum members</p>
<a name="on_add_peer()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_plugin%3A%3A%5Bon_add_peer%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_plugin%3A%3A%5Bon_add_peer%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="on-add-peer">
<h2>on_add_peer()</h2>
<pre class="literal-block">
virtual void <strong>on_add_peer</strong> (tcp::endpoint const&amp;,
      peer_source_flags_t, add_peer_flags_t);
</pre>
<p>called every time a new peer is added to the peer list.
This is before the peer is connected to. For <tt class="docutils literal">flags</tt>, see
torrent_plugin::flags_t. The <tt class="docutils literal">source</tt> argument refers to
the source where we learned about this peer from. It's a
bitmask, because many sources may have told us about the same
peer. For peer source flags, see peer_info::peer_source_flags.</p>
<a name="first_time"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_plugin%3A%3A%5Bfirst_time%5D&labels=documentation&body=Documentation+under+heading+%22torrent_plugin%3A%3A%5Bfirst_time%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>first_time</dt>
<dd>this is the first time we see this peer</dd>
</dl>
<a name="filtered"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_plugin%3A%3A%5Bfiltered%5D&labels=documentation&body=Documentation+under+heading+%22torrent_plugin%3A%3A%5Bfiltered%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>filtered</dt>
<dd>this peer was not added because it was
filtered by the IP filter</dd>
</dl>
<a name="peer_plugin"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+peer_plugin&labels=documentation&body=Documentation+under+heading+%22class+peer_plugin%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="peer-plugin">
<h1>peer_plugin</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/extensions.hpp">libtorrent/extensions.hpp</a>&quot;</p>
<p>peer plugins are associated with a specific peer. A peer could be
both a regular bittorrent peer (<tt class="docutils literal">bt_peer_connection</tt>) or one of the
web seed connections (<tt class="docutils literal">web_peer_connection</tt> or <tt class="docutils literal">http_seed_connection</tt>).
In order to only attach to certain peers, make your
torrent_plugin::new_connection only return a <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> for certain peer
connection types</p>
<pre class="literal-block">
struct peer_plugin
{
   virtual string_view <strong>type</strong> () const;
   virtual void <strong>add_handshake</strong> (entry&amp;);
   virtual void <strong>on_disconnect</strong> (error_code const&amp;);
   virtual void <strong>on_connected</strong> ();
   virtual bool <strong>on_handshake</strong> (span&lt;char const&gt;);
   virtual bool <strong>on_extension_handshake</strong> (bdecode_node const&amp;);
   virtual bool <strong>on_bitfield</strong> (bitfield const&amp; <em>/*bitfield*/</em>);
   virtual bool <strong>on_dont_have</strong> (piece_index_t);
   virtual bool <strong>on_unchoke</strong> ();
   virtual bool <strong>on_have</strong> (piece_index_t);
   virtual bool <strong>on_interested</strong> ();
   virtual bool <strong>on_choke</strong> ();
   virtual bool <strong>on_have_none</strong> ();
   virtual bool <strong>on_request</strong> (peer_request const&amp;);
   virtual bool <strong>on_allowed_fast</strong> (piece_index_t);
   virtual bool <strong>on_not_interested</strong> ();
   virtual bool <strong>on_have_all</strong> ();
   virtual bool <strong>on_piece</strong> (peer_request const&amp; <em>/*piece*/</em>
      , span&lt;char const&gt; <em>/*buf*/</em>);
   virtual bool <strong>on_cancel</strong> (peer_request const&amp;);
   virtual bool <strong>on_suggest</strong> (piece_index_t);
   virtual bool <strong>on_reject</strong> (peer_request const&amp;);
   virtual void <strong>sent_cancel</strong> (peer_request const&amp;);
   virtual void <strong>sent_choke</strong> ();
   virtual void <strong>sent_have_none</strong> ();
   virtual void <strong>sent_reject_request</strong> (peer_request const&amp;);
   virtual void <strong>sent_allow_fast</strong> (piece_index_t);
   virtual void <strong>sent_have_all</strong> ();
   virtual void <strong>sent_suggest</strong> (piece_index_t);
   virtual void <strong>sent_request</strong> (peer_request const&amp;);
   virtual void <strong>sent_unchoke</strong> ();
   virtual void <strong>sent_interested</strong> ();
   virtual void <strong>sent_have</strong> (piece_index_t);
   virtual void <strong>sent_piece</strong> (peer_request const&amp;);
   virtual void <strong>sent_not_interested</strong> ();
   virtual void <strong>sent_payload</strong> (int <em>/* bytes */</em>);
   virtual bool <strong>can_disconnect</strong> (error_code const&amp; <em>/*ec*/</em>);
   virtual bool <strong>on_extended</strong> (int <em>/*length*/</em>, int <em>/*msg*/</em>,
      span&lt;char const&gt; <em>/*body*/</em>);
   virtual bool <strong>on_unknown_message</strong> (int <em>/*length*/</em>, int <em>/*msg*/</em>,
      span&lt;char const&gt; <em>/*body*/</em>);
   virtual void <strong>on_piece_pass</strong> (piece_index_t);
   virtual void <strong>on_piece_failed</strong> (piece_index_t);
   virtual void <strong>tick</strong> ();
   virtual bool <strong>write_request</strong> (peer_request const&amp;);
};
</pre>
<a name="type()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_plugin%3A%3A%5Btype%28%29%5D&labels=documentation&body=Documentation+under+heading+%22peer_plugin%3A%3A%5Btype%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="type-1">
<h2>type()</h2>
<pre class="literal-block">
virtual string_view <strong>type</strong> () const;
</pre>
<p>This function is expected to return the name of
the <a class="reference external" href="reference-Plugins.html#plugin">plugin</a>.</p>
<a name="add_handshake()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_plugin%3A%3A%5Badd_handshake%28%29%5D&labels=documentation&body=Documentation+under+heading+%22peer_plugin%3A%3A%5Badd_handshake%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="add-handshake">
<h2>add_handshake()</h2>
<pre class="literal-block">
virtual void <strong>add_handshake</strong> (entry&amp;);
</pre>
<p>can add entries to the extension handshake
this is not called for web seeds</p>
<a name="on_disconnect()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_plugin%3A%3A%5Bon_disconnect%28%29%5D&labels=documentation&body=Documentation+under+heading+%22peer_plugin%3A%3A%5Bon_disconnect%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="on-disconnect">
<h2>on_disconnect()</h2>
<pre class="literal-block">
virtual void <strong>on_disconnect</strong> (error_code const&amp;);
</pre>
<p>called when the peer is being disconnected.</p>
<a name="on_connected()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_plugin%3A%3A%5Bon_connected%28%29%5D&labels=documentation&body=Documentation+under+heading+%22peer_plugin%3A%3A%5Bon_connected%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="on-connected">
<h2>on_connected()</h2>
<pre class="literal-block">
virtual void <strong>on_connected</strong> ();
</pre>
<p>called when the peer is successfully connected. Note that
incoming connections will have been connected by the time
the peer <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> is attached to it, and won't have this hook
called.</p>
<a name="on_handshake()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_plugin%3A%3A%5Bon_handshake%28%29%5D&labels=documentation&body=Documentation+under+heading+%22peer_plugin%3A%3A%5Bon_handshake%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="on-handshake">
<h2>on_handshake()</h2>
<pre class="literal-block">
virtual bool <strong>on_handshake</strong> (span&lt;char const&gt;);
</pre>
<p>this is called when the initial bittorrent handshake is received.
Returning false means that the other end doesn't support this extension
and will remove it from the list of plugins. this is not called for web
seeds</p>
<a name="on_extension_handshake()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_plugin%3A%3A%5Bon_extension_handshake%28%29%5D&labels=documentation&body=Documentation+under+heading+%22peer_plugin%3A%3A%5Bon_extension_handshake%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="on-extension-handshake">
<h2>on_extension_handshake()</h2>
<pre class="literal-block">
virtual bool <strong>on_extension_handshake</strong> (bdecode_node const&amp;);
</pre>
<p>called when the extension handshake from the other end is received
if this returns false, it means that this extension isn't
supported by this peer. It will result in this <a class="reference external" href="reference-Plugins.html#peer_plugin">peer_plugin</a>
being removed from the peer_connection and destructed.
this is not called for web seeds</p>
<a name="on_interested()"></a>
<a name="on_have_all()"></a>
<a name="on_not_interested()"></a>
<a name="on_have_none()"></a>
<a name="on_dont_have()"></a>
<a name="on_allowed_fast()"></a>
<a name="on_unchoke()"></a>
<a name="on_bitfield()"></a>
<a name="on_have()"></a>
<a name="on_request()"></a>
<a name="on_choke()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_plugin%3A%3A%5Bon_interested%28%29+on_have_all%28%29+on_not_interested%28%29+on_have_none%28%29+on_dont_have%28%29+on_allowed_fast%28%29+on_unchoke%28%29+on_bitfield%28%29+on_have%28%29+on_request%28%29+on_choke%28%29%5D&labels=documentation&body=Documentation+under+heading+%22peer_plugin%3A%3A%5Bon_interested%28%29+on_have_all%28%29+on_not_interested%28%29+on_have_none%28%29+on_dont_have%28%29+on_allowed_fast%28%29+on_unchoke%28%29+on_bitfield%28%29+on_have%28%29+on_request%28%29+on_choke%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="on-interested-on-have-all-on-not-interested-on-have-none-on-dont-have-on-allowed-fast-on-unchoke-on-bitfield-on-have-on-request-on-choke">
<h2>on_interested() on_have_all() on_not_interested() on_have_none() on_dont_have() on_allowed_fast() on_unchoke() on_bitfield() on_have() on_request() on_choke()</h2>
<pre class="literal-block">
virtual bool <strong>on_bitfield</strong> (bitfield const&amp; <em>/*bitfield*/</em>);
virtual bool <strong>on_dont_have</strong> (piece_index_t);
virtual bool <strong>on_unchoke</strong> ();
virtual bool <strong>on_have</strong> (piece_index_t);
virtual bool <strong>on_interested</strong> ();
virtual bool <strong>on_choke</strong> ();
virtual bool <strong>on_have_none</strong> ();
virtual bool <strong>on_request</strong> (peer_request const&amp;);
virtual bool <strong>on_allowed_fast</strong> (piece_index_t);
virtual bool <strong>on_not_interested</strong> ();
virtual bool <strong>on_have_all</strong> ();
</pre>
<p>returning true from any of the message handlers
indicates that the <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> has handled the message.
it will break the <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> chain traversing and not let
anyone else handle the message, including the default
handler.</p>
<a name="on_piece()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_plugin%3A%3A%5Bon_piece%28%29%5D&labels=documentation&body=Documentation+under+heading+%22peer_plugin%3A%3A%5Bon_piece%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="on-piece">
<h2>on_piece()</h2>
<pre class="literal-block">
virtual bool <strong>on_piece</strong> (peer_request const&amp; <em>/*piece*/</em>
      , span&lt;char const&gt; <em>/*buf*/</em>);
</pre>
<p>This function is called when the peer connection is receiving
a piece. <tt class="docutils literal">buf</tt> points (non-owning pointer) to the data in an
internal immutable disk buffer. The length of the data is specified
in the <tt class="docutils literal">length</tt> member of the <tt class="docutils literal">piece</tt> parameter.
returns true to indicate that the piece is handled and the
rest of the logic should be ignored.</p>
<a name="sent_not_interested()"></a>
<a name="sent_unchoke()"></a>
<a name="sent_have()"></a>
<a name="sent_piece()"></a>
<a name="sent_interested()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_plugin%3A%3A%5Bsent_not_interested%28%29+sent_unchoke%28%29+sent_have%28%29+sent_piece%28%29+sent_interested%28%29%5D&labels=documentation&body=Documentation+under+heading+%22peer_plugin%3A%3A%5Bsent_not_interested%28%29+sent_unchoke%28%29+sent_have%28%29+sent_piece%28%29+sent_interested%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="sent-not-interested-sent-unchoke-sent-have-sent-piece-sent-interested">
<h2>sent_not_interested() sent_unchoke() sent_have() sent_piece() sent_interested()</h2>
<pre class="literal-block">
virtual void <strong>sent_unchoke</strong> ();
virtual void <strong>sent_interested</strong> ();
virtual void <strong>sent_have</strong> (piece_index_t);
virtual void <strong>sent_piece</strong> (peer_request const&amp;);
virtual void <strong>sent_not_interested</strong> ();
</pre>
<p>called after a choke message has been sent to the peer</p>
<a name="sent_payload()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_plugin%3A%3A%5Bsent_payload%28%29%5D&labels=documentation&body=Documentation+under+heading+%22peer_plugin%3A%3A%5Bsent_payload%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="sent-payload">
<h2>sent_payload()</h2>
<pre class="literal-block">
virtual void <strong>sent_payload</strong> (int <em>/* bytes */</em>);
</pre>
<p>called after piece data has been sent to the peer
this can be used for stats book keeping</p>
<a name="can_disconnect()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_plugin%3A%3A%5Bcan_disconnect%28%29%5D&labels=documentation&body=Documentation+under+heading+%22peer_plugin%3A%3A%5Bcan_disconnect%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="can-disconnect">
<h2>can_disconnect()</h2>
<pre class="literal-block">
virtual bool <strong>can_disconnect</strong> (error_code const&amp; <em>/*ec*/</em>);
</pre>
<p>called when libtorrent think this peer should be disconnected.
if the <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> returns false, the peer will not be disconnected.</p>
<a name="on_extended()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_plugin%3A%3A%5Bon_extended%28%29%5D&labels=documentation&body=Documentation+under+heading+%22peer_plugin%3A%3A%5Bon_extended%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="on-extended">
<h2>on_extended()</h2>
<pre class="literal-block">
virtual bool <strong>on_extended</strong> (int <em>/*length*/</em>, int <em>/*msg*/</em>,
      span&lt;char const&gt; <em>/*body*/</em>);
</pre>
<p>called when an extended message is received. If returning true,
the message is not processed by any other <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> and if false
is returned the next <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> in the chain will receive it to
be able to handle it. This is not called for web seeds.
thus function may be called more than once per incoming message, but
only the last of the calls will the <tt class="docutils literal">body</tt> size equal the <tt class="docutils literal">length</tt>.
i.e. Every time another fragment of the message is received, this
function will be called, until finally the whole message has been
received. The purpose of this is to allow early disconnects for invalid
messages and for reporting progress of receiving large messages.</p>
<a name="on_unknown_message()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_plugin%3A%3A%5Bon_unknown_message%28%29%5D&labels=documentation&body=Documentation+under+heading+%22peer_plugin%3A%3A%5Bon_unknown_message%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="on-unknown-message">
<h2>on_unknown_message()</h2>
<pre class="literal-block">
virtual bool <strong>on_unknown_message</strong> (int <em>/*length*/</em>, int <em>/*msg*/</em>,
      span&lt;char const&gt; <em>/*body*/</em>);
</pre>
<p>this is not called for web seeds</p>
<a name="on_piece_pass()"></a>
<a name="on_piece_failed()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_plugin%3A%3A%5Bon_piece_pass%28%29+on_piece_failed%28%29%5D&labels=documentation&body=Documentation+under+heading+%22peer_plugin%3A%3A%5Bon_piece_pass%28%29+on_piece_failed%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="on-piece-pass-on-piece-failed-1">
<h2>on_piece_pass() on_piece_failed()</h2>
<pre class="literal-block">
virtual void <strong>on_piece_pass</strong> (piece_index_t);
virtual void <strong>on_piece_failed</strong> (piece_index_t);
</pre>
<p>called when a piece that this peer participated in either
fails or passes the hash_check</p>
<a name="tick()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_plugin%3A%3A%5Btick%28%29%5D&labels=documentation&body=Documentation+under+heading+%22peer_plugin%3A%3A%5Btick%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="tick-1">
<h2>tick()</h2>
<pre class="literal-block">
virtual void <strong>tick</strong> ();
</pre>
<p>called approximately once every second</p>
<a name="write_request()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_plugin%3A%3A%5Bwrite_request%28%29%5D&labels=documentation&body=Documentation+under+heading+%22peer_plugin%3A%3A%5Bwrite_request%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="write-request">
<h2>write_request()</h2>
<pre class="literal-block">
virtual bool <strong>write_request</strong> (peer_request const&amp;);
</pre>
<p>called each time a request message is to be sent. If true
is returned, the original request message won't be sent and
no other <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> will have this function called.</p>
<a name="crypto_plugin"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+crypto_plugin&labels=documentation&body=Documentation+under+heading+%22class+crypto_plugin%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="crypto-plugin">
<h1>crypto_plugin</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/extensions.hpp">libtorrent/extensions.hpp</a>&quot;</p>
<pre class="literal-block">
struct crypto_plugin
{
   virtual void <strong>set_incoming_key</strong> (span&lt;char const&gt; key) = 0;
   virtual void <strong>set_outgoing_key</strong> (span&lt;char const&gt; key) = 0;
   <strong>encrypt</strong> (span&lt;span&lt;char&gt;&gt; <em>/*send_vec*/</em>) = 0;
   virtual std::tuple&lt;int, int, int&gt; <strong>decrypt</strong> (span&lt;span&lt;char&gt;&gt; <em>/*receive_vec*/</em>) = 0;
};
</pre>
<a name="decrypt()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:crypto_plugin%3A%3A%5Bdecrypt%28%29%5D&labels=documentation&body=Documentation+under+heading+%22crypto_plugin%3A%3A%5Bdecrypt%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="decrypt">
<h2>decrypt()</h2>
<pre class="literal-block">
virtual std::tuple&lt;int, int, int&gt; <strong>decrypt</strong> (span&lt;span&lt;char&gt;&gt; <em>/*receive_vec*/</em>) = 0;
</pre>
<p>decrypt the provided buffers.
returns is a tuple representing the values
(consume, produce, packet_size)</p>
<p>consume is set to the number of bytes which should be trimmed from the
head of the buffers, default is 0</p>
<p>produce is set to the number of bytes of payload which are now ready to
be sent to the upper layer. default is the number of bytes passed in receive_vec</p>
<p>packet_size is set to the minimum number of bytes which must be read to
advance the next step of decryption. default is 0</p>
<a name="create_smart_ban_plugin()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:create_smart_ban_plugin%28%29&labels=documentation&body=Documentation+under+heading+%22create_smart_ban_plugin%28%29%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="create-smart-ban-plugin">
<h1>create_smart_ban_plugin()</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/extensions/smart_ban.hpp">libtorrent/extensions/smart_ban.hpp</a>&quot;</p>
<pre class="literal-block">
std::shared_ptr&lt;torrent_plugin&gt; <strong>create_smart_ban_plugin</strong> (torrent_handle const&amp;, client_data_t);
</pre>
<p>constructor function for the smart ban extension. The extension keeps
track of the data peers have sent us for failing pieces and once the
piece completes and passes the hash check bans the peers that turned
out to have sent corrupt data.
This function can either be passed in the add_torrent_params::extensions
field, or via <a class="reference external" href="reference-Torrent_Handle.html#add_extension()">torrent_handle::add_extension()</a>.</p>
<a name="create_ut_pex_plugin()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:create_ut_pex_plugin%28%29&labels=documentation&body=Documentation+under+heading+%22create_ut_pex_plugin%28%29%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="create-ut-pex-plugin">
<h1>create_ut_pex_plugin()</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/extensions/ut_pex.hpp">libtorrent/extensions/ut_pex.hpp</a>&quot;</p>
<pre class="literal-block">
std::shared_ptr&lt;torrent_plugin&gt; <strong>create_ut_pex_plugin</strong> (torrent_handle const&amp;, client_data_t);
</pre>
<p>constructor function for the ut_pex extension. The ut_pex
extension allows peers to gossip about their connections, allowing
the swarm stay well connected and peers aware of more peers in the
swarm. This extension is enabled by default unless explicitly disabled in
the <a class="reference external" href="reference-Session.html#session">session</a> constructor.</p>
<p>This can either be passed in the add_torrent_params::extensions field, or
via <a class="reference external" href="reference-Torrent_Handle.html#add_extension()">torrent_handle::add_extension()</a>.</p>
<a name="create_ut_metadata_plugin()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:create_ut_metadata_plugin%28%29&labels=documentation&body=Documentation+under+heading+%22create_ut_metadata_plugin%28%29%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="create-ut-metadata-plugin">
<h1>create_ut_metadata_plugin()</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/extensions/ut_metadata.hpp">libtorrent/extensions/ut_metadata.hpp</a>&quot;</p>
<pre class="literal-block">
std::shared_ptr&lt;torrent_plugin&gt; <strong>create_ut_metadata_plugin</strong> (torrent_handle const&amp;, client_data_t);
</pre>
<p>constructor function for the ut_metadata extension. The ut_metadata
extension allows peers to request the .torrent file (or more
specifically the info-dictionary of the .torrent file) from each
other. This is the main building block in making magnet links work.
This extension is enabled by default unless explicitly disabled in
the <a class="reference external" href="reference-Session.html#session">session</a> constructor.</p>
<p>This can either be passed in the add_torrent_params::extensions field, or
via <a class="reference external" href="reference-Torrent_Handle.html#add_extension()">torrent_handle::add_extension()</a>.</p>
<a name="block_info"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+block_info&labels=documentation&body=Documentation+under+heading+%22class+block_info%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="block-info">
<h1>block_info</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/torrent_handle.hpp">libtorrent/torrent_handle.hpp</a>&quot;</p>
<p>holds the state of a block in a piece. Who we requested
it from and how far along we are at downloading it.</p>
<pre class="literal-block">
struct block_info
{
   <a class="reference external" href="tcp::endpoint">tcp::endpoint</a> <strong>peer</strong> () const;
   void <strong>set_peer</strong> (tcp::endpoint const&amp; ep);

   enum block_state_t
   {
      none,
      requested,
      writing,
      finished,
   };

   unsigned bytes_progress:15;
   unsigned block_size:15;
   unsigned state:2;
   unsigned num_peers:14;
};
</pre>
<a name="peer()"></a>
<a name="set_peer()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:block_info%3A%3A%5Bpeer%28%29+set_peer%28%29%5D&labels=documentation&body=Documentation+under+heading+%22block_info%3A%3A%5Bpeer%28%29+set_peer%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="peer-set-peer">
<h2>peer() set_peer()</h2>
<pre class="literal-block">
<a class="reference external" href="tcp::endpoint">tcp::endpoint</a> <strong>peer</strong> () const;
void <strong>set_peer</strong> (tcp::endpoint const&amp; ep);
</pre>
<p>The peer is the ip address of the peer this block was downloaded from.</p>
<a name="block_state_t"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+block_state_t&labels=documentation&body=Documentation+under+heading+%22enum+block_state_t%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-block-state-t">
<h2>enum block_state_t</h2>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/torrent_handle.hpp">libtorrent/torrent_handle.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="8%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>none</td>
<td>0</td>
<td>This block has not been downloaded or requested form any peer.</td>
</tr>
<tr><td>requested</td>
<td>1</td>
<td>The block has been requested, but not completely downloaded yet.</td>
</tr>
<tr><td>writing</td>
<td>2</td>
<td>The block has been downloaded and is currently queued for being
written to disk.</td>
</tr>
<tr><td>finished</td>
<td>3</td>
<td>The block has been written to disk.</td>
</tr>
</tbody>
</table>
<a name="bytes_progress"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:block_info%3A%3A%5Bbytes_progress%5D&labels=documentation&body=Documentation+under+heading+%22block_info%3A%3A%5Bbytes_progress%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>bytes_progress</dt>
<dd>the number of bytes that have been received for this block</dd>
</dl>
<a name="block_size"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:block_info%3A%3A%5Bblock_size%5D&labels=documentation&body=Documentation+under+heading+%22block_info%3A%3A%5Bblock_size%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>block_size</dt>
<dd>the total number of bytes in this block.</dd>
</dl>
<a name="state"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:block_info%3A%3A%5Bstate%5D&labels=documentation&body=Documentation+under+heading+%22block_info%3A%3A%5Bstate%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>state</dt>
<dd>the state this block is in (see <a class="reference external" href="reference-Torrent_Handle.html#block_state_t">block_state_t</a>)</dd>
</dl>
<a name="num_peers"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:block_info%3A%3A%5Bnum_peers%5D&labels=documentation&body=Documentation+under+heading+%22block_info%3A%3A%5Bnum_peers%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>num_peers</dt>
<dd>the number of peers that is currently requesting this block. Typically
this is 0 or 1, but at the end of the torrent blocks may be requested
by more peers in parallel to speed things up.</dd>
</dl>
<a name="partial_piece_info"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+partial_piece_info&labels=documentation&body=Documentation+under+heading+%22class+partial_piece_info%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="partial-piece-info">
<h1>partial_piece_info</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/torrent_handle.hpp">libtorrent/torrent_handle.hpp</a>&quot;</p>
<p>This class holds information about pieces that have outstanding requests
or outstanding writes</p>
<pre class="literal-block">
struct partial_piece_info
{
   piece_index_t piece_index;
   int blocks_in_piece;
   int finished;
   int writing;
   int requested;
   block_info const* blocks;
};
</pre>
<a name="piece_index"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:partial_piece_info%3A%3A%5Bpiece_index%5D&labels=documentation&body=Documentation+under+heading+%22partial_piece_info%3A%3A%5Bpiece_index%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>piece_index</dt>
<dd>the index of the piece in question. <tt class="docutils literal">blocks_in_piece</tt> is the number
of blocks in this particular piece. This number will be the same for
most pieces, but
the last piece may have fewer blocks than the standard pieces.</dd>
</dl>
<a name="blocks_in_piece"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:partial_piece_info%3A%3A%5Bblocks_in_piece%5D&labels=documentation&body=Documentation+under+heading+%22partial_piece_info%3A%3A%5Bblocks_in_piece%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>blocks_in_piece</dt>
<dd>the number of blocks in this piece</dd>
</dl>
<a name="finished"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:partial_piece_info%3A%3A%5Bfinished%5D&labels=documentation&body=Documentation+under+heading+%22partial_piece_info%3A%3A%5Bfinished%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>finished</dt>
<dd>the number of blocks that are in the finished state</dd>
</dl>
<a name="writing"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:partial_piece_info%3A%3A%5Bwriting%5D&labels=documentation&body=Documentation+under+heading+%22partial_piece_info%3A%3A%5Bwriting%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>writing</dt>
<dd>the number of blocks that are in the writing state</dd>
</dl>
<a name="requested"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:partial_piece_info%3A%3A%5Brequested%5D&labels=documentation&body=Documentation+under+heading+%22partial_piece_info%3A%3A%5Brequested%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>requested</dt>
<dd>the number of blocks that are in the requested state</dd>
</dl>
<a name="blocks"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:partial_piece_info%3A%3A%5Bblocks%5D&labels=documentation&body=Documentation+under+heading+%22partial_piece_info%3A%3A%5Bblocks%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>blocks</dt>
<dd><p class="first">this is an array of <tt class="docutils literal">blocks_in_piece</tt> number of
items. One for each block in the piece.</p>
<div class="admonition warning last">
<p class="first admonition-title">Warning</p>
<p class="last">This is a pointer that points to an array
that's owned by the <a class="reference external" href="reference-Session.html#session">session</a> object. The next time
<a class="reference external" href="reference-Torrent_Handle.html#get_download_queue()">get_download_queue()</a> is called, it will be invalidated.
In the case of <a class="reference external" href="reference-Alerts.html#piece_info_alert">piece_info_alert</a>, these pointers point into the <a class="reference external" href="reference-Alerts.html#alert">alert</a>
object itself, and will be invalidated when the <a class="reference external" href="reference-Alerts.html#alert">alert</a> destruct.</p>
</div>
</dd>
</dl>
<a name="torrent_handle"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+torrent_handle&labels=documentation&body=Documentation+under+heading+%22class+torrent_handle%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="torrent-handle">
<h1>torrent_handle</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/torrent_handle.hpp">libtorrent/torrent_handle.hpp</a>&quot;</p>
<p>You will usually have to store your torrent handles somewhere, since it's
the object through which you retrieve information about the torrent and
aborts the torrent.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Any member function that returns a value or fills in a value has to be
made synchronously. This means it has to wait for the main thread to
complete the query before it can return. This might potentially be
expensive if done from within a GUI thread that needs to stay
responsive. Try to avoid querying for information you don't need, and
try to do it in as few calls as possible. You can get most of the
interesting information about a torrent from the
<a class="reference external" href="reference-Torrent_Handle.html#status()">torrent_handle::status()</a> call.</p>
</div>
<p>The default constructor will initialize the handle to an invalid state.
Which means you cannot perform any operation on it, unless you first
assign it a valid handle. If you try to perform any operation on an
uninitialized handle, it will throw <tt class="docutils literal">invalid_handle</tt>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">All operations on a <a class="reference external" href="reference-Torrent_Handle.html#torrent_handle">torrent_handle</a> may throw system_error
exception, in case the handle is no longer referring to a torrent.
There is one exception <a class="reference external" href="reference-Torrent_Info.html#is_valid()">is_valid()</a> will never throw. Since the torrents
are processed by a background thread, there is no guarantee that a
handle will remain valid between two calls.</p>
</div>
<pre class="literal-block">
struct torrent_handle
{
   friend std::size_t <strong>hash_value</strong> (torrent_handle const&amp; th);
   <strong>torrent_handle</strong> () noexcept = default;
   void <strong>add_piece</strong> (piece_index_t piece, char const* data, add_piece_flags_t flags = {}) const;
   void <strong>add_piece</strong> (piece_index_t piece, std::vector&lt;char&gt; data, add_piece_flags_t flags = {}) const;
   void <strong>read_piece</strong> (piece_index_t piece) const;
   bool <strong>have_piece</strong> (piece_index_t piece) const;
   void <strong>get_peer_info</strong> (std::vector&lt;peer_info&gt;&amp; v) const;
   void <strong>post_peer_info</strong> () const;
   void <strong>post_status</strong> (status_flags_t flags = status_flags_t::all()) const;
   torrent_status <strong>status</strong> (status_flags_t flags = status_flags_t::all()) const;
   void <strong>post_download_queue</strong> () const;
   std::vector&lt;partial_piece_info&gt; <strong>get_download_queue</strong> () const;
   void <strong>get_download_queue</strong> (std::vector&lt;partial_piece_info&gt;&amp; queue) const;
   void <strong>set_piece_deadline</strong> (piece_index_t index, int deadline, deadline_flags_t flags = {}) const;
   void <strong>clear_piece_deadlines</strong> () const;
   void <strong>reset_piece_deadline</strong> (piece_index_t index) const;
   void <strong>post_file_progress</strong> (file_progress_flags_t flags) const;
   std::vector&lt;std::int64_t&gt; <strong>file_progress</strong> (file_progress_flags_t flags = {}) const;
   void <strong>file_progress</strong> (std::vector&lt;std::int64_t&gt;&amp; progress, file_progress_flags_t flags = {}) const;
   std::vector&lt;open_file_state&gt; <strong>file_status</strong> () const;
   void <strong>clear_error</strong> () const;
   void <strong>post_trackers</strong> () const;
   std::vector&lt;announce_entry&gt; <strong>trackers</strong> () const;
   void <strong>replace_trackers</strong> (std::vector&lt;announce_entry&gt; const&amp;) const;
   void <strong>add_tracker</strong> (announce_entry const&amp;) const;
   void <strong>add_url_seed</strong> (std::string const&amp; url) const;
   std::set&lt;std::string&gt; <strong>url_seeds</strong> () const;
   void <strong>remove_url_seed</strong> (std::string const&amp; url) const;
   std::set&lt;std::string&gt; <strong>http_seeds</strong> () const;
   void <strong>remove_http_seed</strong> (std::string const&amp; url) const;
   void <strong>add_http_seed</strong> (std::string const&amp; url) const;
   void <strong>add_extension</strong> (
      std::function&lt;std::shared_ptr&lt;torrent_plugin&gt;(torrent_handle const&amp;, client_data_t)&gt; const&amp; ext
      , client_data_t userdata = client_data_t{});
   bool <strong>set_metadata</strong> (span&lt;char const&gt; metadata) const;
   bool <strong>is_valid</strong> () const;
   void <strong>resume</strong> () const;
   void <strong>pause</strong> (pause_flags_t flags = {}) const;
   void <strong>unset_flags</strong> (torrent_flags_t flags) const;
   torrent_flags_t <strong>flags</strong> () const;
   void <strong>set_flags</strong> (torrent_flags_t flags) const;
   void <strong>set_flags</strong> (torrent_flags_t flags, torrent_flags_t mask) const;
   void <strong>flush_cache</strong> () const;
   void <strong>force_recheck</strong> () const;
   void <strong>save_resume_data</strong> (resume_data_flags_t flags = {}) const;
   bool <strong>need_save_resume_data</strong> () const;
   bool <strong>need_save_resume_data</strong> (resume_data_flags_t flags) const;
   queue_position_t <strong>queue_position</strong> () const;
   void <strong>queue_position_bottom</strong> () const;
   void <strong>queue_position_down</strong> () const;
   void <strong>queue_position_up</strong> () const;
   void <strong>queue_position_top</strong> () const;
   void <strong>queue_position_set</strong> (queue_position_t p) const;
   void <strong>set_ssl_certificate_buffer</strong> (std::string const&amp; certificate
      , std::string const&amp; private_key
      , std::string const&amp; dh_params);
   void <strong>set_ssl_certificate</strong> (std::string const&amp; certificate
      , std::string const&amp; private_key
      , std::string const&amp; dh_params
      , std::string const&amp; passphrase = &quot;&quot;);
   std::shared_ptr&lt;torrent_info&gt; <strong>torrent_file_with_hashes</strong> () const;
   std::shared_ptr&lt;const torrent_info&gt; <strong>torrent_file</strong> () const;
   std::vector&lt;std::vector&lt;sha256_hash&gt;&gt; <strong>piece_layers</strong> () const;
   void <strong>piece_availability</strong> (std::vector&lt;int&gt;&amp; avail) const;
   void <strong>post_piece_availability</strong> () const;
   void <strong>piece_priority</strong> (piece_index_t index, download_priority_t priority) const;
   void <strong>prioritize_pieces</strong> (std::vector&lt;download_priority_t&gt; const&amp; pieces) const;
   download_priority_t <strong>piece_priority</strong> (piece_index_t index) const;
   std::vector&lt;download_priority_t&gt; <strong>get_piece_priorities</strong> () const;
   void <strong>prioritize_pieces</strong> (std::vector&lt;std::pair&lt;piece_index_t, download_priority_t&gt;&gt; const&amp; pieces) const;
   download_priority_t <strong>file_priority</strong> (file_index_t index) const;
   std::vector&lt;download_priority_t&gt; <strong>get_file_priorities</strong> () const;
   void <strong>file_priority</strong> (file_index_t index, download_priority_t priority) const;
   void <strong>prioritize_files</strong> (std::vector&lt;download_priority_t&gt; const&amp; files) const;
   void <strong>force_dht_announce</strong> () const;
   void <strong>force_reannounce</strong> (int seconds = 0, int idx = -1, reannounce_flags_t = {}) const;
   void <strong>force_lsd_announce</strong> () const;
   void <strong>scrape_tracker</strong> (int idx = -1) const;
   void <strong>set_upload_limit</strong> (int limit) const;
   void <strong>set_download_limit</strong> (int limit) const;
   int <strong>upload_limit</strong> () const;
   int <strong>download_limit</strong> () const;
   void <strong>connect_peer</strong> (tcp::endpoint const&amp; adr, peer_source_flags_t source = {}
      , pex_flags_t flags = pex_encryption | pex_utp | pex_holepunch) const;
   void <strong>clear_peers</strong> ();
   int <strong>max_uploads</strong> () const;
   void <strong>set_max_uploads</strong> (int max_uploads) const;
   void <strong>set_max_connections</strong> (int max_connections) const;
   int <strong>max_connections</strong> () const;
   void <strong>move_storage</strong> (std::string const&amp; save_path
      , move_flags_t flags = move_flags_t::always_replace_files
      ) const;
   void <strong>rename_file</strong> (file_index_t index, std::string const&amp; new_name) const;
   info_hash_t <strong>info_hashes</strong> () const;
   sha1_hash <strong>info_hash</strong> () const;
   bool <strong>operator!=</strong> (const torrent_handle&amp; h) const;
   bool <strong>operator==</strong> (const torrent_handle&amp; h) const;
   bool <strong>operator&lt;</strong> (const torrent_handle&amp; h) const;
   std::uint32_t <strong>id</strong> () const;
   std::shared_ptr&lt;torrent&gt; <strong>native_handle</strong> () const;
   client_data_t <strong>userdata</strong> () const;
   bool <strong>in_session</strong> () const;

   static constexpr add_piece_flags_t <strong>overwrite_existing</strong>  = 0_bit;
   static constexpr status_flags_t <strong>query_distributed_copies</strong>  = 0_bit;
   static constexpr status_flags_t <strong>query_accurate_download_counters</strong>  = 1_bit;
   static constexpr status_flags_t <strong>query_last_seen_complete</strong>  = 2_bit;
   static constexpr status_flags_t <strong>query_pieces</strong>  = 3_bit;
   static constexpr status_flags_t <strong>query_verified_pieces</strong>  = 4_bit;
   static constexpr status_flags_t <strong>query_torrent_file</strong>  = 5_bit;
   static constexpr status_flags_t <strong>query_name</strong>  = 6_bit;
   static constexpr status_flags_t <strong>query_save_path</strong>  = 7_bit;
   static constexpr deadline_flags_t <strong>alert_when_available</strong>  = 0_bit;
   static constexpr file_progress_flags_t <strong>piece_granularity</strong>  = 0_bit;
   static constexpr pause_flags_t <strong>graceful_pause</strong>  = 0_bit;
   static constexpr resume_data_flags_t <strong>flush_disk_cache</strong>  = 0_bit;
   static constexpr resume_data_flags_t <strong>save_info_dict</strong>  = 1_bit;
   static constexpr resume_data_flags_t <strong>only_if_modified</strong>  = 2_bit;
   static constexpr resume_data_flags_t <strong>if_counters_changed</strong>  = 3_bit;
   static constexpr resume_data_flags_t <strong>if_download_progress</strong>  = 4_bit;
   static constexpr resume_data_flags_t <strong>if_config_changed</strong>  = 5_bit;
   static constexpr resume_data_flags_t <strong>if_state_changed</strong>  = 6_bit;
   static constexpr resume_data_flags_t <strong>if_metadata_changed</strong>  = 7_bit;
   static constexpr reannounce_flags_t <strong>ignore_min_interval</strong>  = 0_bit;
};
</pre>
<a name="torrent_handle()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Btorrent_handle%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Btorrent_handle%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="torrent-handle-1">
<h2>torrent_handle()</h2>
<pre class="literal-block">
<strong>torrent_handle</strong> () noexcept = default;
</pre>
<p>constructs a torrent handle that does not refer to a torrent.
i.e. <a class="reference external" href="reference-Torrent_Info.html#is_valid()">is_valid()</a> will return false.</p>
<a name="add_piece()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Badd_piece%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Badd_piece%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="add-piece">
<h2>add_piece()</h2>
<pre class="literal-block">
void <strong>add_piece</strong> (piece_index_t piece, char const* data, add_piece_flags_t flags = {}) const;
void <strong>add_piece</strong> (piece_index_t piece, std::vector&lt;char&gt; data, add_piece_flags_t flags = {}) const;
</pre>
<p>This function will write <tt class="docutils literal">data</tt> to the storage as piece <tt class="docutils literal">piece</tt>,
as if it had been downloaded from a peer.</p>
<p>By default, data that's already been downloaded is not overwritten by
this buffer. If you trust this data to be correct (and pass the piece
hash check) you may pass the overwrite_existing flag. This will
instruct libtorrent to overwrite any data that may already have been
downloaded with this data.</p>
<p>Since the data is written asynchronously, you may know that is passed
or failed the hash check by waiting for <a class="reference external" href="reference-Alerts.html#piece_finished_alert">piece_finished_alert</a> or
<a class="reference external" href="reference-Alerts.html#hash_failed_alert">hash_failed_alert</a>.</p>
<p>Adding pieces while the torrent is being checked (i.e. in
<a class="reference external" href="reference-Torrent_Status.html#checking_files">torrent_status::checking_files</a> state) is not supported.</p>
<p>The overload taking a raw pointer to the data is a blocking call. It
won't return until the libtorrent thread has copied the data into its
disk write buffer. <tt class="docutils literal">data</tt> is expected to point to a buffer of as
many bytes as the size of the specified piece. See
<a class="reference external" href="reference-Storage.html#piece_size()">file_storage::piece_size()</a>.</p>
<p>The data in the buffer is copied and passed on to the disk IO thread
to be written at a later point.</p>
<p>The overload taking a <tt class="docutils literal"><span class="pre">std::vector&lt;char&gt;</span></tt> is not blocking, it will
send the buffer to the main thread and return immediately.</p>
<a name="read_piece()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bread_piece%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bread_piece%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="read-piece">
<h2>read_piece()</h2>
<pre class="literal-block">
void <strong>read_piece</strong> (piece_index_t piece) const;
</pre>
<p>This function starts an asynchronous read operation of the specified
piece from this torrent. You must have completed the download of the
specified piece before calling this function.</p>
<p>When the read operation is completed, it is passed back through an
<a class="reference external" href="reference-Alerts.html#alert">alert</a>, <a class="reference external" href="reference-Alerts.html#read_piece_alert">read_piece_alert</a>. Since this <a class="reference external" href="reference-Alerts.html#alert">alert</a> is a response to an explicit
call, it will always be posted, regardless of the <a class="reference external" href="reference-Alerts.html#alert">alert</a> mask.</p>
<p>Note that if you read multiple pieces, the read operations are not
guaranteed to finish in the same order as you initiated them.</p>
<a name="have_piece()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bhave_piece%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bhave_piece%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="have-piece">
<h2>have_piece()</h2>
<pre class="literal-block">
bool <strong>have_piece</strong> (piece_index_t piece) const;
</pre>
<p>Returns true if this piece has been completely downloaded and written
to disk, and false otherwise.</p>
<a name="post_peer_info()"></a>
<a name="get_peer_info()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bpost_peer_info%28%29+get_peer_info%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bpost_peer_info%28%29+get_peer_info%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="post-peer-info-get-peer-info">
<h2>post_peer_info() get_peer_info()</h2>
<pre class="literal-block">
void <strong>get_peer_info</strong> (std::vector&lt;peer_info&gt;&amp; v) const;
void <strong>post_peer_info</strong> () const;
</pre>
<p>Query information about connected peers for this torrent. If the
<a class="reference external" href="reference-Torrent_Handle.html#torrent_handle">torrent_handle</a> is invalid, it will throw a system_error exception.</p>
<p><tt class="docutils literal">post_peer_info()</tt> is asynchronous and will trigger the posting of
a <a class="reference external" href="reference-Alerts.html#peer_info_alert">peer_info_alert</a>. The <a class="reference external" href="reference-Alerts.html#alert">alert</a> contain a list of <a class="reference external" href="reference-Core.html#peer_info">peer_info</a> objects, one
for each connected peer.</p>
<p><tt class="docutils literal">get_peer_info()</tt> is synchronous and takes a reference to a vector
that will be cleared and filled with one <a class="reference external" href="reference-Bencoding.html#entry">entry</a> for each peer
connected to this torrent, given the handle is valid. Each <a class="reference external" href="reference-Bencoding.html#entry">entry</a> in
the vector contains information about that particular peer. See
<a class="reference external" href="reference-Core.html#peer_info">peer_info</a>.</p>
<a name="post_status()"></a>
<a name="status()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bpost_status%28%29+status%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bpost_status%28%29+status%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="post-status-status">
<h2>post_status() status()</h2>
<pre class="literal-block">
void <strong>post_status</strong> (status_flags_t flags = status_flags_t::all()) const;
torrent_status <strong>status</strong> (status_flags_t flags = status_flags_t::all()) const;
</pre>
<p><tt class="docutils literal">status()</tt> will return a structure with information about the status
of this torrent. If the <a class="reference external" href="reference-Torrent_Handle.html#torrent_handle">torrent_handle</a> is invalid, it will throw
system_error exception. See <a class="reference external" href="reference-Torrent_Status.html#torrent_status">torrent_status</a>. The <tt class="docutils literal">flags</tt>
argument filters what information is returned in the <a class="reference external" href="reference-Torrent_Status.html#torrent_status">torrent_status</a>.
Some information in there is relatively expensive to calculate, and if
you're not interested in it (and see performance issues), you can
filter them out.</p>
<p>The <tt class="docutils literal">status()</tt> function will block until the internal libtorrent
thread responds with the <a class="reference external" href="reference-Torrent_Status.html#torrent_status">torrent_status</a> object. To avoid blocking,
instead call <tt class="docutils literal">post_status()</tt>. It will trigger posting of a
<a class="reference external" href="reference-Alerts.html#state_update_alert">state_update_alert</a> with a single <a class="reference external" href="reference-Torrent_Status.html#torrent_status">torrent_status</a> object for this
torrent.</p>
<p>In order to get regular updates for torrents whose status changes,
consider calling session::post_torrent_updates()`` instead.</p>
<p>By default everything is included. The flags you can use to decide
what to <em>include</em> are defined in this class.</p>
<a name="post_download_queue()"></a>
<a name="get_download_queue()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bpost_download_queue%28%29+get_download_queue%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bpost_download_queue%28%29+get_download_queue%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="post-download-queue-get-download-queue">
<h2>post_download_queue() get_download_queue()</h2>
<pre class="literal-block">
void <strong>post_download_queue</strong> () const;
std::vector&lt;partial_piece_info&gt; <strong>get_download_queue</strong> () const;
void <strong>get_download_queue</strong> (std::vector&lt;partial_piece_info&gt;&amp; queue) const;
</pre>
<p><tt class="docutils literal">post_download_queue()</tt> triggers a download_queue_alert to be
posted.
<tt class="docutils literal">get_download_queue()</tt> is a synchronous call and returns a vector
with information about pieces that are partially downloaded or not
downloaded but partially requested. See <a class="reference external" href="reference-Torrent_Handle.html#partial_piece_info">partial_piece_info</a> for the
fields in the returned vector.</p>
<a name="clear_piece_deadlines()"></a>
<a name="reset_piece_deadline()"></a>
<a name="set_piece_deadline()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bclear_piece_deadlines%28%29+reset_piece_deadline%28%29+set_piece_deadline%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bclear_piece_deadlines%28%29+reset_piece_deadline%28%29+set_piece_deadline%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="clear-piece-deadlines-reset-piece-deadline-set-piece-deadline">
<h2>clear_piece_deadlines() reset_piece_deadline() set_piece_deadline()</h2>
<pre class="literal-block">
void <strong>set_piece_deadline</strong> (piece_index_t index, int deadline, deadline_flags_t flags = {}) const;
void <strong>clear_piece_deadlines</strong> () const;
void <strong>reset_piece_deadline</strong> (piece_index_t index) const;
</pre>
<p>This function sets or resets the deadline associated with a specific
piece index (<tt class="docutils literal">index</tt>). libtorrent will attempt to download this
entire piece before the deadline expires. This is not necessarily
possible, but pieces with a more recent deadline will always be
prioritized over pieces with a deadline further ahead in time. The
deadline (and flags) of a piece can be changed by calling this
function again.</p>
<p>If the piece is already downloaded when this call is made, nothing
happens, unless the alert_when_available flag is set, in which case it
will have the same effect as calling <a class="reference external" href="reference-Torrent_Handle.html#read_piece()">read_piece()</a> for <tt class="docutils literal">index</tt>.</p>
<p><tt class="docutils literal">deadline</tt> is the number of milliseconds until this piece should be
completed.</p>
<p><tt class="docutils literal">reset_piece_deadline</tt> removes the deadline from the piece. If it
hasn't already been downloaded, it will no longer be considered a
priority.</p>
<p><tt class="docutils literal">clear_piece_deadlines()</tt> removes deadlines on all pieces in
the torrent. As if <a class="reference external" href="reference-Torrent_Handle.html#reset_piece_deadline()">reset_piece_deadline()</a> was called on all pieces.</p>
<a name="post_file_progress()"></a>
<a name="file_progress()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bpost_file_progress%28%29+file_progress%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bpost_file_progress%28%29+file_progress%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="post-file-progress-file-progress">
<h2>post_file_progress() file_progress()</h2>
<pre class="literal-block">
void <strong>post_file_progress</strong> (file_progress_flags_t flags) const;
std::vector&lt;std::int64_t&gt; <strong>file_progress</strong> (file_progress_flags_t flags = {}) const;
void <strong>file_progress</strong> (std::vector&lt;std::int64_t&gt;&amp; progress, file_progress_flags_t flags = {}) const;
</pre>
<p>This function fills in the supplied vector, or returns a vector, with
the number of bytes downloaded of each file in this torrent. The
progress values are ordered the same as the files in the
<a class="reference external" href="reference-Torrent_Info.html#torrent_info">torrent_info</a>.</p>
<p>This operation is not very cheap. Its complexity is <em>O(n + mj)</em>.
Where <em>n</em> is the number of files, <em>m</em> is the number of currently
downloading pieces and <em>j</em> is the number of blocks in a piece.</p>
<p>The <tt class="docutils literal">flags</tt> parameter can be used to specify the granularity of the
file progress. If left at the default value of 0, the progress will be
as accurate as possible, but also more expensive to calculate. If
<tt class="docutils literal"><span class="pre">torrent_handle::piece_granularity</span></tt> is specified, the progress will
be specified in piece granularity. i.e. only pieces that have been
fully downloaded and passed the hash check count. When specifying
piece granularity, the operation is a lot cheaper, since libtorrent
already keeps track of this internally and no calculation is required.</p>
<a name="file_status()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bfile_status%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bfile_status%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="file-status">
<h2>file_status()</h2>
<pre class="literal-block">
std::vector&lt;open_file_state&gt; <strong>file_status</strong> () const;
</pre>
<p>This function returns a vector with status about files
that are open for this torrent. Any file that is not open
will not be reported in the vector, i.e. it's possible that
the vector is empty when returning, if none of the files in the
torrent are currently open.</p>
<p>See <a class="reference external" href="reference-Custom_Storage.html#open_file_state">open_file_state</a></p>
<a name="clear_error()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bclear_error%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bclear_error%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="clear-error">
<h2>clear_error()</h2>
<pre class="literal-block">
void <strong>clear_error</strong> () const;
</pre>
<p>If the torrent is in an error state (i.e. <tt class="docutils literal"><span class="pre">torrent_status::error</span></tt> is
non-empty), this will clear the error and start the torrent again.</p>
<a name="trackers()"></a>
<a name="replace_trackers()"></a>
<a name="post_trackers()"></a>
<a name="add_tracker()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Btrackers%28%29+replace_trackers%28%29+post_trackers%28%29+add_tracker%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Btrackers%28%29+replace_trackers%28%29+post_trackers%28%29+add_tracker%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="trackers-replace-trackers-post-trackers-add-tracker">
<h2>trackers() replace_trackers() post_trackers() add_tracker()</h2>
<pre class="literal-block">
void <strong>post_trackers</strong> () const;
std::vector&lt;announce_entry&gt; <strong>trackers</strong> () const;
void <strong>replace_trackers</strong> (std::vector&lt;announce_entry&gt; const&amp;) const;
void <strong>add_tracker</strong> (announce_entry const&amp;) const;
</pre>
<p><tt class="docutils literal">trackers()</tt> returns the list of trackers for this torrent. The
announce <a class="reference external" href="reference-Bencoding.html#entry">entry</a> contains both a string <tt class="docutils literal">url</tt> which specify the
announce url for the tracker as well as an <a class="reference external" href="reference-Core.html#int">int</a> <tt class="docutils literal">tier</tt>, which is
specifies the order in which this tracker is tried. If you want
libtorrent to use another list of trackers for this torrent, you can
use <tt class="docutils literal">replace_trackers()</tt> which takes a list of the same form as the
one returned from <tt class="docutils literal">trackers()</tt> and will replace it. If you want an
immediate effect, you have to call <a class="reference external" href="reference-Torrent_Handle.html#force_reannounce()">force_reannounce()</a>. See
<a class="reference external" href="reference-Trackers.html#announce_entry">announce_entry</a>.</p>
<p><tt class="docutils literal">post_trackers()</tt> is the asynchronous version of <tt class="docutils literal">trackers()</tt>. It
will trigger a <a class="reference external" href="reference-Alerts.html#tracker_list_alert">tracker_list_alert</a> to be posted.</p>
<p><tt class="docutils literal">add_tracker()</tt> will look if the specified tracker is already in the
set. If it is, it doesn't do anything. If it's not in the current set
of trackers, it will insert it in the tier specified in the
<a class="reference external" href="reference-Trackers.html#announce_entry">announce_entry</a>.</p>
<p>The updated set of trackers will be saved in the resume data, and when
a torrent is started with resume data, the trackers from the resume
data will replace the original ones.</p>
<a name="add_url_seed()"></a>
<a name="remove_url_seed()"></a>
<a name="url_seeds()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Badd_url_seed%28%29+remove_url_seed%28%29+url_seeds%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Badd_url_seed%28%29+remove_url_seed%28%29+url_seeds%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="add-url-seed-remove-url-seed-url-seeds">
<h2>add_url_seed() remove_url_seed() url_seeds()</h2>
<pre class="literal-block">
void <strong>add_url_seed</strong> (std::string const&amp; url) const;
std::set&lt;std::string&gt; <strong>url_seeds</strong> () const;
void <strong>remove_url_seed</strong> (std::string const&amp; url) const;
</pre>
<p><tt class="docutils literal">add_url_seed()</tt> adds another url to the torrent's list of url
seeds. If the given url already exists in that list, the call has no
effect. The torrent will connect to the server and try to download
pieces from it, unless it's paused, queued, checking or seeding.
<tt class="docutils literal">remove_url_seed()</tt> removes the given url if it exists already.
<tt class="docutils literal">url_seeds()</tt> return a set of the url seeds currently in this
torrent. Note that URLs that fails may be removed automatically from
the list.</p>
<p>See <a class="reference external" href="manual-ref.html#http-seeding">http seeding</a> for more information.</p>
<a name="remove_http_seed()"></a>
<a name="add_http_seed()"></a>
<a name="http_seeds()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bremove_http_seed%28%29+add_http_seed%28%29+http_seeds%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bremove_http_seed%28%29+add_http_seed%28%29+http_seeds%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="remove-http-seed-add-http-seed-http-seeds">
<h2>remove_http_seed() add_http_seed() http_seeds()</h2>
<pre class="literal-block">
std::set&lt;std::string&gt; <strong>http_seeds</strong> () const;
void <strong>remove_http_seed</strong> (std::string const&amp; url) const;
void <strong>add_http_seed</strong> (std::string const&amp; url) const;
</pre>
<p>These functions are identical as the <tt class="docutils literal">*_url_seed()</tt> variants, but
they operate on <a class="reference external" href="https://www.bittorrent.org/beps/bep_0017.html">BEP 17</a> web seeds instead of <a class="reference external" href="https://www.bittorrent.org/beps/bep_0019.html">BEP 19</a>.</p>
<p>See <a class="reference external" href="manual-ref.html#http-seeding">http seeding</a> for more information.</p>
<a name="add_extension()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Badd_extension%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Badd_extension%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="add-extension">
<h2>add_extension()</h2>
<pre class="literal-block">
void <strong>add_extension</strong> (
      std::function&lt;std::shared_ptr&lt;torrent_plugin&gt;(torrent_handle const&amp;, client_data_t)&gt; const&amp; ext
      , client_data_t userdata = client_data_t{});
</pre>
<p>add the specified extension to this torrent. The <tt class="docutils literal">ext</tt> argument is
a function that will be called from within libtorrent's context
passing in the internal torrent object and the specified userdata
pointer. The function is expected to return a shared pointer to
a <a class="reference external" href="reference-Plugins.html#torrent_plugin">torrent_plugin</a> instance.</p>
<a name="set_metadata()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bset_metadata%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bset_metadata%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="set-metadata">
<h2>set_metadata()</h2>
<pre class="literal-block">
bool <strong>set_metadata</strong> (span&lt;char const&gt; metadata) const;
</pre>
<p><tt class="docutils literal">set_metadata</tt> expects the <em>info</em> section of metadata. i.e. The
buffer passed in will be hashed and verified against the info-hash. If
it fails, a <tt class="docutils literal">metadata_failed_alert</tt> will be generated. If it passes,
a <tt class="docutils literal">metadata_received_alert</tt> is generated. The function returns true
if the metadata is successfully set on the torrent, and false
otherwise. If the torrent already has metadata, this function will not
affect the torrent, and false will be returned.</p>
<a name="is_valid()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bis_valid%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bis_valid%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="is-valid">
<h2>is_valid()</h2>
<pre class="literal-block">
bool <strong>is_valid</strong> () const;
</pre>
<p>Returns true if this handle refers to a valid torrent and false if it
hasn't been initialized or if the torrent it refers to has been
removed from the <a class="reference external" href="reference-Session.html#session">session</a> AND destructed.</p>
<p>To tell if the <a class="reference external" href="reference-Torrent_Handle.html#torrent_handle">torrent_handle</a> is in the <a class="reference external" href="reference-Session.html#session">session</a>, use
<a class="reference external" href="reference-Torrent_Handle.html#in_session()">torrent_handle::in_session()</a>. This will return true before
<a class="reference external" href="reference-Session.html#remove_torrent()">session_handle::remove_torrent()</a> is called, and false
afterward.</p>
<p>Clients should only use <a class="reference external" href="reference-Torrent_Info.html#is_valid()">is_valid()</a> to determine if the result of
session::find_torrent() was successful.</p>
<p>Unlike other member functions which return a value, <a class="reference external" href="reference-Torrent_Info.html#is_valid()">is_valid()</a>
completes immediately, without blocking on a result from the
network thread. Also unlike other functions, it never throws
the system_error exception.</p>
<a name="resume()"></a>
<a name="pause()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bresume%28%29+pause%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bresume%28%29+pause%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="resume-pause">
<h2>resume() pause()</h2>
<pre class="literal-block">
void <strong>resume</strong> () const;
void <strong>pause</strong> (pause_flags_t flags = {}) const;
</pre>
<p><tt class="docutils literal">pause()</tt>, and <tt class="docutils literal">resume()</tt> will disconnect all peers and reconnect
all peers respectively. When a torrent is paused, it will however
remember all share ratios to all peers and remember all potential (not
connected) peers. Torrents may be paused automatically if there is a
file error (e.g. disk full) or something similar. See
<a class="reference external" href="reference-Alerts.html#file_error_alert">file_error_alert</a>.</p>
<p>For possible values of the <tt class="docutils literal">flags</tt> parameter, see pause_flags_t.</p>
<p>To know if a torrent is paused or not, call
<tt class="docutils literal"><span class="pre">torrent_handle::flags()</span></tt> and check for the
<tt class="docutils literal"><span class="pre">torrent_status::paused</span></tt> flag.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Torrents that are auto-managed may be automatically resumed again. It
does not make sense to pause an auto-managed torrent without making it
not auto-managed first. Torrents are auto-managed by default when added
to the <a class="reference external" href="reference-Session.html#session">session</a>. For more information, see <a class="reference external" href="manual-ref.html#queuing">queuing</a>.</p>
</div>
<a name="unset_flags()"></a>
<a name="set_flags()"></a>
<a name="flags()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bunset_flags%28%29+set_flags%28%29+flags%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bunset_flags%28%29+set_flags%28%29+flags%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="unset-flags-set-flags-flags">
<h2>unset_flags() set_flags() flags()</h2>
<pre class="literal-block">
void <strong>unset_flags</strong> (torrent_flags_t flags) const;
torrent_flags_t <strong>flags</strong> () const;
void <strong>set_flags</strong> (torrent_flags_t flags) const;
void <strong>set_flags</strong> (torrent_flags_t flags, torrent_flags_t mask) const;
</pre>
<p>sets and gets the torrent state flags. See <a class="reference external" href="reference-Core.html#torrent_flags_t">torrent_flags_t</a>.
The <tt class="docutils literal">set_flags</tt> overload that take a mask will affect all
flags part of the mask, and set their values to what the
<tt class="docutils literal">flags</tt> argument is set to. This allows clearing and
setting flags in a single function call.
The <tt class="docutils literal">set_flags</tt> overload that just takes flags, sets all
the specified flags and leave any other flags unchanged.
<tt class="docutils literal">unset_flags</tt> clears the specified flags, while leaving
any other flags unchanged.</p>
<p>The <cite>seed_mode</cite> flag is special, it can only be cleared once the
torrent has been added, and it can only be set as part of the
<a class="reference external" href="reference-Add_Torrent.html#add_torrent_params">add_torrent_params</a> flags, when adding the torrent.</p>
<a name="flush_cache()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bflush_cache%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bflush_cache%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="flush-cache">
<h2>flush_cache()</h2>
<pre class="literal-block">
void <strong>flush_cache</strong> () const;
</pre>
<p>Instructs libtorrent to flush all the disk caches for this torrent and
close all file handles. This is done asynchronously and you will be
notified that it's complete through <a class="reference external" href="reference-Alerts.html#cache_flushed_alert">cache_flushed_alert</a>.</p>
<p>Note that by the time you get the <a class="reference external" href="reference-Alerts.html#alert">alert</a>, libtorrent may have cached
more data for the torrent, but you are guaranteed that whatever cached
data libtorrent had by the time you called
<tt class="docutils literal"><span class="pre">torrent_handle::flush_cache()</span></tt> has been written to disk.</p>
<a name="force_recheck()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bforce_recheck%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bforce_recheck%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="force-recheck">
<h2>force_recheck()</h2>
<pre class="literal-block">
void <strong>force_recheck</strong> () const;
</pre>
<p><tt class="docutils literal">force_recheck</tt> puts the torrent back in a state where it assumes to
have no resume data. All peers will be disconnected and the torrent
will stop announcing to the tracker. The torrent will be added to the
checking queue, and will be checked (all the files will be read and
compared to the piece hashes). Once the check is complete, the torrent
will start connecting to peers again, as normal.
The torrent will be placed last in queue, i.e. its queue position
will be the highest of all torrents in the <a class="reference external" href="reference-Session.html#session">session</a>.</p>
<a name="save_resume_data()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bsave_resume_data%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bsave_resume_data%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="save-resume-data">
<h2>save_resume_data()</h2>
<pre class="literal-block">
void <strong>save_resume_data</strong> (resume_data_flags_t flags = {}) const;
</pre>
<p><tt class="docutils literal">save_resume_data()</tt> asks libtorrent to generate fast-resume data for
this torrent. The fast resume data (stored in an <a class="reference external" href="reference-Add_Torrent.html#add_torrent_params">add_torrent_params</a>
object) can be used to resume a torrent in the next <a class="reference external" href="reference-Session.html#session">session</a> without
having to check all files for which pieces have been downloaded. It
can also be used to save a .torrent file for a <a class="reference external" href="reference-Torrent_Handle.html#torrent_handle">torrent_handle</a>.</p>
<p>This operation is asynchronous, <tt class="docutils literal">save_resume_data</tt> will return
immediately. The resume data is delivered when it's done through a
<a class="reference external" href="reference-Alerts.html#save_resume_data_alert">save_resume_data_alert</a>.</p>
<p>The operation will fail, and post a <a class="reference external" href="reference-Alerts.html#save_resume_data_failed_alert">save_resume_data_failed_alert</a>
instead, in the following cases:</p>
<blockquote>
<ol class="arabic simple">
<li>The torrent is in the process of being removed.</li>
<li>No torrent state has changed since the last saving of resume
data, and the only_if_modified flag is set.
metadata (see libtorrent's <a class="reference external" href="manual-ref.html#metadata-from-peers">metadata from peers</a> extension)</li>
</ol>
</blockquote>
<p>Note that some <a class="reference external" href="reference-Stats.html#counters">counters</a> may be outdated by the time you receive the fast resume data</p>
<p>When saving resume data because of shutting down, make sure not to
<a class="reference external" href="reference-Custom_Storage.html#remove_torrent()">remove_torrent()</a> before you receive the <a class="reference external" href="reference-Alerts.html#save_resume_data_alert">save_resume_data_alert</a>.
There's no need to pause the <a class="reference external" href="reference-Session.html#session">session</a> or torrent when saving resume
data.</p>
<p>The paused state of a torrent is saved in the resume data, so pausing
all torrents before saving resume data will all torrents be restored
in a paused state.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It is typically a good idea to save resume data whenever a torrent
is completed or paused. If you save resume data for torrents when they are
paused, you can accelerate the shutdown process by not saving resume
data again for those torrents. Completed torrents should have their
resume data saved when they complete and on exit, since their
statistics might be updated.</p>
</div>
<p>Example code to pause and save resume data for all torrents and wait
for the alerts:</p>
<pre class="code c++ literal-block">
<span class="keyword">extern</span><span class="whitespace"> </span><span class="keyword type">int</span><span class="whitespace"> </span><span class="name">outstanding_resume_data</span><span class="punctuation">;</span><span class="whitespace"> </span><span class="comment single">// global counter of outstanding resume data
</span><span class="name">std</span><span class="operator">::</span><span class="name">vector</span><span class="operator">&lt;</span><span class="name">torrent_handle</span><span class="operator">&gt;</span><span class="whitespace"> </span><span class="name">handles</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">ses</span><span class="punctuation">.</span><span class="name">get_torrents</span><span class="punctuation">();</span><span class="whitespace">
</span><span class="keyword">for</span><span class="whitespace"> </span><span class="punctuation">(</span><span class="name">torrent_handle</span><span class="whitespace"> </span><span class="keyword">const</span><span class="operator">&amp;</span><span class="whitespace"> </span><span class="name">h</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="name">handles</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="keyword">try</span><span class="whitespace">
</span><span class="punctuation">{</span><span class="whitespace">
        </span><span class="name">h</span><span class="punctuation">.</span><span class="name">save_resume_data</span><span class="punctuation">(</span><span class="name">torrent_handle</span><span class="operator">::</span><span class="name">only_if_modified</span><span class="punctuation">);</span><span class="whitespace">
        </span><span class="operator">++</span><span class="name">outstanding_resume_data</span><span class="punctuation">;</span><span class="whitespace">
</span><span class="punctuation">}</span><span class="whitespace">
</span><span class="keyword">catch</span><span class="whitespace"> </span><span class="punctuation">(</span><span class="name">lt</span><span class="operator">::</span><span class="name">system_error</span><span class="whitespace"> </span><span class="keyword">const</span><span class="operator">&amp;</span><span class="whitespace"> </span><span class="name">e</span><span class="punctuation">)</span><span class="whitespace">
</span><span class="punctuation">{</span><span class="whitespace">
        </span><span class="comment single">// the handle was invalid, ignore this one and move to the next
</span><span class="punctuation">}</span><span class="whitespace">

</span><span class="keyword">while</span><span class="whitespace"> </span><span class="punctuation">(</span><span class="name">outstanding_resume_data</span><span class="whitespace"> </span><span class="operator">&gt;</span><span class="whitespace"> </span><span class="literal number integer">0</span><span class="punctuation">)</span><span class="whitespace">
</span><span class="punctuation">{</span><span class="whitespace">
        </span><span class="name">alert</span><span class="whitespace"> </span><span class="keyword">const</span><span class="operator">*</span><span class="whitespace"> </span><span class="name">a</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">ses</span><span class="punctuation">.</span><span class="name">wait_for_alert</span><span class="punctuation">(</span><span class="name">seconds</span><span class="punctuation">(</span><span class="literal number integer">30</span><span class="punctuation">));</span><span class="whitespace">

        </span><span class="comment single">// if we don't get an alert within 30 seconds, abort
</span><span class="whitespace">        </span><span class="keyword">if</span><span class="whitespace"> </span><span class="punctuation">(</span><span class="name">a</span><span class="whitespace"> </span><span class="operator">==</span><span class="whitespace"> </span><span class="keyword">nullptr</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="keyword">break</span><span class="punctuation">;</span><span class="whitespace">

        </span><span class="name">std</span><span class="operator">::</span><span class="name">vector</span><span class="operator">&lt;</span><span class="name">alert</span><span class="operator">*&gt;</span><span class="whitespace"> </span><span class="name">alerts</span><span class="punctuation">;</span><span class="whitespace">
        </span><span class="name">ses</span><span class="punctuation">.</span><span class="name">pop_alerts</span><span class="punctuation">(</span><span class="operator">&amp;</span><span class="name">alerts</span><span class="punctuation">);</span><span class="whitespace">

        </span><span class="keyword">for</span><span class="whitespace"> </span><span class="punctuation">(</span><span class="name">alert</span><span class="operator">*</span><span class="whitespace"> </span><span class="name">i</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="name">alerts</span><span class="punctuation">)</span><span class="whitespace">
        </span><span class="punctuation">{</span><span class="whitespace">
                </span><span class="keyword">if</span><span class="whitespace"> </span><span class="punctuation">(</span><span class="name">alert_cast</span><span class="operator">&lt;</span><span class="name">save_resume_data_failed_alert</span><span class="operator">&gt;</span><span class="punctuation">(</span><span class="name">i</span><span class="punctuation">))</span><span class="whitespace">
                </span><span class="punctuation">{</span><span class="whitespace">
                        </span><span class="name">process_alert</span><span class="punctuation">(</span><span class="name">i</span><span class="punctuation">);</span><span class="whitespace">
                        </span><span class="operator">--</span><span class="name">outstanding_resume_data</span><span class="punctuation">;</span><span class="whitespace">
                        </span><span class="keyword">continue</span><span class="punctuation">;</span><span class="whitespace">
                </span><span class="punctuation">}</span><span class="whitespace">

                </span><span class="name">save_resume_data_alert</span><span class="whitespace"> </span><span class="keyword">const</span><span class="operator">*</span><span class="whitespace"> </span><span class="name">rd</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">alert_cast</span><span class="operator">&lt;</span><span class="name">save_resume_data_alert</span><span class="operator">&gt;</span><span class="punctuation">(</span><span class="name">i</span><span class="punctuation">);</span><span class="whitespace">
                </span><span class="keyword">if</span><span class="whitespace"> </span><span class="punctuation">(</span><span class="name">rd</span><span class="whitespace"> </span><span class="operator">==</span><span class="whitespace"> </span><span class="keyword">nullptr</span><span class="punctuation">)</span><span class="whitespace">
                </span><span class="punctuation">{</span><span class="whitespace">
                        </span><span class="name">process_alert</span><span class="punctuation">(</span><span class="name">i</span><span class="punctuation">);</span><span class="whitespace">
                        </span><span class="keyword">continue</span><span class="punctuation">;</span><span class="whitespace">
                </span><span class="punctuation">}</span><span class="whitespace">

                </span><span class="name">std</span><span class="operator">::</span><span class="name">ofstream</span><span class="whitespace"> </span><span class="name">out</span><span class="punctuation">((</span><span class="name">rd</span><span class="operator">-&gt;</span><span class="name">params</span><span class="punctuation">.</span><span class="name">save_path</span><span class="whitespace">
                        </span><span class="operator">+</span><span class="whitespace"> </span><span class="literal string">&quot;/&quot;</span><span class="whitespace"> </span><span class="operator">+</span><span class="whitespace"> </span><span class="name">rd</span><span class="operator">-&gt;</span><span class="name">params</span><span class="punctuation">.</span><span class="name">name</span><span class="whitespace"> </span><span class="operator">+</span><span class="whitespace"> </span><span class="literal string">&quot;.fastresume&quot;</span><span class="punctuation">).</span><span class="name">c_str</span><span class="punctuation">()</span><span class="whitespace">
                        </span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">std</span><span class="operator">::</span><span class="name">ios_base</span><span class="operator">::</span><span class="name">binary</span><span class="punctuation">);</span><span class="whitespace">
                </span><span class="name">std</span><span class="operator">::</span><span class="name">vector</span><span class="operator">&lt;</span><span class="keyword type">char</span><span class="operator">&gt;</span><span class="whitespace"> </span><span class="name">buf</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">write_resume_data_buf</span><span class="punctuation">(</span><span class="name">rd</span><span class="operator">-&gt;</span><span class="name">params</span><span class="punctuation">);</span><span class="whitespace">
                </span><span class="name">out</span><span class="punctuation">.</span><span class="name">write</span><span class="punctuation">(</span><span class="name">buf</span><span class="punctuation">.</span><span class="name">data</span><span class="punctuation">(),</span><span class="whitespace"> </span><span class="name">buf</span><span class="punctuation">.</span><span class="name">size</span><span class="punctuation">());</span><span class="whitespace">
                </span><span class="operator">--</span><span class="name">outstanding_resume_data</span><span class="punctuation">;</span><span class="whitespace">
        </span><span class="punctuation">}</span><span class="whitespace">
</span><span class="punctuation">}</span>
</pre>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Note how <tt class="docutils literal">outstanding_resume_data</tt> is a global counter in this
example. This is deliberate, otherwise there is a race condition for
torrents that was just asked to save their resume data, they posted
the <a class="reference external" href="reference-Alerts.html#alert">alert</a>, but it has not been received yet. Those torrents would
report that they don't need to save resume data again, and skipped by
the initial loop, and thwart the counter otherwise.</p>
</div>
<a name="need_save_resume_data()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bneed_save_resume_data%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bneed_save_resume_data%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="need-save-resume-data">
<h2>need_save_resume_data()</h2>
<pre class="literal-block">
bool <strong>need_save_resume_data</strong> () const;
bool <strong>need_save_resume_data</strong> (resume_data_flags_t flags) const;
</pre>
<p>This function returns true if anything that is stored in the resume
data has changed since the last time resume data was saved.
The overload that takes <tt class="docutils literal">flags</tt> let you ask if specific categories
of properties have changed. These flags have the same behavior as in
the <a class="reference external" href="reference-Torrent_Handle.html#save_resume_data()">save_resume_data()</a> call.</p>
<p>This is a <em>blocking</em> call. It will wait for a response from
libtorrent's main thread. A way to avoid blocking is to instead
call <a class="reference external" href="reference-Torrent_Handle.html#save_resume_data()">save_resume_data()</a> directly, specifying the conditions under
which resume data should be saved.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">A torrent's resume data is considered saved as soon as the
<a class="reference external" href="reference-Alerts.html#save_resume_data_alert">save_resume_data_alert</a> is posted. It is important to make sure this
<a class="reference external" href="reference-Alerts.html#alert">alert</a> is received and handled in order for this function to be
meaningful.</p>
</div>
<a name="queue_position_bottom()"></a>
<a name="queue_position_top()"></a>
<a name="queue_position_down()"></a>
<a name="queue_position()"></a>
<a name="queue_position_up()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bqueue_position_bottom%28%29+queue_position_top%28%29+queue_position_down%28%29+queue_position%28%29+queue_position_up%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bqueue_position_bottom%28%29+queue_position_top%28%29+queue_position_down%28%29+queue_position%28%29+queue_position_up%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="queue-position-bottom-queue-position-top-queue-position-down-queue-position-queue-position-up">
<h2>queue_position_bottom() queue_position_top() queue_position_down() queue_position() queue_position_up()</h2>
<pre class="literal-block">
queue_position_t <strong>queue_position</strong> () const;
void <strong>queue_position_bottom</strong> () const;
void <strong>queue_position_down</strong> () const;
void <strong>queue_position_up</strong> () const;
void <strong>queue_position_top</strong> () const;
</pre>
<p>Every torrent that is added is assigned a queue position exactly one
greater than the greatest queue position of all existing torrents.
Torrents that are being seeded have -1 as their queue position, since
they're no longer in line to be downloaded.</p>
<p>When a torrent is removed or turns into a seed, all torrents with
greater queue positions have their positions decreased to fill in the
space in the sequence.</p>
<p><tt class="docutils literal">queue_position()</tt> returns the torrent's position in the download
queue. The torrents with the smallest numbers are the ones that are
being downloaded. The smaller number, the closer the torrent is to the
front of the line to be started.</p>
<p>The queue position is also available in the <a class="reference external" href="reference-Torrent_Status.html#torrent_status">torrent_status</a>.</p>
<p>The <tt class="docutils literal"><span class="pre">queue_position_*()</span></tt> functions adjust the torrents position in
the queue. Up means closer to the front and down means closer to the
back of the queue. Top and bottom refers to the front and the back of
the queue respectively.</p>
<a name="queue_position_set()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bqueue_position_set%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bqueue_position_set%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="queue-position-set">
<h2>queue_position_set()</h2>
<pre class="literal-block">
void <strong>queue_position_set</strong> (queue_position_t p) const;
</pre>
<p>updates the position in the queue for this torrent. The relative order
of all other torrents remain intact but their numerical queue position
shifts to make space for this torrent's new position</p>
<a name="set_ssl_certificate()"></a>
<a name="set_ssl_certificate_buffer()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bset_ssl_certificate%28%29+set_ssl_certificate_buffer%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bset_ssl_certificate%28%29+set_ssl_certificate_buffer%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="set-ssl-certificate-set-ssl-certificate-buffer">
<h2>set_ssl_certificate() set_ssl_certificate_buffer()</h2>
<pre class="literal-block">
void <strong>set_ssl_certificate_buffer</strong> (std::string const&amp; certificate
      , std::string const&amp; private_key
      , std::string const&amp; dh_params);
void <strong>set_ssl_certificate</strong> (std::string const&amp; certificate
      , std::string const&amp; private_key
      , std::string const&amp; dh_params
      , std::string const&amp; passphrase = &quot;&quot;);
</pre>
<p>For SSL torrents, use this to specify a path to a .pem file to use as
this client's certificate. The certificate must be signed by the
certificate in the .torrent file to be valid.</p>
<p>The <a class="reference external" href="reference-Torrent_Handle.html#set_ssl_certificate_buffer()">set_ssl_certificate_buffer()</a> overload takes the actual certificate,
private key and DH params as strings, rather than paths to files.</p>
<p><tt class="docutils literal">cert</tt> is a path to the (signed) certificate in .pem format
corresponding to this torrent.</p>
<p><tt class="docutils literal">private_key</tt> is a path to the private key for the specified
certificate. This must be in .pem format.</p>
<p><tt class="docutils literal">dh_params</tt> is a path to the Diffie-Hellman parameter file, which
needs to be in .pem format. You can generate this file using the
openssl command like this: <tt class="docutils literal">openssl dhparam <span class="pre">-outform</span> PEM <span class="pre">-out</span>
dhparams.pem 512</tt>.</p>
<p><tt class="docutils literal">passphrase</tt> may be specified if the private key is encrypted and
requires a passphrase to be decrypted.</p>
<p>Note that when a torrent first starts up, and it needs a certificate,
it will suspend connecting to any peers until it has one. It's
typically desirable to resume the torrent after setting the SSL
certificate.</p>
<p>If you receive a <a class="reference external" href="reference-Alerts.html#torrent_need_cert_alert">torrent_need_cert_alert</a>, you need to call this to
provide a valid cert. If you don't have a cert you won't be allowed to
connect to any peers.</p>
<a name="torrent_file()"></a>
<a name="torrent_file_with_hashes()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Btorrent_file%28%29+torrent_file_with_hashes%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Btorrent_file%28%29+torrent_file_with_hashes%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="torrent-file-torrent-file-with-hashes">
<h2>torrent_file() torrent_file_with_hashes()</h2>
<pre class="literal-block">
std::shared_ptr&lt;torrent_info&gt; <strong>torrent_file_with_hashes</strong> () const;
std::shared_ptr&lt;const torrent_info&gt; <strong>torrent_file</strong> () const;
</pre>
<p><a class="reference external" href="reference-Torrent_Handle.html#torrent_file()">torrent_file()</a> returns a pointer to the <a class="reference external" href="reference-Torrent_Info.html#torrent_info">torrent_info</a> object
associated with this torrent. The <a class="reference external" href="reference-Torrent_Info.html#torrent_info">torrent_info</a> object may be a copy
of the internal object. If the torrent doesn't have metadata, the
pointer will not be initialized (i.e. a nullptr). The torrent may be
in a state without metadata only if it was started without a .torrent
file, e.g. by being added by magnet link.</p>
<p>Note that the <a class="reference external" href="reference-Torrent_Info.html#torrent_info">torrent_info</a> object returned here may be a different
instance than the one added to the <a class="reference external" href="reference-Session.html#session">session</a>, with different attributes
like piece layers, dht nodes and trackers. A <a class="reference external" href="reference-Torrent_Info.html#torrent_info">torrent_info</a> object does
not round-trip cleanly when added to a <a class="reference external" href="reference-Session.html#session">session</a>.</p>
<p>If you want to save a .torrent file from the <a class="reference external" href="reference-Torrent_Handle.html#torrent_handle">torrent_handle</a>, instead
call <a class="reference external" href="reference-Torrent_Handle.html#save_resume_data()">save_resume_data()</a> and <a class="reference external" href="reference-Resume_Data.html#write_torrent_file()">write_torrent_file()</a> the
<a class="reference external" href="reference-Add_Torrent.html#add_torrent_params">add_torrent_params</a> object passed back in the <a class="reference external" href="reference-Alerts.html#alert">alert</a>.</p>
<p><a class="reference external" href="reference-Torrent_Handle.html#torrent_file_with_hashes()">torrent_file_with_hashes()</a> returns a <em>copy</em> of the internal
<a class="reference external" href="reference-Torrent_Info.html#torrent_info">torrent_info</a> and piece layer hashes (if it's a v2 torrent). The piece
layers will only be included if they are available. If this torrent
was added from a .torrent file with piece layers or if it's seeding,
the piece layers are available. This function is more expensive than
<a class="reference external" href="reference-Torrent_Handle.html#torrent_file()">torrent_file()</a> since it needs to make copies of this information.</p>
<p>The <a class="reference external" href="reference-Torrent_Handle.html#torrent_file_with_hashes()">torrent_file_with_hashes()</a> is here for backwards compatibility
when constructing a <a class="reference external" href="reference-Create_Torrents.html#create_torrent">create_torrent</a> object from a <a class="reference external" href="reference-Torrent_Info.html#torrent_info">torrent_info</a> that's
in a <a class="reference external" href="reference-Session.html#session">session</a>. Prefer <a class="reference external" href="reference-Torrent_Handle.html#save_resume_data()">save_resume_data()</a> + <a class="reference external" href="reference-Resume_Data.html#write_torrent_file()">write_torrent_file()</a>.</p>
<p>Note that a torrent added from a magnet link may not have the full
merkle trees for all files, and hence not have the complete piece
layers. In that state, you cannot create a .torrent file even from
the <a class="reference external" href="reference-Torrent_Info.html#torrent_info">torrent_info</a> returned from <a class="reference external" href="reference-Torrent_Handle.html#torrent_file_with_hashes()">torrent_file_with_hashes()</a>. Once the
torrent completes downloading all files, becoming a seed, you can
make a .torrent file from it.</p>
<a name="piece_layers()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bpiece_layers%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bpiece_layers%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="piece-layers">
<h2>piece_layers()</h2>
<pre class="literal-block">
std::vector&lt;std::vector&lt;sha256_hash&gt;&gt; <strong>piece_layers</strong> () const;
</pre>
<p>returns the piece layers for all files in the torrent. If this is a
v1 torrent (and doesn't have any piece layers) it returns an empty
vector. This is a blocking call that will synchronize with the
libtorrent network thread.</p>
<a name="post_piece_availability()"></a>
<a name="piece_availability()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bpost_piece_availability%28%29+piece_availability%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bpost_piece_availability%28%29+piece_availability%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="post-piece-availability-piece-availability">
<h2>post_piece_availability() piece_availability()</h2>
<pre class="literal-block">
void <strong>piece_availability</strong> (std::vector&lt;int&gt;&amp; avail) const;
void <strong>post_piece_availability</strong> () const;
</pre>
<p>The piece availability is the number of peers that we are connected
that has advertised having a particular piece. This is the information
that libtorrent uses in order to prefer picking rare pieces.</p>
<p><tt class="docutils literal">post_piece_availability()</tt> will trigger a <a class="reference external" href="reference-Alerts.html#piece_availability_alert">piece_availability_alert</a>
to be posted.</p>
<p><tt class="docutils literal">piece_availability()</tt> fills the specified <tt class="docutils literal"><span class="pre">std::vector&lt;int&gt;</span></tt>
with the availability for each piece in this torrent. libtorrent does
not keep track of availability for seeds, so if the torrent is
seeding the availability for all pieces is reported as 0.</p>
<a name="prioritize_pieces()"></a>
<a name="piece_priority()"></a>
<a name="get_piece_priorities()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bprioritize_pieces%28%29+piece_priority%28%29+get_piece_priorities%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bprioritize_pieces%28%29+piece_priority%28%29+get_piece_priorities%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="prioritize-pieces-piece-priority-get-piece-priorities">
<h2>prioritize_pieces() piece_priority() get_piece_priorities()</h2>
<pre class="literal-block">
void <strong>piece_priority</strong> (piece_index_t index, download_priority_t priority) const;
void <strong>prioritize_pieces</strong> (std::vector&lt;download_priority_t&gt; const&amp; pieces) const;
download_priority_t <strong>piece_priority</strong> (piece_index_t index) const;
std::vector&lt;download_priority_t&gt; <strong>get_piece_priorities</strong> () const;
void <strong>prioritize_pieces</strong> (std::vector&lt;std::pair&lt;piece_index_t, download_priority_t&gt;&gt; const&amp; pieces) const;
</pre>
<p>These functions are used to set and get the priority of individual
pieces. By default all pieces have priority 4. That means that the
random rarest first algorithm is effectively active for all pieces.
You may however change the priority of individual pieces. There are 8
priority levels. 0 means not to download the piece at all. Otherwise,
lower priority values means less likely to be picked. Piece priority
takes precedence over piece availability. Every piece with priority 7
will be attempted to be picked before a priority 6 piece and so on.</p>
<p>The default priority of pieces is 4.</p>
<p>Piece priorities can not be changed for torrents that have not
downloaded the metadata yet. Magnet links won't have metadata
immediately. see the <a class="reference external" href="reference-Alerts.html#metadata_received_alert">metadata_received_alert</a>.</p>
<p><tt class="docutils literal">piece_priority</tt> sets or gets the priority for an individual piece,
specified by <tt class="docutils literal">index</tt>.</p>
<p><tt class="docutils literal">prioritize_pieces</tt> takes a vector of integers, one integer per
piece in the torrent. All the piece priorities will be updated with
the priorities in the vector.
The second overload of <tt class="docutils literal">prioritize_pieces</tt> that takes a vector of pairs
will update the priorities of only select pieces, and leave all other
unaffected. Each pair is (piece, priority). That is, the first item is
the piece index and the second item is the priority of that piece.
Invalid entries, where the piece index or priority is out of range, are
not allowed.</p>
<p><tt class="docutils literal">get_piece_priorities</tt> returns a vector with one element for each piece
in the torrent. Each element is the current priority of that piece.</p>
<p>It's possible to cancel the effect of <em>file</em> priorities by setting the
priorities for the affected pieces. Care has to be taken when mixing
usage of file- and piece priorities.</p>
<a name="file_priority()"></a>
<a name="prioritize_files()"></a>
<a name="get_file_priorities()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bfile_priority%28%29+prioritize_files%28%29+get_file_priorities%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bfile_priority%28%29+prioritize_files%28%29+get_file_priorities%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="file-priority-prioritize-files-get-file-priorities">
<h2>file_priority() prioritize_files() get_file_priorities()</h2>
<pre class="literal-block">
download_priority_t <strong>file_priority</strong> (file_index_t index) const;
std::vector&lt;download_priority_t&gt; <strong>get_file_priorities</strong> () const;
void <strong>file_priority</strong> (file_index_t index, download_priority_t priority) const;
void <strong>prioritize_files</strong> (std::vector&lt;download_priority_t&gt; const&amp; files) const;
</pre>
<p><tt class="docutils literal">index</tt> must be in the range [0, number_of_files).</p>
<p><tt class="docutils literal">file_priority()</tt> queries or sets the priority of file <tt class="docutils literal">index</tt>.</p>
<p><tt class="docutils literal">prioritize_files()</tt> takes a vector that has at as many elements as
there are files in the torrent. Each <a class="reference external" href="reference-Bencoding.html#entry">entry</a> is the priority of that
file. The function sets the priorities of all the pieces in the
torrent based on the vector.</p>
<p><tt class="docutils literal">get_file_priorities()</tt> returns a vector with the priorities of all
files.</p>
<p>The priority values are the same as for <a class="reference external" href="reference-Torrent_Handle.html#piece_priority()">piece_priority()</a>. See
<a class="reference external" href="reference-Core.html#download_priority_t">download_priority_t</a>.</p>
<p>Whenever a file priority is changed, all other piece priorities are
reset to match the file priorities. In order to maintain special
priorities for particular pieces, <a class="reference external" href="reference-Torrent_Handle.html#piece_priority()">piece_priority()</a> has to be called
again for those pieces.</p>
<p>You cannot set the file priorities on a torrent that does not yet have
metadata or a torrent that is a seed. <tt class="docutils literal">file_priority(int, int)</tt> and
<a class="reference external" href="reference-Torrent_Handle.html#prioritize_files()">prioritize_files()</a> are both no-ops for such torrents.</p>
<p>Since changing file priorities may involve disk operations (of moving
files in- and out of the part file), the internal accounting of file
priorities happen asynchronously. i.e. setting file priorities and then
immediately querying them may not yield the same priorities just set.
To synchronize with the priorities taking effect, wait for the
<a class="reference external" href="reference-Alerts.html#file_prio_alert">file_prio_alert</a>.</p>
<p>When combining file- and piece priorities, the resume file will record
both. When loading the resume data, the file priorities will be applied
first, then the piece priorities.</p>
<p>Moving data from a file into the part file is currently not
supported. If a file has its priority set to 0 <em>after</em> it has already
been created, it will not be moved into the partfile.</p>
<a name="force_dht_announce()"></a>
<a name="force_lsd_announce()"></a>
<a name="force_reannounce()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bforce_dht_announce%28%29+force_lsd_announce%28%29+force_reannounce%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bforce_dht_announce%28%29+force_lsd_announce%28%29+force_reannounce%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="force-dht-announce-force-lsd-announce-force-reannounce">
<h2>force_dht_announce() force_lsd_announce() force_reannounce()</h2>
<pre class="literal-block">
void <strong>force_dht_announce</strong> () const;
void <strong>force_reannounce</strong> (int seconds = 0, int idx = -1, reannounce_flags_t = {}) const;
void <strong>force_lsd_announce</strong> () const;
</pre>
<p><tt class="docutils literal">force_reannounce()</tt> will force this torrent to do another tracker
request, to receive new peers. The <tt class="docutils literal">seconds</tt> argument specifies how
many seconds from now to issue the tracker announces.</p>
<p>If the tracker's <tt class="docutils literal">min_interval</tt> has not passed since the last
announce, the forced announce will be scheduled to happen immediately
as the <tt class="docutils literal">min_interval</tt> expires. This is to honor trackers minimum
re-announce interval settings.</p>
<p>The <tt class="docutils literal">tracker_index</tt> argument specifies which tracker to re-announce.
If set to -1 (which is the default), all trackers are re-announce.</p>
<p>The <tt class="docutils literal">flags</tt> argument can be used to affect the re-announce. See
ignore_min_interval.</p>
<p><tt class="docutils literal">force_dht_announce</tt> will announce the torrent to the DHT
immediately.</p>
<p><tt class="docutils literal">force_lsd_announce</tt> will announce the torrent on LSD
immediately.</p>
<a name="scrape_tracker()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bscrape_tracker%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bscrape_tracker%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="scrape-tracker">
<h2>scrape_tracker()</h2>
<pre class="literal-block">
void <strong>scrape_tracker</strong> (int idx = -1) const;
</pre>
<p><tt class="docutils literal">scrape_tracker()</tt> will send a scrape request to a tracker. By
default (<tt class="docutils literal">idx</tt> = -1) it will scrape the last working tracker. If
<tt class="docutils literal">idx</tt> is &gt;= 0, the tracker with the specified index will scraped.</p>
<p>A scrape request queries the tracker for statistics such as total
number of incomplete peers, complete peers, number of downloads etc.</p>
<p>This request will specifically update the <tt class="docutils literal">num_complete</tt> and
<tt class="docutils literal">num_incomplete</tt> fields in the <a class="reference external" href="reference-Torrent_Status.html#torrent_status">torrent_status</a> struct once it
completes. When it completes, it will generate a <a class="reference external" href="reference-Alerts.html#scrape_reply_alert">scrape_reply_alert</a>.
If it fails, it will generate a <a class="reference external" href="reference-Alerts.html#scrape_failed_alert">scrape_failed_alert</a>.</p>
<a name="set_download_limit()"></a>
<a name="download_limit()"></a>
<a name="set_upload_limit()"></a>
<a name="upload_limit()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bset_download_limit%28%29+download_limit%28%29+set_upload_limit%28%29+upload_limit%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bset_download_limit%28%29+download_limit%28%29+set_upload_limit%28%29+upload_limit%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="set-download-limit-download-limit-set-upload-limit-upload-limit">
<h2>set_download_limit() download_limit() set_upload_limit() upload_limit()</h2>
<pre class="literal-block">
void <strong>set_upload_limit</strong> (int limit) const;
void <strong>set_download_limit</strong> (int limit) const;
int <strong>upload_limit</strong> () const;
int <strong>download_limit</strong> () const;
</pre>
<p><tt class="docutils literal">set_upload_limit</tt> will limit the upload bandwidth used by this
particular torrent to the limit you set. It is given as the number of
bytes per second the torrent is allowed to upload.
<tt class="docutils literal">set_download_limit</tt> works the same way but for download bandwidth
instead of upload bandwidth. Note that setting a higher limit on a
torrent then the global limit
(<tt class="docutils literal"><span class="pre">settings_pack::upload_rate_limit</span></tt>) will not override the global
rate limit. The torrent can never upload more than the global rate
limit.</p>
<p><tt class="docutils literal">upload_limit</tt> and <tt class="docutils literal">download_limit</tt> will return the current limit
setting, for upload and download, respectively.</p>
<p>Local peers are not rate limited by default. see <a class="reference external" href="manual-ref.html#peer-classes">peer classes</a>.</p>
<a name="connect_peer()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bconnect_peer%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bconnect_peer%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="connect-peer">
<h2>connect_peer()</h2>
<pre class="literal-block">
void <strong>connect_peer</strong> (tcp::endpoint const&amp; adr, peer_source_flags_t source = {}
      , pex_flags_t flags = pex_encryption | pex_utp | pex_holepunch) const;
</pre>
<p><tt class="docutils literal">connect_peer()</tt> is a way to manually connect to peers that one
believe is a part of the torrent. If the peer does not respond, or is
not a member of this torrent, it will simply be disconnected. No harm
can be done by using this other than an unnecessary connection attempt
is made. If the torrent is uninitialized or in queued or checking
mode, this will throw system_error. The second (optional)
argument will be bitwise ORed into the source mask of this peer.
Typically this is one of the source flags in <a class="reference external" href="reference-Core.html#peer_info">peer_info</a>. i.e.
<tt class="docutils literal">tracker</tt>, <tt class="docutils literal">pex</tt>, <tt class="docutils literal">dht</tt> etc.</p>
<p>For possible values of <tt class="docutils literal">flags</tt>, see <a class="reference external" href="reference-Core.html#pex_flags_t">pex_flags_t</a>.</p>
<a name="clear_peers()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bclear_peers%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bclear_peers%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="clear-peers">
<h2>clear_peers()</h2>
<pre class="literal-block">
void <strong>clear_peers</strong> ();
</pre>
<p>This will disconnect all peers and clear the peer list for this
torrent. New peers will have to be acquired before resuming, from
trackers, DHT or local service discovery, for example.</p>
<a name="set_max_uploads()"></a>
<a name="max_uploads()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bset_max_uploads%28%29+max_uploads%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bset_max_uploads%28%29+max_uploads%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="set-max-uploads-max-uploads">
<h2>set_max_uploads() max_uploads()</h2>
<pre class="literal-block">
int <strong>max_uploads</strong> () const;
void <strong>set_max_uploads</strong> (int max_uploads) const;
</pre>
<p><tt class="docutils literal">set_max_uploads()</tt> sets the maximum number of peers that's unchoked
at the same time on this torrent. If you set this to -1, there will be
no limit. This defaults to infinite. The primary setting controlling
this is the global unchoke slots limit, set by unchoke_slots_limit in
<a class="reference external" href="reference-Settings.html#settings_pack">settings_pack</a>.</p>
<p><tt class="docutils literal">max_uploads()</tt> returns the current settings.</p>
<a name="set_max_connections()"></a>
<a name="max_connections()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bset_max_connections%28%29+max_connections%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bset_max_connections%28%29+max_connections%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="set-max-connections-max-connections">
<h2>set_max_connections() max_connections()</h2>
<pre class="literal-block">
void <strong>set_max_connections</strong> (int max_connections) const;
int <strong>max_connections</strong> () const;
</pre>
<p><tt class="docutils literal">set_max_connections()</tt> sets the maximum number of connection this
torrent will open. If all connections are used up, incoming
connections may be refused or poor connections may be closed. This
must be at least 2. The default is unlimited number of connections. If
-1 is given to the function, it means unlimited. There is also a
global limit of the number of connections, set by
<tt class="docutils literal">connections_limit</tt> in <a class="reference external" href="reference-Settings.html#settings_pack">settings_pack</a>.</p>
<p><tt class="docutils literal">max_connections()</tt> returns the current settings.</p>
<a name="move_storage()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bmove_storage%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bmove_storage%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="move-storage">
<h2>move_storage()</h2>
<pre class="literal-block">
void <strong>move_storage</strong> (std::string const&amp; save_path
      , move_flags_t flags = move_flags_t::always_replace_files
      ) const;
</pre>
<p>Moves the file(s) that this torrent are currently seeding from or
downloading to. If the given <tt class="docutils literal">save_path</tt> is not located on the same
drive as the original save path, the files will be copied to the new
drive and removed from their original location. This will block all
other disk IO, and other torrents download and upload rates may drop
while copying the file.</p>
<p>Since disk IO is performed in a separate thread, this operation is
also asynchronous. Once the operation completes, the
<tt class="docutils literal">storage_moved_alert</tt> is generated, with the new path as the
message. If the move fails for some reason,
<tt class="docutils literal">storage_moved_failed_alert</tt> is generated instead, containing the
error message.</p>
<p>The <tt class="docutils literal">flags</tt> argument determines the behavior of the copying/moving
of the files in the torrent. see <a class="reference external" href="reference-Storage.html#move_flags_t">move_flags_t</a>.</p>
<p><tt class="docutils literal">always_replace_files</tt> is the default and replaces any file that
exist in both the source directory and the target directory.</p>
<p><tt class="docutils literal">fail_if_exist</tt> first check to see that none of the copy operations
would cause an overwrite. If it would, it will fail. Otherwise it will
proceed as if it was in <tt class="docutils literal">always_replace_files</tt> mode. Note that there
is an inherent race condition here. If the files in the target
directory appear after the check but before the copy or move
completes, they will be overwritten. When failing because of files
already existing in the target path, the <tt class="docutils literal">error</tt> of
<tt class="docutils literal">move_storage_failed_alert</tt> is set to
<tt class="docutils literal"><span class="pre">boost::system::errc::file_exists</span></tt>.</p>
<p>The intention is that a client may use this as a probe, and if it
fails, ask the user which mode to use. The client may then re-issue
the <tt class="docutils literal">move_storage</tt> call with one of the other modes.</p>
<p><tt class="docutils literal">dont_replace</tt> always keeps the existing file in the target
directory, if there is one. The source files will still be removed in
that case. Note that it won't automatically re-check files. If an
incomplete torrent is moved into a directory with the complete files,
pause, move, force-recheck and resume. Without the re-checking, the
torrent will keep downloading and files in the new download directory
will be overwritten.</p>
<p>Files that have been renamed to have absolute paths are not moved by
this function. Keep in mind that files that don't belong to the
torrent but are stored in the torrent's directory may be moved as
well. This goes for files that have been renamed to absolute paths
that still end up inside the save path.</p>
<p>When copying files, sparse regions are not likely to be preserved.
This makes it proportionally more expensive to move a large torrent
when only few pieces have been downloaded, since the files are then
allocated with zeros in the destination directory.</p>
<a name="rename_file()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Brename_file%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Brename_file%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="rename-file">
<h2>rename_file()</h2>
<pre class="literal-block">
void <strong>rename_file</strong> (file_index_t index, std::string const&amp; new_name) const;
</pre>
<p>Renames the file with the given index asynchronously. The rename
operation is complete when either a <a class="reference external" href="reference-Alerts.html#file_renamed_alert">file_renamed_alert</a> or
<a class="reference external" href="reference-Alerts.html#file_rename_failed_alert">file_rename_failed_alert</a> is posted.</p>
<a name="info_hash()"></a>
<a name="info_hashes()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Binfo_hash%28%29+info_hashes%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Binfo_hash%28%29+info_hashes%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="info-hash-info-hashes">
<h2>info_hash() info_hashes()</h2>
<pre class="literal-block">
info_hash_t <strong>info_hashes</strong> () const;
sha1_hash <strong>info_hash</strong> () const;
</pre>
<p>returns the info-hash(es) of the torrent. If this handle is to a
torrent that hasn't loaded yet (for instance by being added) by a
URL, the returned value is undefined.
The <tt class="docutils literal">info_hash()</tt> returns the SHA-1 info-hash for v1 torrents and a
truncated hash for v2 torrents. For the full v2 info-hash, use
<tt class="docutils literal">info_hashes()</tt> instead.</p>
<a name="operator!=()"></a>
<a name="operator==()"></a>
<a name="operator<()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Boperator%21%3D%28%29+operator%3D%3D%28%29+operator%3C%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Boperator%21%3D%28%29+operator%3D%3D%28%29+operator%3C%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="operator-operator-operator">
<h2>operator!=() operator==() operator&lt;()</h2>
<pre class="literal-block">
bool <strong>operator!=</strong> (const torrent_handle&amp; h) const;
bool <strong>operator==</strong> (const torrent_handle&amp; h) const;
bool <strong>operator&lt;</strong> (const torrent_handle&amp; h) const;
</pre>
<p>comparison operators. The order of the torrents is unspecified
but stable.</p>
<a name="id()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bid%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bid%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="id">
<h2>id()</h2>
<pre class="literal-block">
std::uint32_t <strong>id</strong> () const;
</pre>
<p>returns a unique identifier for this torrent. It's not a dense index.
It's not preserved across sessions.</p>
<a name="native_handle()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bnative_handle%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bnative_handle%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="native-handle">
<h2>native_handle()</h2>
<pre class="literal-block">
std::shared_ptr&lt;torrent&gt; <strong>native_handle</strong> () const;
</pre>
<p>This function is intended only for use by plugins and the <a class="reference external" href="reference-Alerts.html#alert">alert</a>
dispatch function. This type does not have a stable ABI and should
be relied on as little as possible. Accessing the handle returned by
this function is not thread safe outside of libtorrent's internal
thread (which is used to invoke <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> callbacks).
The <tt class="docutils literal">torrent</tt> class is not only eligible for changing ABI across
minor versions of libtorrent, its layout is also dependent on build
configuration. This adds additional requirements on a client to be
built with the exact same build configuration as libtorrent itself.
i.e. the <tt class="docutils literal">TORRENT_</tt> macros must match between libtorrent and the
client builds.</p>
<a name="userdata()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Buserdata%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Buserdata%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="userdata">
<h2>userdata()</h2>
<pre class="literal-block">
client_data_t <strong>userdata</strong> () const;
</pre>
<p>returns the userdata pointer as set in <a class="reference external" href="reference-Add_Torrent.html#add_torrent_params">add_torrent_params</a></p>
<a name="in_session()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bin_session%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bin_session%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="in-session">
<h2>in_session()</h2>
<pre class="literal-block">
bool <strong>in_session</strong> () const;
</pre>
<p>Returns true if the torrent is in the <a class="reference external" href="reference-Session.html#session">session</a>. It returns true before
session::remove_torrent() is called, and false afterward.</p>
<p>Note that this is a blocking function, unlike <a class="reference external" href="reference-Torrent_Handle.html#is_valid()">torrent_handle::is_valid()</a>
which returns immediately.</p>
<a name="overwrite_existing"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Boverwrite_existing%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Boverwrite_existing%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>overwrite_existing</dt>
<dd>instruct libtorrent to overwrite any data that may already have been
downloaded with the data of the new piece being added. Using this
flag when adding a piece that is actively being downloaded from other
peers may have some unexpected consequences, as blocks currently
being downloaded from peers may not be replaced.</dd>
</dl>
<a name="query_distributed_copies"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bquery_distributed_copies%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bquery_distributed_copies%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>query_distributed_copies</dt>
<dd>calculates <tt class="docutils literal">distributed_copies</tt>, <tt class="docutils literal">distributed_full_copies</tt> and
<tt class="docutils literal">distributed_fraction</tt>.</dd>
</dl>
<a name="query_accurate_download_counters"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bquery_accurate_download_counters%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bquery_accurate_download_counters%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>query_accurate_download_counters</dt>
<dd>includes partial downloaded blocks in <tt class="docutils literal">total_done</tt> and
<tt class="docutils literal">total_wanted_done</tt>.</dd>
</dl>
<a name="query_last_seen_complete"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bquery_last_seen_complete%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bquery_last_seen_complete%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>query_last_seen_complete</dt>
<dd>includes <tt class="docutils literal">last_seen_complete</tt>.</dd>
</dl>
<a name="query_pieces"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bquery_pieces%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bquery_pieces%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>query_pieces</dt>
<dd>populate the <tt class="docutils literal">pieces</tt> field in <a class="reference external" href="reference-Torrent_Status.html#torrent_status">torrent_status</a>.</dd>
</dl>
<a name="query_verified_pieces"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bquery_verified_pieces%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bquery_verified_pieces%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>query_verified_pieces</dt>
<dd>includes <tt class="docutils literal">verified_pieces</tt> (only applies to torrents in <em>seed
mode</em>).</dd>
</dl>
<a name="query_torrent_file"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bquery_torrent_file%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bquery_torrent_file%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>query_torrent_file</dt>
<dd>includes <tt class="docutils literal">torrent_file</tt>, which is all the static information from
the .torrent file.</dd>
</dl>
<a name="query_name"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bquery_name%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bquery_name%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>query_name</dt>
<dd>includes <tt class="docutils literal">name</tt>, the name of the torrent. This is either derived
from the .torrent file, or from the <tt class="docutils literal">&amp;dn=</tt> magnet link argument
or possibly some other source. If the name of the torrent is not
known, this is an empty string.</dd>
</dl>
<a name="query_save_path"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bquery_save_path%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bquery_save_path%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>query_save_path</dt>
<dd>includes <tt class="docutils literal">save_path</tt>, the path to the directory the files of the
torrent are saved to.</dd>
</dl>
<a name="alert_when_available"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Balert_when_available%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Balert_when_available%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>alert_when_available</dt>
<dd>used to ask libtorrent to send an <a class="reference external" href="reference-Alerts.html#alert">alert</a> once the piece has been
downloaded, by passing alert_when_available. When set, the
<a class="reference external" href="reference-Alerts.html#read_piece_alert">read_piece_alert</a> <a class="reference external" href="reference-Alerts.html#alert">alert</a> will be delivered, with the piece data, when
it's downloaded.</dd>
</dl>
<a name="piece_granularity"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bpiece_granularity%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bpiece_granularity%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>piece_granularity</dt>
<dd>only calculate file progress at piece granularity. This makes
the <a class="reference external" href="reference-Torrent_Handle.html#file_progress()">file_progress()</a> call cheaper and also only takes bytes that
have passed the hash check into account, so progress cannot
regress in this mode.</dd>
</dl>
<a name="graceful_pause"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bgraceful_pause%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bgraceful_pause%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>graceful_pause</dt>
<dd>will delay the disconnect of peers that we're still downloading
outstanding requests from. The torrent will not accept any more
requests and will disconnect all idle peers. As soon as a peer is done
transferring the blocks that were requested from it, it is
disconnected. This is a graceful shut down of the torrent in the sense
that no downloaded bytes are wasted.</dd>
</dl>
<a name="flush_disk_cache"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bflush_disk_cache%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bflush_disk_cache%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>flush_disk_cache</dt>
<dd>the disk cache will be flushed before creating the resume data.
This avoids a problem with file timestamps in the resume data in
case the cache hasn't been flushed yet.</dd>
</dl>
<a name="save_info_dict"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bsave_info_dict%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bsave_info_dict%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>save_info_dict</dt>
<dd>the resume data will contain the metadata from the torrent file as
well. This is useful for clients that don't keep .torrent files
around separately, or for torrents that were added via a magnet link.</dd>
</dl>
<a name="only_if_modified"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bonly_if_modified%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bonly_if_modified%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>only_if_modified</dt>
<dd>this flag has the same behavior as the combination of:
if_counters_changed | if_download_progress | if_config_changed |
if_state_changed | if_metadata_changed</dd>
</dl>
<a name="if_counters_changed"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bif_counters_changed%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bif_counters_changed%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>if_counters_changed</dt>
<dd>save resume data if any <a class="reference external" href="reference-Stats.html#counters">counters</a> has changed since the last time
resume data was saved. This includes upload/download <a class="reference external" href="reference-Stats.html#counters">counters</a>, active
time <a class="reference external" href="reference-Stats.html#counters">counters</a> and scrape data. A torrent that is not paused will have
its active time <a class="reference external" href="reference-Stats.html#counters">counters</a> incremented continuously.</dd>
</dl>
<a name="if_download_progress"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bif_download_progress%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bif_download_progress%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>if_download_progress</dt>
<dd>save the resume data if any blocks have been downloaded since the
last time resume data was saved. This includes:
* checking existing files on disk
* downloading a block from a peer</dd>
</dl>
<a name="if_config_changed"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bif_config_changed%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bif_config_changed%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>if_config_changed</dt>
<dd>save the resume data if configuration options changed since last time
the resume data was saved. This includes:
* file- or piece priorities
* upload- and download rate limits
* change max-uploads (unchoke slots)
* change max connection limit
* enable/disable peer-exchange, local service discovery or DHT
* enable/disable apply IP-filter
* enable/disable auto-managed
* enable/disable share-mode
* enable/disable sequential-mode
* files renamed
* storage moved (save_path changed)</dd>
</dl>
<a name="if_state_changed"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bif_state_changed%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bif_state_changed%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>if_state_changed</dt>
<dd>save the resume data if torrent state has changed since last time the
resume data was saved. This includes:
* upload mode
* paused state
* super-seeding
* seed-mode</dd>
</dl>
<a name="if_metadata_changed"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bif_metadata_changed%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bif_metadata_changed%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>if_metadata_changed</dt>
<dd>save the resume data if any <em>metadata</em> changed since the last time
resume data was saved. This includes:
* add/remove web seeds
* add/remove trackers
* receiving metadata for a magnet link</dd>
</dl>
<a name="ignore_min_interval"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bignore_min_interval%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bignore_min_interval%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>ignore_min_interval</dt>
<dd>by default, force-reannounce will still honor the min-interval
published by the tracker. If this flag is set, it will be ignored
and the tracker is announced immediately.</dd>
</dl>
<a name="hash_value()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:hash_value%28%29&labels=documentation&body=Documentation+under+heading+%22hash_value%28%29%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="hash-value">
<h1>hash_value()</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/torrent_handle.hpp">libtorrent/torrent_handle.hpp</a>&quot;</p>
<pre class="literal-block">
std::size_t <strong>hash_value</strong> (torrent_handle const&amp; h);
</pre>
<p>for std::hash (and to support using this type in unordered_map etc.)</p>
<a name="storage_params"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+storage_params&labels=documentation&body=Documentation+under+heading+%22class+storage_params%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="storage-params">
<h1>storage_params</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/storage_defs.hpp">libtorrent/storage_defs.hpp</a>&quot;</p>
<p>a parameter pack used to construct the storage for a torrent, used in
<a class="reference external" href="reference-Custom_Storage.html#disk_interface">disk_interface</a></p>
<pre class="literal-block">
struct storage_params
{
   <strong>storage_params</strong> (file_storage const&amp; f, file_storage const* mf
      , std::string const&amp; sp, storage_mode_t const sm
      , aux::vector&lt;download_priority_t, file_index_t&gt; const&amp; prio
      , sha1_hash const&amp; ih);

   file_storage const&amp; files;
   file_storage const* <strong>mapped_files</strong>  = nullptr;
   std::string const&amp; path;
   storage_mode_t <strong>mode</strong> {storage_mode_sparse};
   aux::vector&lt;download_priority_t, file_index_t&gt; const&amp; priorities;
   sha1_hash info_hash;
};
</pre>
<a name="file_slice"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+file_slice&labels=documentation&body=Documentation+under+heading+%22class+file_slice%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="file-slice">
<h1>file_slice</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/file_storage.hpp">libtorrent/file_storage.hpp</a>&quot;</p>
<p>represents a window of a file in a torrent.</p>
<p>The <tt class="docutils literal">file_index</tt> refers to the index of the file (in the <a class="reference external" href="reference-Torrent_Info.html#torrent_info">torrent_info</a>).
To get the path and filename, use <tt class="docutils literal">file_path()</tt> and give the <tt class="docutils literal">file_index</tt>
as argument. The <tt class="docutils literal">offset</tt> is the byte offset in the file where the range
starts, and <tt class="docutils literal">size</tt> is the number of bytes this range is. The size + offset
will never be greater than the file size.</p>
<pre class="literal-block">
struct file_slice
{
   file_index_t file_index;
   std::int64_t offset;
   std::int64_t size;
};
</pre>
<a name="file_index"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:file_slice%3A%3A%5Bfile_index%5D&labels=documentation&body=Documentation+under+heading+%22file_slice%3A%3A%5Bfile_index%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>file_index</dt>
<dd>the index of the file</dd>
</dl>
<a name="offset"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:file_slice%3A%3A%5Boffset%5D&labels=documentation&body=Documentation+under+heading+%22file_slice%3A%3A%5Boffset%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>offset</dt>
<dd>the offset from the start of the file, in bytes</dd>
</dl>
<a name="size"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:file_slice%3A%3A%5Bsize%5D&labels=documentation&body=Documentation+under+heading+%22file_slice%3A%3A%5Bsize%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>size</dt>
<dd>the size of the window, in bytes</dd>
</dl>
<a name="file_storage"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+file_storage&labels=documentation&body=Documentation+under+heading+%22class+file_storage%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="file-storage">
<h1>file_storage</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/file_storage.hpp">libtorrent/file_storage.hpp</a>&quot;</p>
<p>The <tt class="docutils literal">file_storage</tt> class represents a file list and the piece
size. Everything necessary to interpret a regular bittorrent storage
file structure.</p>
<pre class="literal-block">
class file_storage
{
   bool <strong>is_valid</strong> () const;
   void <strong>reserve</strong> (int num_files);
   void <strong>add_file_borrow</strong> (string_view filename
      , std::string const&amp; path, std::int64_t file_size
      , file_flags_t file_flags = {}, char const* filehash = nullptr
      , std::int64_t mtime = 0, string_view symlink_path = string_view()
      , char const* root_hash = nullptr);
   void <strong>add_file</strong> (error_code&amp; ec, std::string const&amp; path, std::int64_t file_size
      , file_flags_t file_flags = {}
      , std::time_t mtime = 0, string_view symlink_path = string_view()
      , char const* root_hash = nullptr);
   void <strong>add_file</strong> (std::string const&amp; path, std::int64_t file_size
      , file_flags_t file_flags = {}
      , std::time_t mtime = 0, string_view symlink_path = string_view()
      , char const* root_hash = nullptr);
   void <strong>add_file_borrow</strong> (error_code&amp; ec, string_view filename
      , std::string const&amp; path, std::int64_t file_size
      , file_flags_t file_flags = {}, char const* filehash = nullptr
      , std::int64_t mtime = 0, string_view symlink_path = string_view()
      , char const* root_hash = nullptr);
   void <strong>rename_file</strong> (file_index_t index, std::string const&amp; new_filename);
   std::vector&lt;file_slice&gt; <strong>map_block</strong> (piece_index_t piece, std::int64_t offset
      , std::int64_t size) const;
   peer_request <strong>map_file</strong> (file_index_t file, std::int64_t offset, int size) const;
   int <strong>num_files</strong> () const noexcept;
   file_index_t <strong>end_file</strong> () const noexcept;
   index_range&lt;file_index_t&gt; <strong>file_range</strong> () const noexcept;
   std::int64_t <strong>total_size</strong> () const;
   void <strong>set_num_pieces</strong> (int n);
   int <strong>num_pieces</strong> () const;
   piece_index_t <strong>end_piece</strong> () const;
   piece_index_t <strong>last_piece</strong> () const;
   index_range&lt;piece_index_t&gt; <strong>piece_range</strong> () const noexcept;
   int <strong>piece_length</strong> () const;
   void <strong>set_piece_length</strong> (int l);
   int <strong>piece_size</strong> (piece_index_t index) const;
   int <strong>piece_size2</strong> (piece_index_t index) const;
   int <strong>blocks_in_piece2</strong> (piece_index_t index) const;
   int <strong>blocks_per_piece</strong> () const;
   void <strong>set_name</strong> (std::string const&amp; n);
   std::string const&amp; <strong>name</strong> () const;
   void <strong>swap</strong> (file_storage&amp; ti) noexcept;
   void <strong>canonicalize</strong> ();
   sha256_hash <strong>root</strong> (file_index_t index) const;
   bool <strong>pad_file_at</strong> (file_index_t index) const;
   std::time_t <strong>mtime</strong> (file_index_t index) const;
   sha1_hash <strong>hash</strong> (file_index_t index) const;
   string_view <strong>file_name</strong> (file_index_t index) const;
   std::string <strong>symlink</strong> (file_index_t index) const;
   std::string <strong>file_path</strong> (file_index_t index, std::string const&amp; save_path = &quot;&quot;) const;
   std::int64_t <strong>file_offset</strong> (file_index_t index) const;
   std::int64_t <strong>file_size</strong> (file_index_t index) const;
   char const* <strong>root_ptr</strong> (file_index_t const index) const;
   index_range&lt;piece_index_t::diff_type&gt; <strong>file_piece_range</strong> (file_index_t) const;
   int <strong>file_num_blocks</strong> (file_index_t index) const;
   int <strong>file_num_pieces</strong> (file_index_t index) const;
   int <strong>file_first_piece_node</strong> (file_index_t index) const;
   int <strong>file_first_block_node</strong> (file_index_t index) const;
   std::uint32_t <strong>file_path_hash</strong> (file_index_t index, std::string const&amp; save_path) const;
   void <strong>all_path_hashes</strong> (std::unordered_set&lt;std::uint32_t&gt;&amp; table) const;
   file_flags_t <strong>file_flags</strong> (file_index_t index) const;
   bool <strong>file_absolute_path</strong> (file_index_t index) const;
   file_index_t <strong>file_index_at_piece</strong> (piece_index_t piece) const;
   file_index_t <strong>file_index_at_offset</strong> (std::int64_t offset) const;
   file_index_t <strong>file_index_for_root</strong> (sha256_hash const&amp; root_hash) const;
   piece_index_t <strong>piece_index_at_file</strong> (file_index_t f) const;
   void <strong>sanitize_symlinks</strong> ();
   bool <strong>v2</strong> () const;

   static constexpr file_flags_t <strong>flag_pad_file</strong>  = 0_bit;
   static constexpr file_flags_t <strong>flag_hidden</strong>  = 1_bit;
   static constexpr file_flags_t <strong>flag_executable</strong>  = 2_bit;
   static constexpr file_flags_t <strong>flag_symlink</strong>  = 3_bit;
};
</pre>
<a name="is_valid()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:file_storage%3A%3A%5Bis_valid%28%29%5D&labels=documentation&body=Documentation+under+heading+%22file_storage%3A%3A%5Bis_valid%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="is-valid-1">
<h2>is_valid()</h2>
<pre class="literal-block">
bool <strong>is_valid</strong> () const;
</pre>
<p>returns true if the piece length has been initialized
on the <a class="reference external" href="reference-Storage.html#file_storage">file_storage</a>. This is typically taken as a proxy
of whether the <a class="reference external" href="reference-Storage.html#file_storage">file_storage</a> as a whole is initialized or
not.</p>
<a name="reserve()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:file_storage%3A%3A%5Breserve%28%29%5D&labels=documentation&body=Documentation+under+heading+%22file_storage%3A%3A%5Breserve%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="reserve">
<h2>reserve()</h2>
<pre class="literal-block">
void <strong>reserve</strong> (int num_files);
</pre>
<p>allocates space for <tt class="docutils literal">num_files</tt> in the internal file list. This can
be used to avoid reallocating the internal file list when the number
of files to be added is known up-front.</p>
<a name="add_file_borrow()"></a>
<a name="add_file()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:file_storage%3A%3A%5Badd_file_borrow%28%29+add_file%28%29%5D&labels=documentation&body=Documentation+under+heading+%22file_storage%3A%3A%5Badd_file_borrow%28%29+add_file%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="add-file-borrow-add-file">
<h2>add_file_borrow() add_file()</h2>
<pre class="literal-block">
void <strong>add_file_borrow</strong> (string_view filename
      , std::string const&amp; path, std::int64_t file_size
      , file_flags_t file_flags = {}, char const* filehash = nullptr
      , std::int64_t mtime = 0, string_view symlink_path = string_view()
      , char const* root_hash = nullptr);
void <strong>add_file</strong> (error_code&amp; ec, std::string const&amp; path, std::int64_t file_size
      , file_flags_t file_flags = {}
      , std::time_t mtime = 0, string_view symlink_path = string_view()
      , char const* root_hash = nullptr);
void <strong>add_file</strong> (std::string const&amp; path, std::int64_t file_size
      , file_flags_t file_flags = {}
      , std::time_t mtime = 0, string_view symlink_path = string_view()
      , char const* root_hash = nullptr);
void <strong>add_file_borrow</strong> (error_code&amp; ec, string_view filename
      , std::string const&amp; path, std::int64_t file_size
      , file_flags_t file_flags = {}, char const* filehash = nullptr
      , std::int64_t mtime = 0, string_view symlink_path = string_view()
      , char const* root_hash = nullptr);
</pre>
<p>Adds a file to the file storage. The <tt class="docutils literal">add_file_borrow</tt> version
expects that <tt class="docutils literal">filename</tt> is the file name (without a path) of
the file that's being added.
This memory is <em>borrowed</em>, i.e. it is the caller's
responsibility to make sure it stays valid throughout the lifetime
of this <a class="reference external" href="reference-Storage.html#file_storage">file_storage</a> object or any copy of it. The same thing applies
to <tt class="docutils literal">filehash</tt>, which is an optional pointer to a 20 byte binary
SHA-1 hash of the file.</p>
<p>if <tt class="docutils literal">filename</tt> is empty, the filename from <tt class="docutils literal">path</tt> is used and not
borrowed.</p>
<p>The <tt class="docutils literal">path</tt> argument is the full path (in the torrent file) to
the file to add. Note that this is not supposed to be an absolute
path, but it is expected to include the name of the torrent as the
first path element.</p>
<p><tt class="docutils literal">file_size</tt> is the size of the file in bytes.</p>
<p>The <tt class="docutils literal">file_flags</tt> argument sets attributes on the file. The file
attributes is an extension and may not work in all bittorrent clients.</p>
<p>For possible file attributes, see file_storage::flags_t.</p>
<p>The <tt class="docutils literal">mtime</tt> argument is optional and can be set to 0. If non-zero,
it is the posix time of the last modification time of this file.</p>
<p><tt class="docutils literal">symlink_path</tt> is the path the file is a symlink to. To make this a
symlink you also need to set the <a class="reference external" href="reference-Storage.html#flag_symlink">file_storage::flag_symlink</a> file flag.</p>
<p><tt class="docutils literal">root_hash</tt> is an optional pointer to a 32 byte SHA-256 hash, being
the merkle tree root hash for this file. This is only used for v2
torrents. If the <tt class="docutils literal">root hash</tt> is specified for one file, it has to
be specified for all, otherwise this function will fail.
Note that the buffer <tt class="docutils literal">root_hash</tt> points to must out-live the
<a class="reference external" href="reference-Storage.html#file_storage">file_storage</a> object, it will not be copied. This parameter is only
used when <em>loading</em> torrents, that already have their file hashes
computed. When creating torrents, the file hashes will be computed by
the piece hashes.</p>
<p>If more files than one are added, certain restrictions to their paths
apply. In a multi-file file storage (torrent), all files must share
the same root directory.</p>
<p>That is, the first path element of all files must be the same.
This shared path element is also set to the name of the torrent. It
can be changed by calling <tt class="docutils literal">set_name</tt>.</p>
<p>The overloads that take an <cite>error_code</cite> reference will report failures
via that variable, otherwise <cite>system_error</cite> is thrown.</p>
<a name="rename_file()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:file_storage%3A%3A%5Brename_file%28%29%5D&labels=documentation&body=Documentation+under+heading+%22file_storage%3A%3A%5Brename_file%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="rename-file-1">
<h2>rename_file()</h2>
<pre class="literal-block">
void <strong>rename_file</strong> (file_index_t index, std::string const&amp; new_filename);
</pre>
<p>renames the file at <tt class="docutils literal">index</tt> to <tt class="docutils literal">new_filename</tt>. Keep in mind
that filenames are expected to be UTF-8 encoded.</p>
<a name="map_block()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:file_storage%3A%3A%5Bmap_block%28%29%5D&labels=documentation&body=Documentation+under+heading+%22file_storage%3A%3A%5Bmap_block%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="map-block">
<h2>map_block()</h2>
<pre class="literal-block">
std::vector&lt;file_slice&gt; <strong>map_block</strong> (piece_index_t piece, std::int64_t offset
      , std::int64_t size) const;
</pre>
<p>returns a list of <a class="reference external" href="reference-Storage.html#file_slice">file_slice</a> objects representing the portions of
files the specified piece index, byte offset and size range overlaps.
this is the inverse mapping of <a class="reference external" href="reference-Torrent_Info.html#map_file()">map_file()</a>.</p>
<p>Preconditions of this function is that the input range is within the
torrents address space. <tt class="docutils literal">piece</tt> may not be negative and</p>
<blockquote>
<tt class="docutils literal">piece</tt> * piece_size + <tt class="docutils literal">offset</tt> + <tt class="docutils literal">size</tt></blockquote>
<p>may not exceed the total size of the torrent.</p>
<a name="map_file()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:file_storage%3A%3A%5Bmap_file%28%29%5D&labels=documentation&body=Documentation+under+heading+%22file_storage%3A%3A%5Bmap_file%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="map-file">
<h2>map_file()</h2>
<pre class="literal-block">
peer_request <strong>map_file</strong> (file_index_t file, std::int64_t offset, int size) const;
</pre>
<p>returns a <a class="reference external" href="reference-Core.html#peer_request">peer_request</a> representing the piece index, byte offset
and size the specified file range overlaps. This is the inverse
mapping over <a class="reference external" href="reference-Torrent_Info.html#map_block()">map_block()</a>. Note that the <tt class="docutils literal">peer_request</tt> return type
is meant to hold bittorrent block requests, which may not be larger
than 16 kiB. Mapping a range larger than that may return an overflown
integer.</p>
<a name="num_files()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:file_storage%3A%3A%5Bnum_files%28%29%5D&labels=documentation&body=Documentation+under+heading+%22file_storage%3A%3A%5Bnum_files%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="num-files">
<h2>num_files()</h2>
<pre class="literal-block">
int <strong>num_files</strong> () const noexcept;
</pre>
<p>returns the number of files in the <a class="reference external" href="reference-Storage.html#file_storage">file_storage</a></p>
<a name="end_file()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:file_storage%3A%3A%5Bend_file%28%29%5D&labels=documentation&body=Documentation+under+heading+%22file_storage%3A%3A%5Bend_file%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="end-file">
<h2>end_file()</h2>
<pre class="literal-block">
file_index_t <strong>end_file</strong> () const noexcept;
</pre>
<p>returns the index of the one-past-end file in the file storage</p>
<a name="file_range()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:file_storage%3A%3A%5Bfile_range%28%29%5D&labels=documentation&body=Documentation+under+heading+%22file_storage%3A%3A%5Bfile_range%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="file-range">
<h2>file_range()</h2>
<pre class="literal-block">
index_range&lt;file_index_t&gt; <strong>file_range</strong> () const noexcept;
</pre>
<p>returns an implementation-defined type that can be used as the
container in a range-for loop. Where the values are the indices of all
files in the <a class="reference external" href="reference-Storage.html#file_storage">file_storage</a>.</p>
<a name="total_size()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:file_storage%3A%3A%5Btotal_size%28%29%5D&labels=documentation&body=Documentation+under+heading+%22file_storage%3A%3A%5Btotal_size%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="total-size">
<h2>total_size()</h2>
<pre class="literal-block">
std::int64_t <strong>total_size</strong> () const;
</pre>
<p>returns the total number of bytes all the files in this torrent spans</p>
<a name="num_pieces()"></a>
<a name="set_num_pieces()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:file_storage%3A%3A%5Bnum_pieces%28%29+set_num_pieces%28%29%5D&labels=documentation&body=Documentation+under+heading+%22file_storage%3A%3A%5Bnum_pieces%28%29+set_num_pieces%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="num-pieces-set-num-pieces">
<h2>num_pieces() set_num_pieces()</h2>
<pre class="literal-block">
void <strong>set_num_pieces</strong> (int n);
int <strong>num_pieces</strong> () const;
</pre>
<p>set and get the number of pieces in the torrent</p>
<a name="end_piece()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:file_storage%3A%3A%5Bend_piece%28%29%5D&labels=documentation&body=Documentation+under+heading+%22file_storage%3A%3A%5Bend_piece%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="end-piece">
<h2>end_piece()</h2>
<pre class="literal-block">
piece_index_t <strong>end_piece</strong> () const;
</pre>
<p>returns the index of the one-past-end piece in the file storage</p>
<a name="last_piece()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:file_storage%3A%3A%5Blast_piece%28%29%5D&labels=documentation&body=Documentation+under+heading+%22file_storage%3A%3A%5Blast_piece%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="last-piece">
<h2>last_piece()</h2>
<pre class="literal-block">
piece_index_t <strong>last_piece</strong> () const;
</pre>
<p>returns the index of the last piece in the torrent. The last piece is
special in that it may be smaller than the other pieces (and the other
pieces are all the same size).</p>
<a name="piece_range()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:file_storage%3A%3A%5Bpiece_range%28%29%5D&labels=documentation&body=Documentation+under+heading+%22file_storage%3A%3A%5Bpiece_range%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="piece-range">
<h2>piece_range()</h2>
<pre class="literal-block">
index_range&lt;piece_index_t&gt; <strong>piece_range</strong> () const noexcept;
</pre>
<p>returns an implementation-defined type that can be used as the
container in a range-for loop. Where the values are the indices of all
pieces in the <a class="reference external" href="reference-Storage.html#file_storage">file_storage</a>.</p>
<a name="piece_length()"></a>
<a name="set_piece_length()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:file_storage%3A%3A%5Bpiece_length%28%29+set_piece_length%28%29%5D&labels=documentation&body=Documentation+under+heading+%22file_storage%3A%3A%5Bpiece_length%28%29+set_piece_length%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="piece-length-set-piece-length">
<h2>piece_length() set_piece_length()</h2>
<pre class="literal-block">
int <strong>piece_length</strong> () const;
void <strong>set_piece_length</strong> (int l);
</pre>
<p>set and get the size of each piece in this torrent. It must be a power of two
and at least 16 kiB.</p>
<a name="piece_size()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:file_storage%3A%3A%5Bpiece_size%28%29%5D&labels=documentation&body=Documentation+under+heading+%22file_storage%3A%3A%5Bpiece_size%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="piece-size">
<h2>piece_size()</h2>
<pre class="literal-block">
int <strong>piece_size</strong> (piece_index_t index) const;
</pre>
<p>returns the piece size of <tt class="docutils literal">index</tt>. This will be the same as <a class="reference external" href="reference-Torrent_Info.html#piece_length()">piece_length()</a>, except
for the last piece, which may be shorter.</p>
<a name="piece_size2()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:file_storage%3A%3A%5Bpiece_size2%28%29%5D&labels=documentation&body=Documentation+under+heading+%22file_storage%3A%3A%5Bpiece_size2%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="piece-size2">
<h2>piece_size2()</h2>
<pre class="literal-block">
int <strong>piece_size2</strong> (piece_index_t index) const;
</pre>
<p>Returns the size of the given piece. If the piece spans multiple files,
only the first file is considered part of the piece. This is used for
v2 torrents, where all files are piece aligned and padded. i.e. The pad
files are not considered part of the piece for this purpose.</p>
<a name="blocks_in_piece2()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:file_storage%3A%3A%5Bblocks_in_piece2%28%29%5D&labels=documentation&body=Documentation+under+heading+%22file_storage%3A%3A%5Bblocks_in_piece2%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="blocks-in-piece2">
<h2>blocks_in_piece2()</h2>
<pre class="literal-block">
int <strong>blocks_in_piece2</strong> (piece_index_t index) const;
</pre>
<p>returns the number of blocks in the specified piece, for v2 torrents.</p>
<a name="blocks_per_piece()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:file_storage%3A%3A%5Bblocks_per_piece%28%29%5D&labels=documentation&body=Documentation+under+heading+%22file_storage%3A%3A%5Bblocks_per_piece%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="blocks-per-piece">
<h2>blocks_per_piece()</h2>
<pre class="literal-block">
int <strong>blocks_per_piece</strong> () const;
</pre>
<p>returns the number of blocks there are in the typical piece. There
may be fewer in the last piece)</p>
<a name="name()"></a>
<a name="set_name()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:file_storage%3A%3A%5Bname%28%29+set_name%28%29%5D&labels=documentation&body=Documentation+under+heading+%22file_storage%3A%3A%5Bname%28%29+set_name%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="name-set-name">
<h2>name() set_name()</h2>
<pre class="literal-block">
void <strong>set_name</strong> (std::string const&amp; n);
std::string const&amp; <strong>name</strong> () const;
</pre>
<p>set and get the name of this torrent. For multi-file torrents, this is also
the name of the root directory all the files are stored in.</p>
<a name="swap()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:file_storage%3A%3A%5Bswap%28%29%5D&labels=documentation&body=Documentation+under+heading+%22file_storage%3A%3A%5Bswap%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="swap-2">
<h2>swap()</h2>
<pre class="literal-block">
void <strong>swap</strong> (file_storage&amp; ti) noexcept;
</pre>
<p>swap all content of <em>this</em> with <em>ti</em>.</p>
<a name="canonicalize()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:file_storage%3A%3A%5Bcanonicalize%28%29%5D&labels=documentation&body=Documentation+under+heading+%22file_storage%3A%3A%5Bcanonicalize%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="canonicalize">
<h2>canonicalize()</h2>
<pre class="literal-block">
void <strong>canonicalize</strong> ();
</pre>
<p>arrange files and padding to match the canonical form required
by BEP 52</p>
<a name="symlink()"></a>
<a name="pad_file_at()"></a>
<a name="mtime()"></a>
<a name="root_ptr()"></a>
<a name="file_path()"></a>
<a name="file_offset()"></a>
<a name="root()"></a>
<a name="file_size()"></a>
<a name="file_name()"></a>
<a name="hash()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:file_storage%3A%3A%5Bsymlink%28%29+pad_file_at%28%29+mtime%28%29+root_ptr%28%29+file_path%28%29+file_offset%28%29+root%28%29+file_size%28%29+file_name%28%29+hash%28%29%5D&labels=documentation&body=Documentation+under+heading+%22file_storage%3A%3A%5Bsymlink%28%29+pad_file_at%28%29+mtime%28%29+root_ptr%28%29+file_path%28%29+file_offset%28%29+root%28%29+file_size%28%29+file_name%28%29+hash%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="symlink-pad-file-at-mtime-root-ptr-file-path-file-offset-root-file-size-file-name-hash">
<h2>symlink() pad_file_at() mtime() root_ptr() file_path() file_offset() root() file_size() file_name() hash()</h2>
<pre class="literal-block">
sha256_hash <strong>root</strong> (file_index_t index) const;
bool <strong>pad_file_at</strong> (file_index_t index) const;
std::time_t <strong>mtime</strong> (file_index_t index) const;
sha1_hash <strong>hash</strong> (file_index_t index) const;
string_view <strong>file_name</strong> (file_index_t index) const;
std::string <strong>symlink</strong> (file_index_t index) const;
std::string <strong>file_path</strong> (file_index_t index, std::string const&amp; save_path = &quot;&quot;) const;
std::int64_t <strong>file_offset</strong> (file_index_t index) const;
std::int64_t <strong>file_size</strong> (file_index_t index) const;
char const* <strong>root_ptr</strong> (file_index_t const index) const;
</pre>
<p>These functions are used to query attributes of files at
a given index.</p>
<p>The <tt class="docutils literal">hash()</tt> is a SHA-1 hash of the file, or 0 if none was
provided in the torrent file. This can potentially be used to
join a bittorrent network with other file sharing networks.</p>
<p><tt class="docutils literal">root()</tt> returns the SHA-256 merkle tree root of the specified file,
in case this is a v2 torrent. Otherwise returns zeros.
<tt class="docutils literal">root_ptr()</tt> returns a pointer to the SHA-256 merkle tree root hash
for the specified file. The pointer points into storage referred to
when the file was added, it is not owned by this object. Torrents
that are not v2 torrents return nullptr.</p>
<p>The <tt class="docutils literal">mtime()</tt> is the modification time is the posix
time when a file was last modified when the torrent
was created, or 0 if it was not included in the torrent file.</p>
<p><tt class="docutils literal">file_path()</tt> returns the full path to a file.</p>
<p><tt class="docutils literal">file_size()</tt> returns the size of a file.</p>
<p><tt class="docutils literal">pad_file_at()</tt> returns true if the file at the given
index is a pad-file.</p>
<p><tt class="docutils literal">file_name()</tt> returns <em>just</em> the name of the file, whereas
<tt class="docutils literal">file_path()</tt> returns the path (inside the torrent file) with
the filename appended.</p>
<p><tt class="docutils literal">file_offset()</tt> returns the byte offset within the torrent file
where this file starts. It can be used to map the file to a piece
index (given the piece size).</p>
<a name="file_num_blocks()"></a>
<a name="file_num_pieces()"></a>
<a name="file_piece_range()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:file_storage%3A%3A%5Bfile_num_blocks%28%29+file_num_pieces%28%29+file_piece_range%28%29%5D&labels=documentation&body=Documentation+under+heading+%22file_storage%3A%3A%5Bfile_num_blocks%28%29+file_num_pieces%28%29+file_piece_range%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="file-num-blocks-file-num-pieces-file-piece-range">
<h2>file_num_blocks() file_num_pieces() file_piece_range()</h2>
<pre class="literal-block">
index_range&lt;piece_index_t::diff_type&gt; <strong>file_piece_range</strong> (file_index_t) const;
int <strong>file_num_blocks</strong> (file_index_t index) const;
int <strong>file_num_pieces</strong> (file_index_t index) const;
</pre>
<p>Returns the number of pieces or blocks the file at <cite>index</cite> spans,
under the assumption that the file is aligned to the start of a piece.
This is only meaningful for v2 torrents, where files are guaranteed
such alignment.
These numbers are used to size and navigate the merkle hash tree for
each file.</p>
<a name="file_first_block_node()"></a>
<a name="file_first_piece_node()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:file_storage%3A%3A%5Bfile_first_block_node%28%29+file_first_piece_node%28%29%5D&labels=documentation&body=Documentation+under+heading+%22file_storage%3A%3A%5Bfile_first_block_node%28%29+file_first_piece_node%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="file-first-block-node-file-first-piece-node">
<h2>file_first_block_node() file_first_piece_node()</h2>
<pre class="literal-block">
int <strong>file_first_piece_node</strong> (file_index_t index) const;
int <strong>file_first_block_node</strong> (file_index_t index) const;
</pre>
<p>index of first piece node in the merkle tree</p>
<a name="file_path_hash()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:file_storage%3A%3A%5Bfile_path_hash%28%29%5D&labels=documentation&body=Documentation+under+heading+%22file_storage%3A%3A%5Bfile_path_hash%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="file-path-hash">
<h2>file_path_hash()</h2>
<pre class="literal-block">
std::uint32_t <strong>file_path_hash</strong> (file_index_t index, std::string const&amp; save_path) const;
</pre>
<p>returns the crc32 hash of file_path(index)</p>
<a name="all_path_hashes()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:file_storage%3A%3A%5Ball_path_hashes%28%29%5D&labels=documentation&body=Documentation+under+heading+%22file_storage%3A%3A%5Ball_path_hashes%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="all-path-hashes">
<h2>all_path_hashes()</h2>
<pre class="literal-block">
void <strong>all_path_hashes</strong> (std::unordered_set&lt;std::uint32_t&gt;&amp; table) const;
</pre>
<p>this will add the CRC32 hash of all directory entries to the table. No
filename will be included, just directories. Every depth of directories
are added separately to allow test for collisions with files at all
levels. i.e. if one path in the torrent is <tt class="docutils literal">foo/bar/baz</tt>, the CRC32
hashes for <tt class="docutils literal">foo</tt>, <tt class="docutils literal">foo/bar</tt> and <tt class="docutils literal">foo/bar/baz</tt> will be added to
the set.</p>
<a name="file_flags()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:file_storage%3A%3A%5Bfile_flags%28%29%5D&labels=documentation&body=Documentation+under+heading+%22file_storage%3A%3A%5Bfile_flags%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="file-flags">
<h2>file_flags()</h2>
<pre class="literal-block">
file_flags_t <strong>file_flags</strong> (file_index_t index) const;
</pre>
<p>returns a bitmask of flags from file_flags_t that apply
to file at <tt class="docutils literal">index</tt>.</p>
<a name="file_absolute_path()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:file_storage%3A%3A%5Bfile_absolute_path%28%29%5D&labels=documentation&body=Documentation+under+heading+%22file_storage%3A%3A%5Bfile_absolute_path%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="file-absolute-path">
<h2>file_absolute_path()</h2>
<pre class="literal-block">
bool <strong>file_absolute_path</strong> (file_index_t index) const;
</pre>
<p>returns true if the file at the specified index has been renamed to
have an absolute path, i.e. is not anchored in the save path of the
torrent.</p>
<a name="file_index_at_offset()"></a>
<a name="file_index_at_piece()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:file_storage%3A%3A%5Bfile_index_at_offset%28%29+file_index_at_piece%28%29%5D&labels=documentation&body=Documentation+under+heading+%22file_storage%3A%3A%5Bfile_index_at_offset%28%29+file_index_at_piece%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="file-index-at-offset-file-index-at-piece">
<h2>file_index_at_offset() file_index_at_piece()</h2>
<pre class="literal-block">
file_index_t <strong>file_index_at_piece</strong> (piece_index_t piece) const;
file_index_t <strong>file_index_at_offset</strong> (std::int64_t offset) const;
</pre>
<p>returns the index of the file at the given offset in the torrent</p>
<a name="file_index_for_root()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:file_storage%3A%3A%5Bfile_index_for_root%28%29%5D&labels=documentation&body=Documentation+under+heading+%22file_storage%3A%3A%5Bfile_index_for_root%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="file-index-for-root">
<h2>file_index_for_root()</h2>
<pre class="literal-block">
file_index_t <strong>file_index_for_root</strong> (sha256_hash const&amp; root_hash) const;
</pre>
<p>finds the file with the given root hash and returns its index
if there is no file with the root hash, file_index_t{-1} is returned</p>
<a name="piece_index_at_file()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:file_storage%3A%3A%5Bpiece_index_at_file%28%29%5D&labels=documentation&body=Documentation+under+heading+%22file_storage%3A%3A%5Bpiece_index_at_file%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="piece-index-at-file">
<h2>piece_index_at_file()</h2>
<pre class="literal-block">
piece_index_t <strong>piece_index_at_file</strong> (file_index_t f) const;
</pre>
<p>returns the piece index the given file starts at</p>
<a name="sanitize_symlinks()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:file_storage%3A%3A%5Bsanitize_symlinks%28%29%5D&labels=documentation&body=Documentation+under+heading+%22file_storage%3A%3A%5Bsanitize_symlinks%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="sanitize-symlinks">
<h2>sanitize_symlinks()</h2>
<pre class="literal-block">
void <strong>sanitize_symlinks</strong> ();
</pre>
<p>validate any symlinks, to ensure they all point to
other files or directories inside this storage. Any invalid symlinks
are updated to point to themselves.</p>
<a name="v2()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:file_storage%3A%3A%5Bv2%28%29%5D&labels=documentation&body=Documentation+under+heading+%22file_storage%3A%3A%5Bv2%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="v2">
<h2>v2()</h2>
<pre class="literal-block">
bool <strong>v2</strong> () const;
</pre>
<p>returns true if this torrent contains v2 metadata.</p>
<a name="flag_pad_file"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:file_storage%3A%3A%5Bflag_pad_file%5D&labels=documentation&body=Documentation+under+heading+%22file_storage%3A%3A%5Bflag_pad_file%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>flag_pad_file</dt>
<dd>the file is a pad file. It's required to contain zeros
at it will not be saved to disk. Its purpose is to make
the following file start on a piece boundary.</dd>
</dl>
<a name="flag_hidden"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:file_storage%3A%3A%5Bflag_hidden%5D&labels=documentation&body=Documentation+under+heading+%22file_storage%3A%3A%5Bflag_hidden%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>flag_hidden</dt>
<dd>this file has the hidden attribute set. This is primarily
a windows attribute</dd>
</dl>
<a name="flag_executable"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:file_storage%3A%3A%5Bflag_executable%5D&labels=documentation&body=Documentation+under+heading+%22file_storage%3A%3A%5Bflag_executable%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>flag_executable</dt>
<dd>this file has the executable attribute set.</dd>
</dl>
<a name="flag_symlink"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:file_storage%3A%3A%5Bflag_symlink%5D&labels=documentation&body=Documentation+under+heading+%22file_storage%3A%3A%5Bflag_symlink%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>flag_symlink</dt>
<dd>this file is a symbolic link. It should have a link
target string associated with it.</dd>
</dl>
<a name="mmap_disk_io_constructor()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:mmap_disk_io_constructor%28%29&labels=documentation&body=Documentation+under+heading+%22mmap_disk_io_constructor%28%29%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="mmap-disk-io-constructor">
<h1>mmap_disk_io_constructor()</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/mmap_disk_io.hpp">libtorrent/mmap_disk_io.hpp</a>&quot;</p>
<pre class="literal-block">
std::unique_ptr&lt;disk_interface&gt; <strong>mmap_disk_io_constructor</strong> (
   io_context&amp; ios, settings_interface const&amp;, counters&amp; cnt);
</pre>
<p>constructs a memory mapped file disk I/O object.</p>
<a name="default_disk_io_constructor()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:default_disk_io_constructor%28%29&labels=documentation&body=Documentation+under+heading+%22default_disk_io_constructor%28%29%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="default-disk-io-constructor">
<h1>default_disk_io_constructor()</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/session.hpp">libtorrent/session.hpp</a>&quot;</p>
<pre class="literal-block">
std::unique_ptr&lt;disk_interface&gt; <strong>default_disk_io_constructor</strong> (
   io_context&amp; ios, settings_interface const&amp;, counters&amp; cnt);
</pre>
<p>the constructor function for the default storage. On systems that support
memory mapped files (and a 64 bit address space) the memory mapped storage
will be constructed, otherwise the portable posix storage.</p>
<a name="disabled_disk_io_constructor()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:disabled_disk_io_constructor%28%29&labels=documentation&body=Documentation+under+heading+%22disabled_disk_io_constructor%28%29%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="disabled-disk-io-constructor">
<h1>disabled_disk_io_constructor()</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/disabled_disk_io.hpp">libtorrent/disabled_disk_io.hpp</a>&quot;</p>
<pre class="literal-block">
std::unique_ptr&lt;disk_interface&gt; <strong>disabled_disk_io_constructor</strong> (
   io_context&amp; ios, settings_interface const&amp;, counters&amp; cnt);
</pre>
<p>creates a disk io object that discards all data written to it, and only
returns zero-buffers when read from. May be useful for testing and
benchmarking.</p>
<a name="posix_disk_io_constructor()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:posix_disk_io_constructor%28%29&labels=documentation&body=Documentation+under+heading+%22posix_disk_io_constructor%28%29%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="posix-disk-io-constructor">
<h1>posix_disk_io_constructor()</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/posix_disk_io.hpp">libtorrent/posix_disk_io.hpp</a>&quot;</p>
<pre class="literal-block">
std::unique_ptr&lt;disk_interface&gt; <strong>posix_disk_io_constructor</strong> (
   io_context&amp; ios, settings_interface const&amp;, counters&amp; cnt);
</pre>
<p>this is a simple posix disk I/O back-end, used for systems that don't
have a 64 bit virtual address space or don't support memory mapped files.
It's implemented using portable C file functions and is single-threaded.</p>
<a name="storage_mode_t"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+storage_mode_t&labels=documentation&body=Documentation+under+heading+%22enum+storage_mode_t%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-storage-mode-t">
<h1>enum storage_mode_t</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/storage_defs.hpp">libtorrent/storage_defs.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="7%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>storage_mode_allocate</td>
<td>0</td>
<td>All pieces will be written to their final position, all files will be
allocated in full when the torrent is first started. This mode minimizes
fragmentation but could be a costly operation.</td>
</tr>
<tr><td>storage_mode_sparse</td>
<td>1</td>
<td>All pieces will be written to the place where they belong and sparse files
will be used. This is the recommended, and default mode.</td>
</tr>
</tbody>
</table>
<a name="status_t"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+status_t&labels=documentation&body=Documentation+under+heading+%22enum+status_t%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-status-t">
<h1>enum status_t</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/storage_defs.hpp">libtorrent/storage_defs.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="7%" />
<col width="74%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>no_error</td>
<td>0</td>
<td>&nbsp;</td>
</tr>
<tr><td>fatal_disk_error</td>
<td>1</td>
<td>&nbsp;</td>
</tr>
<tr><td>need_full_check</td>
<td>2</td>
<td>&nbsp;</td>
</tr>
<tr><td>file_exist</td>
<td>3</td>
<td>&nbsp;</td>
</tr>
<tr><td>oversized_file</td>
<td>16</td>
<td>this is not an enum value, but a flag that can be set in the return
from async_check_files, in case an existing file was found larger than
specified in the torrent. i.e. it has garbage at the end
the <a class="reference external" href="reference-Storage.html#status_t">status_t</a> field is used for this to preserve ABI.</td>
</tr>
</tbody>
</table>
<a name="move_flags_t"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+move_flags_t&labels=documentation&body=Documentation+under+heading+%22enum+move_flags_t%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-move-flags-t">
<h1>enum move_flags_t</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/storage_defs.hpp">libtorrent/storage_defs.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="7%" />
<col width="64%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>always_replace_files</td>
<td>0</td>
<td>replace any files in the destination when copying
or moving the storage</td>
</tr>
<tr><td>fail_if_exist</td>
<td>1</td>
<td>if any files that we want to copy exist in the destination
exist, fail the whole operation and don't perform
any copy or move. There is an inherent race condition
in this mode. The files are checked for existence before
the operation starts. In between the check and performing
the copy, the destination files may be created, in which
case they are replaced.</td>
</tr>
<tr><td>dont_replace</td>
<td>2</td>
<td>if any file exist in the target, take those files instead
of the ones we may have in the source.</td>
</tr>
<tr><td>reset_save_path</td>
<td>3</td>
<td>don't move any source files, just forget about them
and begin checking files at new save path</td>
</tr>
<tr><td>reset_save_path_unchecked</td>
<td>4</td>
<td>don't move any source files, just change save path
and continue working without any checks</td>
</tr>
</tbody>
</table>
<a name="session_proxy"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+session_proxy&labels=documentation&body=Documentation+under+heading+%22class+session_proxy%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="session-proxy">
<h1>session_proxy</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/session.hpp">libtorrent/session.hpp</a>&quot;</p>
<p>this is a holder for the internal <a class="reference external" href="reference-Session.html#session">session</a> implementation object. Once the
<a class="reference external" href="reference-Session.html#session">session</a> destruction is explicitly initiated, this holder is used to
synchronize the completion of the shutdown. The lifetime of this object
may outlive <a class="reference external" href="reference-Session.html#session">session</a>, causing the <a class="reference external" href="reference-Session.html#session">session</a> destructor to not block. The
<a class="reference external" href="reference-Session.html#session_proxy">session_proxy</a> destructor will block however, until the underlying <a class="reference external" href="reference-Session.html#session">session</a>
is done shutting down.</p>
<pre class="literal-block">
struct session_proxy
{
   <strong>session_proxy</strong> (session_proxy const&amp;);
   session_proxy&amp; <strong>operator=</strong> (session_proxy&amp;&amp;) &amp; noexcept;
   <strong>session_proxy</strong> (session_proxy&amp;&amp;) noexcept;
   <strong>session_proxy</strong> ();
   session_proxy&amp; <strong>operator=</strong> (session_proxy const&amp;) &amp;;
   <strong>~session_proxy</strong> ();
};
</pre>
<a name="operator=()"></a>
<a name="session_proxy()"></a>
<a name="~session_proxy()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session_proxy%3A%3A%5Boperator%3D%28%29+session_proxy%28%29+~session_proxy%28%29%5D&labels=documentation&body=Documentation+under+heading+%22session_proxy%3A%3A%5Boperator%3D%28%29+session_proxy%28%29+~session_proxy%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="operator-session-proxy-session-proxy">
<h2>operator=() session_proxy() ~session_proxy()</h2>
<pre class="literal-block">
<strong>session_proxy</strong> (session_proxy const&amp;);
session_proxy&amp; <strong>operator=</strong> (session_proxy&amp;&amp;) &amp; noexcept;
<strong>session_proxy</strong> (session_proxy&amp;&amp;) noexcept;
<strong>session_proxy</strong> ();
session_proxy&amp; <strong>operator=</strong> (session_proxy const&amp;) &amp;;
<strong>~session_proxy</strong> ();
</pre>
<p>default constructor, does not refer to any <a class="reference external" href="reference-Session.html#session">session</a>
implementation object.</p>
<a name="session"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+session&labels=documentation&body=Documentation+under+heading+%22class+session%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="session">
<h1>session</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/session.hpp">libtorrent/session.hpp</a>&quot;</p>
<p>The <a class="reference external" href="reference-Session.html#session">session</a> holds all state that spans multiple torrents. Among other
things it runs the network loop and manages all torrents. Once it's
created, the <a class="reference external" href="reference-Session.html#session">session</a> object will spawn the main thread that will do all
the work. The main thread will be idle as long it doesn't have any
torrents to participate in.</p>
<p>You have some control over <a class="reference external" href="reference-Session.html#session">session</a> configuration through the
<tt class="docutils literal"><span class="pre">session_handle::apply_settings()</span></tt> member function. To change one or more
configuration options, create a <a class="reference external" href="reference-Settings.html#settings_pack">settings_pack</a>. object and fill it with
the settings to be set and pass it in to <tt class="docutils literal"><span class="pre">session::apply_settings()</span></tt>.</p>
<p>see <a class="reference external" href="reference-Session.html#apply_settings()">apply_settings()</a>.</p>
<pre class="literal-block">
struct session : session_handle
{
   <strong>session</strong> ();
   <strong>session</strong> (session_params const&amp; params, session_flags_t flags);
   explicit <strong>session</strong> (session_params&amp;&amp; params);
   <strong>session</strong> (session_params&amp;&amp; params, session_flags_t flags);
   explicit <strong>session</strong> (session_params const&amp; params);
   <strong>session</strong> (session_params&amp;&amp; params, io_context&amp; ios, session_flags_t);
   <strong>session</strong> (session_params const&amp; params, io_context&amp; ios);
   <strong>session</strong> (session_params&amp;&amp; params, io_context&amp; ios);
   <strong>session</strong> (session_params const&amp; params, io_context&amp; ios, session_flags_t);
   <strong>~session</strong> ();
   session_proxy <strong>abort</strong> ();
};
</pre>
<a name="session()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session%3A%3A%5Bsession%28%29%5D&labels=documentation&body=Documentation+under+heading+%22session%3A%3A%5Bsession%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="session-1">
<h2>session()</h2>
<pre class="literal-block">
<strong>session</strong> ();
<strong>session</strong> (session_params const&amp; params, session_flags_t flags);
explicit <strong>session</strong> (session_params&amp;&amp; params);
<strong>session</strong> (session_params&amp;&amp; params, session_flags_t flags);
explicit <strong>session</strong> (session_params const&amp; params);
</pre>
<p>Constructs the <a class="reference external" href="reference-Session.html#session">session</a> objects which acts as the container of torrents.
In order to avoid a race condition between starting the <a class="reference external" href="reference-Session.html#session">session</a> and
configuring it, you can pass in a <a class="reference external" href="reference-Session.html#session_params">session_params</a> object. Its settings
will take effect before the <a class="reference external" href="reference-Session.html#session">session</a> starts up.</p>
<p>The overloads taking <tt class="docutils literal">flags</tt> can be used to start a <a class="reference external" href="reference-Session.html#session">session</a> in
paused mode (by passing in <tt class="docutils literal"><span class="pre">session::paused</span></tt>). Note that
<tt class="docutils literal">add_default_plugins</tt> do not have an affect on constructors that
take a <a class="reference external" href="reference-Session.html#session_params">session_params</a> object. It already contains the plugins to use.</p>
<a name="session()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session%3A%3A%5Bsession%28%29%5D&labels=documentation&body=Documentation+under+heading+%22session%3A%3A%5Bsession%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="session-2">
<h2>session()</h2>
<pre class="literal-block">
<strong>session</strong> (session_params&amp;&amp; params, io_context&amp; ios, session_flags_t);
<strong>session</strong> (session_params const&amp; params, io_context&amp; ios);
<strong>session</strong> (session_params&amp;&amp; params, io_context&amp; ios);
<strong>session</strong> (session_params const&amp; params, io_context&amp; ios, session_flags_t);
</pre>
<p>Overload of the constructor that takes an external io_context to run
the <a class="reference external" href="reference-Session.html#session">session</a> object on. This is primarily useful for tests that may want
to run multiple sessions on a single io_context, or low resource
systems where additional threads are expensive and sharing an
io_context with other events is fine.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The <a class="reference external" href="reference-Session.html#session">session</a> object does not cleanly terminate with an external
<tt class="docutils literal">io_context</tt>. The <tt class="docutils literal"><span class="pre">io_context::run()</span></tt> call <em>must</em> have returned
before it's safe to destruct the <a class="reference external" href="reference-Session.html#session">session</a>. Which means you <em>MUST</em>
call <a class="reference external" href="reference-Session.html#abort()">session::abort()</a> and save the <a class="reference external" href="reference-Session.html#session_proxy">session_proxy</a> first, then
destruct the <a class="reference external" href="reference-Session.html#session">session</a> object, then sync with the io_context, then
destruct the <a class="reference external" href="reference-Session.html#session_proxy">session_proxy</a> object.</p>
</div>
<a name="~session()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session%3A%3A%5B~session%28%29%5D&labels=documentation&body=Documentation+under+heading+%22session%3A%3A%5B~session%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="session-3">
<h2>~session()</h2>
<pre class="literal-block">
<strong>~session</strong> ();
</pre>
<p>The destructor of <a class="reference external" href="reference-Session.html#session">session</a> will notify all trackers that our torrents
have been shut down. If some trackers are down, they will time out.
All this before the destructor of <a class="reference external" href="reference-Session.html#session">session</a> returns. So, it's advised
that any kind of interface (such as windows) are closed before
destructing the <a class="reference external" href="reference-Session.html#session">session</a> object. Because it can take a few second for
it to finish. The timeout can be set with <a class="reference external" href="reference-Session.html#apply_settings()">apply_settings()</a>.</p>
<a name="abort()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session%3A%3A%5Babort%28%29%5D&labels=documentation&body=Documentation+under+heading+%22session%3A%3A%5Babort%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="abort-2">
<h2>abort()</h2>
<pre class="literal-block">
session_proxy <strong>abort</strong> ();
</pre>
<p>In case you want to destruct the <a class="reference external" href="reference-Session.html#session">session</a> asynchronously, you can
request a <a class="reference external" href="reference-Session.html#session">session</a> destruction proxy. If you don't do this, the
destructor of the <a class="reference external" href="reference-Session.html#session">session</a> object will block while the trackers are
contacted. If you keep one <tt class="docutils literal">session_proxy</tt> to the <a class="reference external" href="reference-Session.html#session">session</a> when
destructing it, the destructor will not block, but start to close down
the <a class="reference external" href="reference-Session.html#session">session</a>, the destructor of the proxy will then synchronize the
threads. So, the destruction of the <a class="reference external" href="reference-Session.html#session">session</a> is performed from the
<tt class="docutils literal">session</tt> destructor call until the <tt class="docutils literal">session_proxy</tt> destructor
call. The <tt class="docutils literal">session_proxy</tt> does not have any operations on it (since
the <a class="reference external" href="reference-Session.html#session">session</a> is being closed down, no operations are allowed on it).
The only valid operation is calling the destructor:</p>
<pre class="literal-block">
struct session_proxy {};
</pre>
<a name="session_params"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+session_params&labels=documentation&body=Documentation+under+heading+%22class+session_params%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="session-params">
<h1>session_params</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/session_params.hpp">libtorrent/session_params.hpp</a>&quot;</p>
<p>The <a class="reference external" href="reference-Session.html#session_params">session_params</a> is a parameters pack for configuring the <a class="reference external" href="reference-Session.html#session">session</a>
before it's started.</p>
<pre class="literal-block">
struct session_params
{
   <strong>session_params</strong> ();
   <strong>session_params</strong> (settings_pack const&amp; sp);
   <strong>session_params</strong> (settings_pack&amp;&amp; sp);
   <strong>session_params</strong> (settings_pack const&amp; sp
      , std::vector&lt;std::shared_ptr&lt;plugin&gt;&gt; exts);
   <strong>session_params</strong> (settings_pack&amp;&amp; sp
      , std::vector&lt;std::shared_ptr&lt;plugin&gt;&gt; exts);

   settings_pack settings;
   std::vector&lt;std::shared_ptr&lt;plugin&gt;&gt; extensions;
   dht::dht_state dht_state;
   dht::dht_storage_constructor_type dht_storage_constructor;
   disk_io_constructor_type disk_io_constructor;
   std::map&lt;std::string, std::string&gt; ext_state;
   libtorrent::ip_filter ip_filter;
};
</pre>
<a name="session_params()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session_params%3A%3A%5Bsession_params%28%29%5D&labels=documentation&body=Documentation+under+heading+%22session_params%3A%3A%5Bsession_params%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="session-params-1">
<h2>session_params()</h2>
<pre class="literal-block">
<strong>session_params</strong> ();
<strong>session_params</strong> (settings_pack const&amp; sp);
<strong>session_params</strong> (settings_pack&amp;&amp; sp);
</pre>
<p>This constructor can be used to start with the default plugins
(ut_metadata, ut_pex and smart_ban). Pass a <a class="reference external" href="reference-Settings.html#settings_pack">settings_pack</a> to set the
initial settings when the <a class="reference external" href="reference-Session.html#session">session</a> starts.</p>
<a name="session_params()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session_params%3A%3A%5Bsession_params%28%29%5D&labels=documentation&body=Documentation+under+heading+%22session_params%3A%3A%5Bsession_params%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="session-params-2">
<h2>session_params()</h2>
<pre class="literal-block">
<strong>session_params</strong> (settings_pack const&amp; sp
      , std::vector&lt;std::shared_ptr&lt;plugin&gt;&gt; exts);
<strong>session_params</strong> (settings_pack&amp;&amp; sp
      , std::vector&lt;std::shared_ptr&lt;plugin&gt;&gt; exts);
</pre>
<p>This constructor helps to configure the set of initial plugins
to be added to the <a class="reference external" href="reference-Session.html#session">session</a> before it's started.</p>
<a name="settings"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session_params%3A%3A%5Bsettings%5D&labels=documentation&body=Documentation+under+heading+%22session_params%3A%3A%5Bsettings%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>settings</dt>
<dd>The settings to configure the <a class="reference external" href="reference-Session.html#session">session</a> with</dd>
</dl>
<a name="extensions"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session_params%3A%3A%5Bextensions%5D&labels=documentation&body=Documentation+under+heading+%22session_params%3A%3A%5Bextensions%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>extensions</dt>
<dd>the plugins to add to the <a class="reference external" href="reference-Session.html#session">session</a> as it is constructed</dd>
</dl>
<a name="dht_state"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session_params%3A%3A%5Bdht_state%5D&labels=documentation&body=Documentation+under+heading+%22session_params%3A%3A%5Bdht_state%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>dht_state</dt>
<dd>DHT node ID and node addresses to bootstrap the DHT with.</dd>
</dl>
<a name="dht_storage_constructor"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session_params%3A%3A%5Bdht_storage_constructor%5D&labels=documentation&body=Documentation+under+heading+%22session_params%3A%3A%5Bdht_storage_constructor%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>dht_storage_constructor</dt>
<dd>function object to construct the storage object for DHT items.</dd>
</dl>
<a name="disk_io_constructor"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session_params%3A%3A%5Bdisk_io_constructor%5D&labels=documentation&body=Documentation+under+heading+%22session_params%3A%3A%5Bdisk_io_constructor%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>disk_io_constructor</dt>
<dd>function object to create the disk I/O subsystem. Defaults to
default_disk_io_constructor.</dd>
</dl>
<a name="ext_state"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session_params%3A%3A%5Bext_state%5D&labels=documentation&body=Documentation+under+heading+%22session_params%3A%3A%5Bext_state%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>ext_state</dt>
<dd>this container can be used by extensions/plugins to store settings. It's
primarily here to make it convenient to save and restore state across
sessions, using <a class="reference external" href="reference-Session.html#read_session_params()">read_session_params()</a> and <a class="reference external" href="reference-Session.html#write_session_params()">write_session_params()</a>.</dd>
</dl>
<a name="ip_filter"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session_params%3A%3A%5Bip_filter%5D&labels=documentation&body=Documentation+under+heading+%22session_params%3A%3A%5Bip_filter%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>ip_filter</dt>
<dd>the IP filter to use for the <a class="reference external" href="reference-Session.html#session">session</a>. This restricts which peers are allowed
to connect. As if passed to <a class="reference external" href="reference-Session.html#set_ip_filter()">set_ip_filter()</a>.</dd>
</dl>
<a name="session_handle"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+session_handle&labels=documentation&body=Documentation+under+heading+%22class+session_handle%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="session-handle">
<h1>session_handle</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/session_handle.hpp">libtorrent/session_handle.hpp</a>&quot;</p>
<p>this class provides a non-owning handle to a <a class="reference external" href="reference-Session.html#session">session</a> and a subset of the
interface of the <a class="reference external" href="reference-Session.html#session">session</a> class. If the underlying <a class="reference external" href="reference-Session.html#session">session</a> is destructed
any handle to it will no longer be valid. <a class="reference external" href="reference-Torrent_Info.html#is_valid()">is_valid()</a> will return false and
any operation on it will throw a system_error exception, with error code
invalid_session_handle.</p>
<pre class="literal-block">
struct session_handle
{
   bool <strong>is_valid</strong> () const;
   session_params <strong>session_state</strong> (save_state_flags_t flags = save_state_flags_t::all()) const;
   void <strong>refresh_torrent_status</strong> (std::vector&lt;torrent_status&gt;* ret
      , status_flags_t flags = {}) const;
   std::vector&lt;torrent_status&gt; <strong>get_torrent_status</strong> (
      std::function&lt;bool(torrent_status const&amp;)&gt; const&amp; pred
      , status_flags_t flags = {}) const;
   void <strong>post_torrent_updates</strong> (status_flags_t flags = status_flags_t::all());
   void <strong>post_session_stats</strong> ();
   void <strong>post_dht_stats</strong> ();
   void <strong>set_dht_state</strong> (dht::dht_state const&amp; st);
   void <strong>set_dht_state</strong> (dht::dht_state&amp;&amp; st);
   torrent_handle <strong>find_torrent</strong> (sha1_hash const&amp; info_hash) const;
   std::vector&lt;torrent_handle&gt; <strong>get_torrents</strong> () const;
   void <strong>async_add_torrent</strong> (add_torrent_params&amp;&amp; params);
   torrent_handle <strong>add_torrent</strong> (add_torrent_params const&amp; params, error_code&amp; ec);
   torrent_handle <strong>add_torrent</strong> (add_torrent_params&amp;&amp; params);
   torrent_handle <strong>add_torrent</strong> (add_torrent_params&amp;&amp; params, error_code&amp; ec);
   void <strong>async_add_torrent</strong> (add_torrent_params const&amp; params);
   torrent_handle <strong>add_torrent</strong> (add_torrent_params const&amp; params);
   void <strong>resume</strong> ();
   bool <strong>is_paused</strong> () const;
   void <strong>pause</strong> ();
   bool <strong>is_dht_running</strong> () const;
   void <strong>set_dht_storage</strong> (dht::dht_storage_constructor_type sc);
   void <strong>add_dht_node</strong> (std::pair&lt;std::string, int&gt; const&amp; node);
   void <strong>dht_get_item</strong> (sha1_hash const&amp; target);
   void <strong>dht_get_item</strong> (std::array&lt;char, 32&gt; key
      , std::string salt = std::string());
   sha1_hash <strong>dht_put_item</strong> (entry data);
   void <strong>dht_put_item</strong> (std::array&lt;char, 32&gt; key
      , std::function&lt;void(entry&amp;, std::array&lt;char, 64&gt;&amp;
      , std::int64_t&amp;, std::string const&amp;)&gt; cb
      , std::string salt = std::string());
   void <strong>dht_announce</strong> (sha1_hash const&amp; info_hash, int port = 0, dht::announce_flags_t flags = {});
   void <strong>dht_get_peers</strong> (sha1_hash const&amp; info_hash);
   void <strong>dht_live_nodes</strong> (sha1_hash const&amp; nid);
   void <strong>dht_sample_infohashes</strong> (udp::endpoint const&amp; ep, sha1_hash const&amp; target);
   void <strong>dht_direct_request</strong> (udp::endpoint const&amp; ep, entry const&amp; e, client_data_t userdata = {});
   void <strong>add_extension</strong> (std::function&lt;std::shared_ptr&lt;torrent_plugin&gt;(
      torrent_handle const&amp;, client_data_t)&gt; ext);
   void <strong>add_extension</strong> (std::shared_ptr&lt;plugin&gt; ext);
   ip_filter <strong>get_ip_filter</strong> () const;
   void <strong>set_ip_filter</strong> (ip_filter f);
   void <strong>set_port_filter</strong> (port_filter const&amp; f);
   bool <strong>is_listening</strong> () const;
   unsigned short <strong>listen_port</strong> () const;
   unsigned short <strong>ssl_listen_port</strong> () const;
   ip_filter <strong>get_peer_class_filter</strong> () const;
   void <strong>set_peer_class_filter</strong> (ip_filter const&amp; f);
   peer_class_type_filter <strong>get_peer_class_type_filter</strong> () const;
   void <strong>set_peer_class_type_filter</strong> (peer_class_type_filter const&amp; f);
   peer_class_t <strong>create_peer_class</strong> (char const* name);
   void <strong>delete_peer_class</strong> (peer_class_t cid);
   peer_class_info <strong>get_peer_class</strong> (peer_class_t cid) const;
   void <strong>set_peer_class</strong> (peer_class_t cid, peer_class_info const&amp; pci);
   void <strong>remove_torrent</strong> (const torrent_handle&amp;, remove_flags_t = {});
   void <strong>apply_settings</strong> (settings_pack&amp;&amp;);
   settings_pack <strong>get_settings</strong> () const;
   void <strong>apply_settings</strong> (settings_pack const&amp;);
   void <strong>set_alert_notify</strong> (std::function&lt;void()&gt; const&amp; fun);
   void <strong>pop_alerts</strong> (std::vector&lt;alert*&gt;* alerts);
   alert* <strong>wait_for_alert</strong> (time_duration max_wait);
   void <strong>delete_port_mapping</strong> (port_mapping_t handle);
   std::vector&lt;port_mapping_t&gt; <strong>add_port_mapping</strong> (portmap_protocol t, int external_port, int local_port);
   void <strong>reopen_network_sockets</strong> (reopen_network_flags_t options = reopen_map_ports);
   std::shared_ptr&lt;aux::session_impl&gt; <strong>native_handle</strong> () const;

   static constexpr save_state_flags_t <strong>save_settings</strong>  = 0_bit;
   static constexpr save_state_flags_t <strong>save_dht_state</strong>  = 2_bit;
   static constexpr save_state_flags_t <strong>save_extension_state</strong>  = 11_bit;
   static constexpr save_state_flags_t <strong>save_ip_filter</strong>  = 12_bit;
   static constexpr peer_class_t <strong>global_peer_class_id</strong> {0};
   static constexpr peer_class_t <strong>tcp_peer_class_id</strong> {1};
   static constexpr peer_class_t <strong>local_peer_class_id</strong> {2};
   static constexpr remove_flags_t <strong>delete_files</strong>  = 0_bit;
   static constexpr remove_flags_t <strong>delete_partfile</strong>  = 1_bit;
   static constexpr session_flags_t <strong>paused</strong>  = 2_bit;
   static constexpr portmap_protocol <strong>udp</strong>  = portmap_protocol::udp;
   static constexpr portmap_protocol <strong>tcp</strong>  = portmap_protocol::tcp;
   static constexpr reopen_network_flags_t <strong>reopen_map_ports</strong>  = 0_bit;
};
</pre>
<a name="is_valid()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session_handle%3A%3A%5Bis_valid%28%29%5D&labels=documentation&body=Documentation+under+heading+%22session_handle%3A%3A%5Bis_valid%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="is-valid-2">
<h2>is_valid()</h2>
<pre class="literal-block">
bool <strong>is_valid</strong> () const;
</pre>
<p>returns true if this handle refers to a valid <a class="reference external" href="reference-Session.html#session">session</a> object. If the
<a class="reference external" href="reference-Session.html#session">session</a> has been destroyed, all <a class="reference external" href="reference-Session.html#session_handle">session_handle</a> objects will expire and
not be valid.</p>
<a name="session_state()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session_handle%3A%3A%5Bsession_state%28%29%5D&labels=documentation&body=Documentation+under+heading+%22session_handle%3A%3A%5Bsession_state%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="session-state">
<h2>session_state()</h2>
<pre class="literal-block">
session_params <strong>session_state</strong> (save_state_flags_t flags = save_state_flags_t::all()) const;
</pre>
<p>returns the current <a class="reference external" href="reference-Session.html#session">session</a> state. This can be passed to
<a class="reference external" href="reference-Session.html#write_session_params()">write_session_params()</a> to save the state to disk and restored using
<a class="reference external" href="reference-Session.html#read_session_params()">read_session_params()</a> when constructing a new <a class="reference external" href="reference-Session.html#session">session</a>. The kind of
state that's included is all settings, the DHT routing table, possibly
plugin-specific state.
the flags parameter can be used to only save certain parts of the
<a class="reference external" href="reference-Session.html#session">session</a> state</p>
<a name="get_torrent_status()"></a>
<a name="refresh_torrent_status()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session_handle%3A%3A%5Bget_torrent_status%28%29+refresh_torrent_status%28%29%5D&labels=documentation&body=Documentation+under+heading+%22session_handle%3A%3A%5Bget_torrent_status%28%29+refresh_torrent_status%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="get-torrent-status-refresh-torrent-status">
<h2>get_torrent_status() refresh_torrent_status()</h2>
<pre class="literal-block">
void <strong>refresh_torrent_status</strong> (std::vector&lt;torrent_status&gt;* ret
      , status_flags_t flags = {}) const;
std::vector&lt;torrent_status&gt; <strong>get_torrent_status</strong> (
      std::function&lt;bool(torrent_status const&amp;)&gt; const&amp; pred
      , status_flags_t flags = {}) const;
</pre>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">these calls are potentially expensive and won't scale well with
lots of torrents. If you're concerned about performance, consider
using <tt class="docutils literal">post_torrent_updates()</tt> instead.</p>
</div>
<p><tt class="docutils literal">get_torrent_status</tt> returns a vector of the <a class="reference external" href="reference-Torrent_Status.html#torrent_status">torrent_status</a> for
every torrent which satisfies <tt class="docutils literal">pred</tt>, which is a predicate function
which determines if a torrent should be included in the returned set
or not. Returning true means it should be included and false means
excluded. The <tt class="docutils literal">flags</tt> argument is the same as to
<a class="reference external" href="reference-Torrent_Handle.html#status()">torrent_handle::status()</a>. Since <tt class="docutils literal">pred</tt> is guaranteed to be
called for every torrent, it may be used to count the number of
torrents of different categories as well.</p>
<p><tt class="docutils literal">refresh_torrent_status</tt> takes a vector of <a class="reference external" href="reference-Torrent_Status.html#torrent_status">torrent_status</a> structs
(for instance the same vector that was returned by
<a class="reference external" href="reference-Session.html#get_torrent_status()">get_torrent_status()</a> ) and refreshes the status based on the
<tt class="docutils literal">handle</tt> member. It is possible to use this function by first
setting up a vector of default constructed <tt class="docutils literal">torrent_status</tt> objects,
only initializing the <tt class="docutils literal">handle</tt> member, in order to request the
torrent status for multiple torrents in a single call. This can save a
significant amount of time if you have a lot of torrents.</p>
<p>Any <a class="reference external" href="reference-Torrent_Status.html#torrent_status">torrent_status</a> object whose <tt class="docutils literal">handle</tt> member is not referring to
a valid torrent are ignored.</p>
<p>The intended use of these functions is to start off by calling
<tt class="docutils literal">get_torrent_status()</tt> to get a list of all torrents that match your
criteria. Then call <tt class="docutils literal">refresh_torrent_status()</tt> on that list. This
will only refresh the status for the torrents in your list, and thus
ignore all other torrents you might be running. This may save a
significant amount of time, especially if the number of torrents you're
interested in is small. In order to keep your list of interested
torrents up to date, you can either call <tt class="docutils literal">get_torrent_status()</tt> from
time to time, to include torrents you might have become interested in
since the last time. In order to stop refreshing a certain torrent,
simply remove it from the list.</p>
<a name="post_torrent_updates()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session_handle%3A%3A%5Bpost_torrent_updates%28%29%5D&labels=documentation&body=Documentation+under+heading+%22session_handle%3A%3A%5Bpost_torrent_updates%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="post-torrent-updates">
<h2>post_torrent_updates()</h2>
<pre class="literal-block">
void <strong>post_torrent_updates</strong> (status_flags_t flags = status_flags_t::all());
</pre>
<p>This functions instructs the <a class="reference external" href="reference-Session.html#session">session</a> to post the <a class="reference external" href="reference-Alerts.html#state_update_alert">state_update_alert</a>,
containing the status of all torrents whose state changed since the
last time this function was called.</p>
<p>Only torrents who has the state subscription flag set will be
included. This flag is on by default. See <a class="reference external" href="reference-Add_Torrent.html#add_torrent_params">add_torrent_params</a>.
the <tt class="docutils literal">flags</tt> argument is the same as for <a class="reference external" href="reference-Torrent_Handle.html#status()">torrent_handle::status()</a>.
see status_flags_t in <a class="reference external" href="reference-Torrent_Handle.html#torrent_handle">torrent_handle</a>.</p>
<a name="post_session_stats()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session_handle%3A%3A%5Bpost_session_stats%28%29%5D&labels=documentation&body=Documentation+under+heading+%22session_handle%3A%3A%5Bpost_session_stats%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="post-session-stats">
<h2>post_session_stats()</h2>
<pre class="literal-block">
void <strong>post_session_stats</strong> ();
</pre>
<p>This function will post a <a class="reference external" href="reference-Alerts.html#session_stats_alert">session_stats_alert</a> object, containing a
snapshot of the performance <a class="reference external" href="reference-Stats.html#counters">counters</a> from the internals of libtorrent.
To interpret these <a class="reference external" href="reference-Stats.html#counters">counters</a>, query the <a class="reference external" href="reference-Session.html#session">session</a> via
<a class="reference external" href="reference-Stats.html#session_stats_metrics()">session_stats_metrics()</a>.</p>
<p>For more information, see the <a class="reference external" href="manual-ref.html#session-statistics">session statistics</a> section.</p>
<a name="post_dht_stats()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session_handle%3A%3A%5Bpost_dht_stats%28%29%5D&labels=documentation&body=Documentation+under+heading+%22session_handle%3A%3A%5Bpost_dht_stats%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="post-dht-stats">
<h2>post_dht_stats()</h2>
<pre class="literal-block">
void <strong>post_dht_stats</strong> ();
</pre>
<p>This will cause a <a class="reference external" href="reference-Alerts.html#dht_stats_alert">dht_stats_alert</a> to be posted.</p>
<a name="set_dht_state()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session_handle%3A%3A%5Bset_dht_state%28%29%5D&labels=documentation&body=Documentation+under+heading+%22session_handle%3A%3A%5Bset_dht_state%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="set-dht-state">
<h2>set_dht_state()</h2>
<pre class="literal-block">
void <strong>set_dht_state</strong> (dht::dht_state const&amp; st);
void <strong>set_dht_state</strong> (dht::dht_state&amp;&amp; st);
</pre>
<p>set the DHT state for the <a class="reference external" href="reference-Session.html#session">session</a>. This will be taken into account the
next time the DHT is started, as if it had been passed in via the
<a class="reference external" href="reference-Session.html#session_params">session_params</a> on startup.</p>
<a name="find_torrent()"></a>
<a name="get_torrents()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session_handle%3A%3A%5Bfind_torrent%28%29+get_torrents%28%29%5D&labels=documentation&body=Documentation+under+heading+%22session_handle%3A%3A%5Bfind_torrent%28%29+get_torrents%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="find-torrent-get-torrents">
<h2>find_torrent() get_torrents()</h2>
<pre class="literal-block">
torrent_handle <strong>find_torrent</strong> (sha1_hash const&amp; info_hash) const;
std::vector&lt;torrent_handle&gt; <strong>get_torrents</strong> () const;
</pre>
<p><tt class="docutils literal">find_torrent()</tt> looks for a torrent with the given info-hash. In
case there is such a torrent in the <a class="reference external" href="reference-Session.html#session">session</a>, a <a class="reference external" href="reference-Torrent_Handle.html#torrent_handle">torrent_handle</a> to that
torrent is returned. In case the torrent cannot be found, an invalid
<a class="reference external" href="reference-Torrent_Handle.html#torrent_handle">torrent_handle</a> is returned.</p>
<p>See <tt class="docutils literal"><span class="pre">torrent_handle::is_valid()</span></tt> to know if the torrent was found or
not.</p>
<p><tt class="docutils literal">get_torrents()</tt> returns a vector of torrent_handles to all the
torrents currently in the <a class="reference external" href="reference-Session.html#session">session</a>.</p>
<a name="add_torrent()"></a>
<a name="async_add_torrent()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session_handle%3A%3A%5Badd_torrent%28%29+async_add_torrent%28%29%5D&labels=documentation&body=Documentation+under+heading+%22session_handle%3A%3A%5Badd_torrent%28%29+async_add_torrent%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="add-torrent-async-add-torrent">
<h2>add_torrent() async_add_torrent()</h2>
<pre class="literal-block">
void <strong>async_add_torrent</strong> (add_torrent_params&amp;&amp; params);
torrent_handle <strong>add_torrent</strong> (add_torrent_params const&amp; params, error_code&amp; ec);
torrent_handle <strong>add_torrent</strong> (add_torrent_params&amp;&amp; params);
torrent_handle <strong>add_torrent</strong> (add_torrent_params&amp;&amp; params, error_code&amp; ec);
void <strong>async_add_torrent</strong> (add_torrent_params const&amp; params);
torrent_handle <strong>add_torrent</strong> (add_torrent_params const&amp; params);
</pre>
<p>You add torrents through the <a class="reference external" href="reference-Session.html#add_torrent()">add_torrent()</a> function where you give an
object with all the parameters. The <a class="reference external" href="reference-Session.html#add_torrent()">add_torrent()</a> overloads will block
until the torrent has been added (or failed to be added) and returns
an error code and a <a class="reference external" href="reference-Torrent_Handle.html#torrent_handle">torrent_handle</a>. In order to add torrents more
efficiently, consider using <a class="reference external" href="reference-Session.html#async_add_torrent()">async_add_torrent()</a> which returns
immediately, without waiting for the torrent to add. Notification of
the torrent being added is sent as <a class="reference external" href="reference-Alerts.html#add_torrent_alert">add_torrent_alert</a>.</p>
<p>The <tt class="docutils literal">save_path</tt> field in <a class="reference external" href="reference-Add_Torrent.html#add_torrent_params">add_torrent_params</a> must be set to a valid
path where the files for the torrent will be saved. Even when using a
custom storage, this needs to be set to something. If the save_path
is empty, the call to <a class="reference external" href="reference-Session.html#add_torrent()">add_torrent()</a> will throw a system_error
exception.</p>
<p>The overload that does not take an error_code throws an exception on
error and is not available when building without exception support.
The <a class="reference external" href="reference-Torrent_Handle.html#torrent_handle">torrent_handle</a> returned by <a class="reference external" href="reference-Session.html#add_torrent()">add_torrent()</a> can be used to retrieve
information about the torrent's progress, its peers etc. It is also
used to abort a torrent.</p>
<p>If the torrent you are trying to add already exists in the <a class="reference external" href="reference-Session.html#session">session</a> (is
either queued for checking, being checked or downloading)
<tt class="docutils literal">add_torrent()</tt> will throw system_error which derives from
<tt class="docutils literal"><span class="pre">std::exception</span></tt> unless duplicate_is_error is set to false. In that
case, <a class="reference external" href="reference-Session.html#add_torrent()">add_torrent()</a> will return the handle to the existing torrent.</p>
<p>The <a class="reference external" href="reference-Add_Torrent.html#add_torrent_params">add_torrent_params</a> class has a flags field. It can be used to
control what state the new torrent will be added in. Common flags to
want to control are torrent_flags::paused and
torrent_flags::auto_managed. In order to add a magnet link that will
just download the metadata, but no payload, set the
torrent_flags::upload_mode flag.</p>
<p>Special consideration has to be taken when adding hybrid torrents
(i.e. torrents that are BitTorrent v2 torrents that are backwards
compatible with v1). For more details, see <a class="reference external" href="manual-ref.html#bittorrent-v2-torrents">BitTorrent v2 torrents</a>.</p>
<a name="resume()"></a>
<a name="is_paused()"></a>
<a name="pause()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session_handle%3A%3A%5Bresume%28%29+is_paused%28%29+pause%28%29%5D&labels=documentation&body=Documentation+under+heading+%22session_handle%3A%3A%5Bresume%28%29+is_paused%28%29+pause%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="resume-is-paused-pause">
<h2>resume() is_paused() pause()</h2>
<pre class="literal-block">
void <strong>resume</strong> ();
bool <strong>is_paused</strong> () const;
void <strong>pause</strong> ();
</pre>
<p>Pausing the <a class="reference external" href="reference-Session.html#session">session</a> has the same effect as pausing every torrent in
it, except that torrents will not be resumed by the auto-manage
mechanism. Resuming will restore the torrents to their previous paused
state. i.e. the <a class="reference external" href="reference-Session.html#session">session</a> pause state is separate from the torrent pause
state. A torrent is inactive if it is paused or if the <a class="reference external" href="reference-Session.html#session">session</a> is
paused.</p>
<a name="is_dht_running()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session_handle%3A%3A%5Bis_dht_running%28%29%5D&labels=documentation&body=Documentation+under+heading+%22session_handle%3A%3A%5Bis_dht_running%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="is-dht-running">
<h2>is_dht_running()</h2>
<pre class="literal-block">
bool <strong>is_dht_running</strong> () const;
</pre>
<p><tt class="docutils literal">is_dht_running()</tt> returns true if the DHT support has been started
and false otherwise.</p>
<a name="set_dht_storage()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session_handle%3A%3A%5Bset_dht_storage%28%29%5D&labels=documentation&body=Documentation+under+heading+%22session_handle%3A%3A%5Bset_dht_storage%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="set-dht-storage">
<h2>set_dht_storage()</h2>
<pre class="literal-block">
void <strong>set_dht_storage</strong> (dht::dht_storage_constructor_type sc);
</pre>
<p><tt class="docutils literal">set_dht_storage</tt> set a dht custom storage constructor function
to be used internally when the dht is created.</p>
<p>Since the dht storage is a critical component for the dht behavior,
this function will only be effective the next time the dht is started.
If you never touch this feature, a default map-memory based storage
is used.</p>
<p>If you want to make sure the dht is initially created with your
custom storage, create a <a class="reference external" href="reference-Session.html#session">session</a> with the setting
<tt class="docutils literal"><span class="pre">settings_pack::enable_dht</span></tt> to false, set your constructor function
and call <tt class="docutils literal">apply_settings</tt> with <tt class="docutils literal"><span class="pre">settings_pack::enable_dht</span></tt> to true.</p>
<a name="add_dht_node()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session_handle%3A%3A%5Badd_dht_node%28%29%5D&labels=documentation&body=Documentation+under+heading+%22session_handle%3A%3A%5Badd_dht_node%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="add-dht-node">
<h2>add_dht_node()</h2>
<pre class="literal-block">
void <strong>add_dht_node</strong> (std::pair&lt;std::string, int&gt; const&amp; node);
</pre>
<p><tt class="docutils literal">add_dht_node</tt> takes a host name and port pair. That endpoint will be
pinged, and if a valid DHT reply is received, the node will be added to
the routing table.</p>
<a name="dht_get_item()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session_handle%3A%3A%5Bdht_get_item%28%29%5D&labels=documentation&body=Documentation+under+heading+%22session_handle%3A%3A%5Bdht_get_item%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="dht-get-item">
<h2>dht_get_item()</h2>
<pre class="literal-block">
void <strong>dht_get_item</strong> (sha1_hash const&amp; target);
</pre>
<p>query the DHT for an immutable item at the <tt class="docutils literal">target</tt> hash.
the result is posted as a <a class="reference external" href="reference-Alerts.html#dht_immutable_item_alert">dht_immutable_item_alert</a>.</p>
<a name="dht_get_item()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session_handle%3A%3A%5Bdht_get_item%28%29%5D&labels=documentation&body=Documentation+under+heading+%22session_handle%3A%3A%5Bdht_get_item%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="dht-get-item-1">
<h2>dht_get_item()</h2>
<pre class="literal-block">
void <strong>dht_get_item</strong> (std::array&lt;char, 32&gt; key
      , std::string salt = std::string());
</pre>
<p>query the DHT for a mutable item under the public key <tt class="docutils literal">key</tt>.
this is an ed25519 key. <tt class="docutils literal">salt</tt> is optional and may be left
as an empty string if no salt is to be used.
if the item is found in the DHT, a <a class="reference external" href="reference-Alerts.html#dht_mutable_item_alert">dht_mutable_item_alert</a> is
posted.</p>
<a name="dht_put_item()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session_handle%3A%3A%5Bdht_put_item%28%29%5D&labels=documentation&body=Documentation+under+heading+%22session_handle%3A%3A%5Bdht_put_item%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="dht-put-item">
<h2>dht_put_item()</h2>
<pre class="literal-block">
sha1_hash <strong>dht_put_item</strong> (entry data);
</pre>
<p>store the given bencoded data as an immutable item in the DHT.
the returned hash is the key that is to be used to look the item
up again. It's just the SHA-1 hash of the bencoded form of the
structure.</p>
<a name="dht_put_item()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session_handle%3A%3A%5Bdht_put_item%28%29%5D&labels=documentation&body=Documentation+under+heading+%22session_handle%3A%3A%5Bdht_put_item%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="dht-put-item-1">
<h2>dht_put_item()</h2>
<pre class="literal-block">
void <strong>dht_put_item</strong> (std::array&lt;char, 32&gt; key
      , std::function&lt;void(entry&amp;, std::array&lt;char, 64&gt;&amp;
      , std::int64_t&amp;, std::string const&amp;)&gt; cb
      , std::string salt = std::string());
</pre>
<p>store a mutable item. The <tt class="docutils literal">key</tt> is the public key the blob is
to be stored under. The optional <tt class="docutils literal">salt</tt> argument is a string that
is to be mixed in with the key when determining where in the DHT
the value is to be stored. The callback function is called from within
the libtorrent network thread once we've found where to store the blob,
possibly with the current value stored under the key.
The values passed to the callback functions are:</p>
<dl class="docutils">
<dt>entry&amp; value</dt>
<dd>the current value stored under the key (may be empty). Also expected
to be set to the value to be stored by the function.</dd>
<dt>std::array&lt;char,64&gt;&amp; signature</dt>
<dd>the signature authenticating the current value. This may be zeros
if there is currently no value stored. The function is expected to
fill in this buffer with the signature of the new value to store.
To generate the signature, you may want to use the
<tt class="docutils literal">sign_mutable_item</tt> function.</dd>
<dt>std::int64_t&amp; seq</dt>
<dd>current sequence number. May be zero if there is no current value.
The function is expected to set this to the new sequence number of
the value that is to be stored. Sequence numbers must be monotonically
increasing. Attempting to overwrite a value with a lower or equal
sequence number will fail, even if the signature is correct.</dd>
<dt>std::string const&amp; salt</dt>
<dd>this is the salt that was used for this put call.</dd>
</dl>
<p>Since the callback function <tt class="docutils literal">cb</tt> is called from within libtorrent,
it is critical to not perform any blocking operations. Ideally not
even locking a mutex. Pass any data required for this function along
with the function object's context and make the function entirely
self-contained. The only reason data blob's value is computed
via a function instead of just passing in the new value is to avoid
race conditions. If you want to <em>update</em> the value in the DHT, you
must first retrieve it, then modify it, then write it back. The way
the DHT works, it is natural to always do a lookup before storing and
calling the callback in between is convenient.</p>
<a name="dht_announce()"></a>
<a name="dht_get_peers()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session_handle%3A%3A%5Bdht_announce%28%29+dht_get_peers%28%29%5D&labels=documentation&body=Documentation+under+heading+%22session_handle%3A%3A%5Bdht_announce%28%29+dht_get_peers%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="dht-announce-dht-get-peers">
<h2>dht_announce() dht_get_peers()</h2>
<pre class="literal-block">
void <strong>dht_announce</strong> (sha1_hash const&amp; info_hash, int port = 0, dht::announce_flags_t flags = {});
void <strong>dht_get_peers</strong> (sha1_hash const&amp; info_hash);
</pre>
<p><tt class="docutils literal">dht_get_peers()</tt> will issue a DHT get_peer request to the DHT for the
specified info-hash. The response (the peers) will be posted back in a
<a class="reference external" href="reference-Alerts.html#dht_get_peers_reply_alert">dht_get_peers_reply_alert</a>.</p>
<p><tt class="docutils literal">dht_announce()</tt> will issue a DHT announce request to the DHT to the
specified info-hash, advertising the specified port. If the port is
left at its default, 0, the port will be implied by the DHT message's
source port (which may improve connectivity through a NAT).
<tt class="docutils literal">dht_announce()</tt> is not affected by the <tt class="docutils literal">announce_port</tt> override setting.</p>
<p>Both these functions are exposed for advanced custom use of the DHT.
All torrents eligible to be announce to the DHT will be automatically,
by libtorrent.</p>
<p>For possible flags, see <a class="reference external" href="reference-DHT.html#announce_flags_t">announce_flags_t</a>.</p>
<a name="dht_live_nodes()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session_handle%3A%3A%5Bdht_live_nodes%28%29%5D&labels=documentation&body=Documentation+under+heading+%22session_handle%3A%3A%5Bdht_live_nodes%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="dht-live-nodes">
<h2>dht_live_nodes()</h2>
<pre class="literal-block">
void <strong>dht_live_nodes</strong> (sha1_hash const&amp; nid);
</pre>
<p>Retrieve all the live DHT (identified by <tt class="docutils literal">nid</tt>) nodes. All the
nodes id and endpoint will be returned in the list of nodes in the
<a class="reference external" href="reference-Alerts.html#alert">alert</a> <tt class="docutils literal">dht_live_nodes_alert</tt>.
Since this <a class="reference external" href="reference-Alerts.html#alert">alert</a> is a response to an explicit call, it will always be
posted, regardless of the <a class="reference external" href="reference-Alerts.html#alert">alert</a> mask.</p>
<a name="dht_sample_infohashes()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session_handle%3A%3A%5Bdht_sample_infohashes%28%29%5D&labels=documentation&body=Documentation+under+heading+%22session_handle%3A%3A%5Bdht_sample_infohashes%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="dht-sample-infohashes">
<h2>dht_sample_infohashes()</h2>
<pre class="literal-block">
void <strong>dht_sample_infohashes</strong> (udp::endpoint const&amp; ep, sha1_hash const&amp; target);
</pre>
<p>Query the DHT node specified by <tt class="docutils literal">ep</tt> to retrieve a sample of the
info-hashes that the node currently have in their storage.
The <tt class="docutils literal">target</tt> is included for iterative lookups so that indexing nodes
can perform a key space traversal with a single RPC per node by adjusting
the target value for each RPC. It has no effect on the returned sample value.
The result is posted as a <tt class="docutils literal">dht_sample_infohashes_alert</tt>.</p>
<a name="dht_direct_request()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session_handle%3A%3A%5Bdht_direct_request%28%29%5D&labels=documentation&body=Documentation+under+heading+%22session_handle%3A%3A%5Bdht_direct_request%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="dht-direct-request">
<h2>dht_direct_request()</h2>
<pre class="literal-block">
void <strong>dht_direct_request</strong> (udp::endpoint const&amp; ep, entry const&amp; e, client_data_t userdata = {});
</pre>
<p>Send an arbitrary DHT request directly to the specified endpoint. This
function is intended for use by plugins. When a response is received
or the request times out, a <a class="reference external" href="reference-Alerts.html#dht_direct_response_alert">dht_direct_response_alert</a> will be posted
with the response (if any) and the userdata pointer passed in here.
Since this <a class="reference external" href="reference-Alerts.html#alert">alert</a> is a response to an explicit call, it will always be
posted, regardless of the <a class="reference external" href="reference-Alerts.html#alert">alert</a> mask.</p>
<a name="add_extension()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session_handle%3A%3A%5Badd_extension%28%29%5D&labels=documentation&body=Documentation+under+heading+%22session_handle%3A%3A%5Badd_extension%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="add-extension-1">
<h2>add_extension()</h2>
<pre class="literal-block">
void <strong>add_extension</strong> (std::function&lt;std::shared_ptr&lt;torrent_plugin&gt;(
      torrent_handle const&amp;, client_data_t)&gt; ext);
void <strong>add_extension</strong> (std::shared_ptr&lt;plugin&gt; ext);
</pre>
<p>This function adds an extension to this <a class="reference external" href="reference-Session.html#session">session</a>. The argument is a
function object that is called with a <tt class="docutils literal">torrent_handle</tt> and which should
return a <tt class="docutils literal"><span class="pre">std::shared_ptr&lt;torrent_plugin&gt;</span></tt>. To write custom
plugins, see <a class="reference external" href="reference-Plugins.html">libtorrent plugins</a>. For the typical bittorrent client
all of these extensions should be added. The main plugins implemented
in libtorrent are:</p>
<dl class="docutils">
<dt>uTorrent metadata</dt>
<dd>Allows peers to download the metadata (.torrent files) from the swarm
directly. Makes it possible to join a swarm with just a tracker and
info-hash.</dd>
</dl>
<pre class="code c++ literal-block">
<span class="comment preproc">#include</span><span class="whitespace"> </span><span class="comment preprocfile">&lt;libtorrent/extensions/ut_metadata.hpp&gt;</span><span class="comment preproc">
</span><span class="name">ses</span><span class="punctuation">.</span><span class="name">add_extension</span><span class="punctuation">(</span><span class="operator">&amp;</span><span class="name">lt</span><span class="operator">::</span><span class="name">create_ut_metadata_plugin</span><span class="punctuation">);</span>
</pre>
<dl class="docutils">
<dt>uTorrent peer exchange</dt>
<dd>Exchanges peers between clients.</dd>
</dl>
<pre class="code c++ literal-block">
<span class="comment preproc">#include</span><span class="whitespace"> </span><span class="comment preprocfile">&lt;libtorrent/extensions/ut_pex.hpp&gt;</span><span class="comment preproc">
</span><span class="name">ses</span><span class="punctuation">.</span><span class="name">add_extension</span><span class="punctuation">(</span><span class="operator">&amp;</span><span class="name">lt</span><span class="operator">::</span><span class="name">create_ut_pex_plugin</span><span class="punctuation">);</span>
</pre>
<dl class="docutils">
<dt>smart ban <a class="reference external" href="reference-Plugins.html#plugin">plugin</a></dt>
<dd>A <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> that, with a small overhead, can ban peers
that sends bad data with very high accuracy. Should
eliminate most problems on poisoned torrents.</dd>
</dl>
<pre class="code c++ literal-block">
<span class="comment preproc">#include</span><span class="whitespace"> </span><span class="comment preprocfile">&lt;libtorrent/extensions/smart_ban.hpp&gt;</span><span class="comment preproc">
</span><span class="name">ses</span><span class="punctuation">.</span><span class="name">add_extension</span><span class="punctuation">(</span><span class="operator">&amp;</span><span class="name">lt</span><span class="operator">::</span><span class="name">create_smart_ban_plugin</span><span class="punctuation">);</span>
</pre>
<a name="get_ip_filter()"></a>
<a name="set_ip_filter()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session_handle%3A%3A%5Bget_ip_filter%28%29+set_ip_filter%28%29%5D&labels=documentation&body=Documentation+under+heading+%22session_handle%3A%3A%5Bget_ip_filter%28%29+set_ip_filter%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="get-ip-filter-set-ip-filter">
<h2>get_ip_filter() set_ip_filter()</h2>
<pre class="literal-block">
ip_filter <strong>get_ip_filter</strong> () const;
void <strong>set_ip_filter</strong> (ip_filter f);
</pre>
<p>Sets a filter that will be used to reject and accept incoming as well
as outgoing connections based on their originating ip address. The
default filter will allow connections to any ip address. To build a
set of rules for which addresses are accepted and not, see <a class="reference external" href="reference-Filter.html#ip_filter">ip_filter</a>.</p>
<p>Each time a peer is blocked because of the IP filter, a
<a class="reference external" href="reference-Alerts.html#peer_blocked_alert">peer_blocked_alert</a> is generated. <tt class="docutils literal">get_ip_filter()</tt> Returns the
<a class="reference external" href="reference-Filter.html#ip_filter">ip_filter</a> currently in the <a class="reference external" href="reference-Session.html#session">session</a>. See <a class="reference external" href="reference-Filter.html#ip_filter">ip_filter</a>.</p>
<a name="set_port_filter()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session_handle%3A%3A%5Bset_port_filter%28%29%5D&labels=documentation&body=Documentation+under+heading+%22session_handle%3A%3A%5Bset_port_filter%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="set-port-filter">
<h2>set_port_filter()</h2>
<pre class="literal-block">
void <strong>set_port_filter</strong> (port_filter const&amp; f);
</pre>
<p>apply <a class="reference external" href="reference-Filter.html#port_filter">port_filter</a> <tt class="docutils literal">f</tt> to incoming and outgoing peers. a port filter
will reject making outgoing peer connections to certain remote ports.
The main intention is to be able to avoid triggering certain
anti-virus software by connecting to SMTP, FTP ports.</p>
<a name="is_listening()"></a>
<a name="ssl_listen_port()"></a>
<a name="listen_port()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session_handle%3A%3A%5Bis_listening%28%29+ssl_listen_port%28%29+listen_port%28%29%5D&labels=documentation&body=Documentation+under+heading+%22session_handle%3A%3A%5Bis_listening%28%29+ssl_listen_port%28%29+listen_port%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="is-listening-ssl-listen-port-listen-port">
<h2>is_listening() ssl_listen_port() listen_port()</h2>
<pre class="literal-block">
bool <strong>is_listening</strong> () const;
unsigned short <strong>listen_port</strong> () const;
unsigned short <strong>ssl_listen_port</strong> () const;
</pre>
<p><tt class="docutils literal">is_listening()</tt> will tell you whether or not the <a class="reference external" href="reference-Session.html#session">session</a> has
successfully opened a listening port. If it hasn't, this function will
return false, and then you can set a new
<a class="reference external" href="reference-Settings.html#listen_interfaces">settings_pack::listen_interfaces</a> to try another interface and port to
bind to.</p>
<p><tt class="docutils literal">listen_port()</tt> returns the port we ended up listening on.</p>
<a name="set_peer_class_filter()"></a>
<a name="get_peer_class_filter()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session_handle%3A%3A%5Bset_peer_class_filter%28%29+get_peer_class_filter%28%29%5D&labels=documentation&body=Documentation+under+heading+%22session_handle%3A%3A%5Bset_peer_class_filter%28%29+get_peer_class_filter%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="set-peer-class-filter-get-peer-class-filter">
<h2>set_peer_class_filter() get_peer_class_filter()</h2>
<pre class="literal-block">
ip_filter <strong>get_peer_class_filter</strong> () const;
void <strong>set_peer_class_filter</strong> (ip_filter const&amp; f);
</pre>
<p>Sets the peer class filter for this <a class="reference external" href="reference-Session.html#session">session</a>. All new peer connections
will take this into account and be added to the peer classes specified
by this filter, based on the peer's IP address.</p>
<p>The ip-filter essentially maps an IP -&gt; uint32. Each bit in that 32
bit integer represents a peer class. The least significant bit
represents class 0, the next bit class 1 and so on.</p>
<p>For more info, see <a class="reference external" href="reference-Filter.html#ip_filter">ip_filter</a>.</p>
<p>For example, to make all peers in the range 200.1.1.0 - 200.1.255.255
belong to their own peer class, apply the following filter:</p>
<pre class="code c++ literal-block">
<span class="name">ip_filter</span><span class="whitespace"> </span><span class="name">f</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">ses</span><span class="punctuation">.</span><span class="name">get_peer_class_filter</span><span class="punctuation">();</span><span class="whitespace">
</span><span class="name">peer_class_t</span><span class="whitespace"> </span><span class="name">my_class</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">ses</span><span class="punctuation">.</span><span class="name">create_peer_class</span><span class="punctuation">(</span><span class="literal string">&quot;200.1.x.x IP range&quot;</span><span class="punctuation">);</span><span class="whitespace">
</span><span class="name">f</span><span class="punctuation">.</span><span class="name">add_rule</span><span class="punctuation">(</span><span class="name">make_address</span><span class="punctuation">(</span><span class="literal string">&quot;200.1.1.0&quot;</span><span class="punctuation">),</span><span class="whitespace"> </span><span class="name">make_address</span><span class="punctuation">(</span><span class="literal string">&quot;200.1.255.255&quot;</span><span class="punctuation">)</span><span class="whitespace">
        </span><span class="punctuation">,</span><span class="whitespace"> </span><span class="literal number integer">1</span><span class="whitespace"> </span><span class="operator">&lt;&lt;</span><span class="whitespace"> </span><span class="keyword">static_cast</span><span class="operator">&lt;</span><span class="name">std</span><span class="operator">::</span><span class="keyword type">uint32_t</span><span class="operator">&gt;</span><span class="punctuation">(</span><span class="name">my_class</span><span class="punctuation">));</span><span class="whitespace">
</span><span class="name">ses</span><span class="punctuation">.</span><span class="name">set_peer_class_filter</span><span class="punctuation">(</span><span class="name">f</span><span class="punctuation">);</span>
</pre>
<p>This setting only applies to new connections, it won't affect existing
peer connections.</p>
<p>This function is limited to only peer class 0-31, since there are only
32 bits in the IP range mapping. Only the set bits matter; no peer
class will be removed from a peer as a result of this call, peer
classes are only added.</p>
<p>The <tt class="docutils literal">peer_class</tt> argument cannot be greater than 31. The bitmasks
representing peer classes in the <tt class="docutils literal">peer_class_filter</tt> are 32 bits.</p>
<p>The <tt class="docutils literal">get_peer_class_filter()</tt> function returns the current filter.</p>
<p>For more information, see <a class="reference external" href="manual-ref.html#peer-classes">peer classes</a>.</p>
<a name="set_peer_class_type_filter()"></a>
<a name="get_peer_class_type_filter()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session_handle%3A%3A%5Bset_peer_class_type_filter%28%29+get_peer_class_type_filter%28%29%5D&labels=documentation&body=Documentation+under+heading+%22session_handle%3A%3A%5Bset_peer_class_type_filter%28%29+get_peer_class_type_filter%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="set-peer-class-type-filter-get-peer-class-type-filter">
<h2>set_peer_class_type_filter() get_peer_class_type_filter()</h2>
<pre class="literal-block">
peer_class_type_filter <strong>get_peer_class_type_filter</strong> () const;
void <strong>set_peer_class_type_filter</strong> (peer_class_type_filter const&amp; f);
</pre>
<p>Sets and gets the <em>peer class type filter</em>. This is controls automatic
peer class assignments to peers based on what kind of socket it is.</p>
<p>It does not only support assigning peer classes, it also supports
removing peer classes based on socket type.</p>
<p>The order of these rules being applied are:</p>
<ol class="arabic simple">
<li>peer-class IP filter</li>
<li>peer-class type filter, removing classes</li>
<li>peer-class type filter, adding classes</li>
</ol>
<p>For more information, see <a class="reference external" href="manual-ref.html#peer-classes">peer classes</a>.</p>
<a name="create_peer_class()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session_handle%3A%3A%5Bcreate_peer_class%28%29%5D&labels=documentation&body=Documentation+under+heading+%22session_handle%3A%3A%5Bcreate_peer_class%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="create-peer-class">
<h2>create_peer_class()</h2>
<pre class="literal-block">
peer_class_t <strong>create_peer_class</strong> (char const* name);
</pre>
<p>Creates a new peer class (see <a class="reference external" href="manual-ref.html#peer-classes">peer classes</a>) with the given name. The
returned integer is the new peer class identifier. Peer classes may
have the same name, so each invocation of this function creates a new
class and returns a unique identifier.</p>
<p>Identifiers are assigned from low numbers to higher. So if you plan on
using certain peer classes in a call to <a class="reference external" href="reference-Session.html#set_peer_class_filter()">set_peer_class_filter()</a>,
make sure to create those early on, to get low identifiers.</p>
<p>For more information on peer classes, see <a class="reference external" href="manual-ref.html#peer-classes">peer classes</a>.</p>
<a name="delete_peer_class()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session_handle%3A%3A%5Bdelete_peer_class%28%29%5D&labels=documentation&body=Documentation+under+heading+%22session_handle%3A%3A%5Bdelete_peer_class%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="delete-peer-class">
<h2>delete_peer_class()</h2>
<pre class="literal-block">
void <strong>delete_peer_class</strong> (peer_class_t cid);
</pre>
<p>This call dereferences the reference count of the specified peer
class. When creating a peer class it's automatically referenced by 1.
If you want to recycle a peer class, you may call this function. You
may only call this function <strong>once</strong> per peer class you create.
Calling it more than once for the same class will lead to memory
corruption.</p>
<p>Since peer classes are reference counted, this function will not
remove the peer class if it's still assigned to torrents or peers. It
will however remove it once the last peer and torrent drops their
references to it.</p>
<p>There is no need to call this function for custom peer classes. All
peer classes will be properly destructed when the <a class="reference external" href="reference-Session.html#session">session</a> object
destructs.</p>
<p>For more information on peer classes, see <a class="reference external" href="manual-ref.html#peer-classes">peer classes</a>.</p>
<a name="set_peer_class()"></a>
<a name="get_peer_class()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session_handle%3A%3A%5Bset_peer_class%28%29+get_peer_class%28%29%5D&labels=documentation&body=Documentation+under+heading+%22session_handle%3A%3A%5Bset_peer_class%28%29+get_peer_class%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="set-peer-class-get-peer-class">
<h2>set_peer_class() get_peer_class()</h2>
<pre class="literal-block">
peer_class_info <strong>get_peer_class</strong> (peer_class_t cid) const;
void <strong>set_peer_class</strong> (peer_class_t cid, peer_class_info const&amp; pci);
</pre>
<p>These functions queries information from a peer class and updates the
configuration of a peer class, respectively.</p>
<p><tt class="docutils literal">cid</tt> must refer to an existing peer class. If it does not, the
return value of <tt class="docutils literal">get_peer_class()</tt> is undefined.</p>
<p><tt class="docutils literal">set_peer_class()</tt> sets all the information in the
<a class="reference external" href="reference-PeerClass.html#peer_class_info">peer_class_info</a> object in the specified peer class. There is no
option to only update a single property.</p>
<p>A peer or torrent belonging to more than one class, the highest
priority among any of its classes is the one that is taken into
account.</p>
<p>For more information, see <a class="reference external" href="manual-ref.html#peer-classes">peer classes</a>.</p>
<a name="remove_torrent()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session_handle%3A%3A%5Bremove_torrent%28%29%5D&labels=documentation&body=Documentation+under+heading+%22session_handle%3A%3A%5Bremove_torrent%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="remove-torrent-1">
<h2>remove_torrent()</h2>
<pre class="literal-block">
void <strong>remove_torrent</strong> (const torrent_handle&amp;, remove_flags_t = {});
</pre>
<p><tt class="docutils literal">remove_torrent()</tt> will close all peer connections associated with
the torrent and tell the tracker that we've stopped participating in
the swarm. This operation cannot fail. When it completes, you will
receive a <a class="reference external" href="reference-Alerts.html#torrent_removed_alert">torrent_removed_alert</a>.</p>
<p><a class="reference external" href="reference-Custom_Storage.html#remove_torrent()">remove_torrent()</a> is non-blocking, but will remove the torrent from the
<a class="reference external" href="reference-Session.html#session">session</a> synchronously. Calling <a class="reference external" href="reference-Session.html#add_torrent()">session_handle::add_torrent()</a> immediately
afterward with the same torrent will succeed. Note that this creates a
new handle which is not equal to the removed one.</p>
<p>The optional second argument <tt class="docutils literal">options</tt> can be used to delete all the
files downloaded by this torrent. To do so, pass in the value
<tt class="docutils literal"><span class="pre">session_handle::delete_files</span></tt>. Once the torrent is deleted, a
<a class="reference external" href="reference-Alerts.html#torrent_deleted_alert">torrent_deleted_alert</a> is posted.</p>
<p>The <a class="reference external" href="reference-Torrent_Handle.html#torrent_handle">torrent_handle</a> remains valid for some time after <a class="reference external" href="reference-Custom_Storage.html#remove_torrent()">remove_torrent()</a> is
called. It will become invalid only after all libtorrent tasks (such as
I/O tasks) release their references to the torrent. Until this happens,
<a class="reference external" href="reference-Torrent_Handle.html#is_valid()">torrent_handle::is_valid()</a> will return true, and other calls such
as <a class="reference external" href="reference-Torrent_Handle.html#status()">torrent_handle::status()</a> will succeed. Because of this, and because
<a class="reference external" href="reference-Custom_Storage.html#remove_torrent()">remove_torrent()</a> is non-blocking, the following sequence usually
succeeds (does not throw system_error):
.. code:: c++</p>
<blockquote>
session.remove_handle(handle);
handle.save_resume_data();</blockquote>
<p>Note that when a queued or downloading torrent is removed, its position
in the download queue is vacated and every subsequent torrent in the
queue has their queue positions updated. This can potentially cause a
large state_update to be posted. When removing all torrents, it is
advised to remove them from the back of the queue, to minimize the
shifting.</p>
<a name="get_settings()"></a>
<a name="apply_settings()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session_handle%3A%3A%5Bget_settings%28%29+apply_settings%28%29%5D&labels=documentation&body=Documentation+under+heading+%22session_handle%3A%3A%5Bget_settings%28%29+apply_settings%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="get-settings-apply-settings">
<h2>get_settings() apply_settings()</h2>
<pre class="literal-block">
void <strong>apply_settings</strong> (settings_pack&amp;&amp;);
settings_pack <strong>get_settings</strong> () const;
void <strong>apply_settings</strong> (settings_pack const&amp;);
</pre>
<p>Applies the settings specified by the <a class="reference external" href="reference-Settings.html#settings_pack">settings_pack</a> <tt class="docutils literal">s</tt>. This is an
asynchronous operation that will return immediately and actually apply
the settings to the main thread of libtorrent some time later.</p>
<a name="pop_alerts()"></a>
<a name="wait_for_alert()"></a>
<a name="set_alert_notify()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session_handle%3A%3A%5Bpop_alerts%28%29+wait_for_alert%28%29+set_alert_notify%28%29%5D&labels=documentation&body=Documentation+under+heading+%22session_handle%3A%3A%5Bpop_alerts%28%29+wait_for_alert%28%29+set_alert_notify%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="pop-alerts-wait-for-alert-set-alert-notify">
<h2>pop_alerts() wait_for_alert() set_alert_notify()</h2>
<pre class="literal-block">
void <strong>set_alert_notify</strong> (std::function&lt;void()&gt; const&amp; fun);
void <strong>pop_alerts</strong> (std::vector&lt;alert*&gt;* alerts);
alert* <strong>wait_for_alert</strong> (time_duration max_wait);
</pre>
<p>Alerts is the main mechanism for libtorrent to report errors and
events. <tt class="docutils literal">pop_alerts</tt> fills in the vector passed to it with pointers
to new alerts. The <a class="reference external" href="reference-Session.html#session">session</a> still owns these alerts and they will stay
valid until the next time <tt class="docutils literal">pop_alerts</tt> is called. You may not delete
the <a class="reference external" href="reference-Alerts.html#alert">alert</a> objects.</p>
<p>It is safe to call <tt class="docutils literal">pop_alerts</tt> from multiple different threads, as
long as the alerts themselves are not accessed once another thread
calls <tt class="docutils literal">pop_alerts</tt>. Doing this requires manual synchronization
between the popping threads.</p>
<p><tt class="docutils literal">wait_for_alert</tt> will block the current thread for <tt class="docutils literal">max_wait</tt> time
duration, or until another <a class="reference external" href="reference-Alerts.html#alert">alert</a> is posted. If an <a class="reference external" href="reference-Alerts.html#alert">alert</a> is available
at the time of the call, it returns immediately. The returned <a class="reference external" href="reference-Alerts.html#alert">alert</a>
pointer is the head of the <a class="reference external" href="reference-Alerts.html#alert">alert</a> queue. <tt class="docutils literal">wait_for_alert</tt> does not
pop alerts from the queue, it merely peeks at it. The returned <a class="reference external" href="reference-Alerts.html#alert">alert</a>
will stay valid until <tt class="docutils literal">pop_alerts</tt> is called twice. The first time
will pop it and the second will free it.</p>
<p>If there is no <a class="reference external" href="reference-Alerts.html#alert">alert</a> in the queue and no <a class="reference external" href="reference-Alerts.html#alert">alert</a> arrives within the
specified timeout, <tt class="docutils literal">wait_for_alert</tt> returns nullptr.</p>
<p>In the python binding, <tt class="docutils literal">wait_for_alert</tt> takes the number of
milliseconds to wait as an integer.</p>
<p>The <a class="reference external" href="reference-Alerts.html#alert">alert</a> queue in the <a class="reference external" href="reference-Session.html#session">session</a> will not grow indefinitely. Make sure
to pop periodically to not miss notifications. To control the max
number of alerts that's queued by the <a class="reference external" href="reference-Session.html#session">session</a>, see
<tt class="docutils literal"><span class="pre">settings_pack::alert_queue_size</span></tt>.</p>
<p>Some alerts are considered so important that they are posted even when
the <a class="reference external" href="reference-Alerts.html#alert">alert</a> queue is full. Some alerts are considered mandatory and cannot
be disabled by the <tt class="docutils literal">alert_mask</tt>. For instance,
<a class="reference external" href="reference-Alerts.html#save_resume_data_alert">save_resume_data_alert</a> and <a class="reference external" href="reference-Alerts.html#save_resume_data_failed_alert">save_resume_data_failed_alert</a> are always
posted, regardless of the <a class="reference external" href="reference-Alerts.html#alert">alert</a> mask.</p>
<p>To control which alerts are posted, set the alert_mask
(<a class="reference external" href="reference-Settings.html#alert_mask">settings_pack::alert_mask</a>).</p>
<p>If the <a class="reference external" href="reference-Alerts.html#alert">alert</a> queue fills up to the point where alerts are dropped, this
will be indicated by a <a class="reference external" href="reference-Alerts.html#alerts_dropped_alert">alerts_dropped_alert</a>, which contains a bitmask
of which types of alerts were dropped. Generally it is a good idea to
make sure the <a class="reference external" href="reference-Alerts.html#alert">alert</a> queue is large enough, the alert_mask doesn't have
unnecessary categories enabled and to call pop_alert() frequently, to
avoid alerts being dropped.</p>
<p>the <tt class="docutils literal">set_alert_notify</tt> function lets the client set a function object
to be invoked every time the <a class="reference external" href="reference-Alerts.html#alert">alert</a> queue goes from having 0 alerts to
1 <a class="reference external" href="reference-Alerts.html#alert">alert</a>. This function is called from within libtorrent, it may be the
main thread, or it may be from within a user call. The intention of
of the function is that the client wakes up its main thread, to poll
for more alerts using <tt class="docutils literal">pop_alerts()</tt>. If the notify function fails
to do so, it won't be called again, until <tt class="docutils literal">pop_alerts</tt> is called for
some other reason. For instance, it could signal an eventfd, post a
message to an HWND or some other main message pump. The actual
retrieval of alerts should not be done in the callback. In fact, the
callback should not block. It should not perform any expensive work.
It really should just notify the main application thread.</p>
<p>The type of an <a class="reference external" href="reference-Alerts.html#alert">alert</a> is returned by the polymorphic function
<tt class="docutils literal"><span class="pre">alert::type()</span></tt> but can also be queries from a concrete type via
<tt class="docutils literal"><span class="pre">T::alert_type</span></tt>, as a static constant.</p>
<a name="delete_port_mapping()"></a>
<a name="add_port_mapping()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session_handle%3A%3A%5Bdelete_port_mapping%28%29+add_port_mapping%28%29%5D&labels=documentation&body=Documentation+under+heading+%22session_handle%3A%3A%5Bdelete_port_mapping%28%29+add_port_mapping%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="delete-port-mapping-add-port-mapping">
<h2>delete_port_mapping() add_port_mapping()</h2>
<pre class="literal-block">
void <strong>delete_port_mapping</strong> (port_mapping_t handle);
std::vector&lt;port_mapping_t&gt; <strong>add_port_mapping</strong> (portmap_protocol t, int external_port, int local_port);
</pre>
<p>add_port_mapping adds one or more port forwards on UPnP and/or NAT-PMP,
whichever is enabled. A mapping is created for each listen socket
in the <a class="reference external" href="reference-Session.html#session">session</a>. The return values are all handles referring to the
port mappings that were just created. Pass them to <a class="reference external" href="reference-Session.html#delete_port_mapping()">delete_port_mapping()</a>
to remove them.</p>
<a name="reopen_network_sockets()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session_handle%3A%3A%5Breopen_network_sockets%28%29%5D&labels=documentation&body=Documentation+under+heading+%22session_handle%3A%3A%5Breopen_network_sockets%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="reopen-network-sockets">
<h2>reopen_network_sockets()</h2>
<pre class="literal-block">
void <strong>reopen_network_sockets</strong> (reopen_network_flags_t options = reopen_map_ports);
</pre>
<p>Instructs the <a class="reference external" href="reference-Session.html#session">session</a> to reopen all listen and outgoing sockets.</p>
<p>It's useful in the case your platform doesn't support the built in
IP notifier mechanism, or if you have a better more reliable way to
detect changes in the IP routing table.</p>
<a name="native_handle()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session_handle%3A%3A%5Bnative_handle%28%29%5D&labels=documentation&body=Documentation+under+heading+%22session_handle%3A%3A%5Bnative_handle%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="native-handle-1">
<h2>native_handle()</h2>
<pre class="literal-block">
std::shared_ptr&lt;aux::session_impl&gt; <strong>native_handle</strong> () const;
</pre>
<p>This function is intended only for use by plugins. This type does
not have a stable API and should be relied on as little as possible.</p>
<a name="save_settings"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session_handle%3A%3A%5Bsave_settings%5D&labels=documentation&body=Documentation+under+heading+%22session_handle%3A%3A%5Bsave_settings%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>save_settings</dt>
<dd>saves settings (i.e. the <a class="reference external" href="reference-Settings.html#settings_pack">settings_pack</a>)</dd>
</dl>
<a name="save_dht_state"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session_handle%3A%3A%5Bsave_dht_state%5D&labels=documentation&body=Documentation+under+heading+%22session_handle%3A%3A%5Bsave_dht_state%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>save_dht_state</dt>
<dd>saves dht state such as nodes and node-id, possibly accelerating
joining the DHT if provided at next <a class="reference external" href="reference-Session.html#session">session</a> startup.</dd>
</dl>
<a name="save_extension_state"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session_handle%3A%3A%5Bsave_extension_state%5D&labels=documentation&body=Documentation+under+heading+%22session_handle%3A%3A%5Bsave_extension_state%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>save_extension_state</dt>
<dd>load or save state from plugins</dd>
</dl>
<a name="save_ip_filter"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session_handle%3A%3A%5Bsave_ip_filter%5D&labels=documentation&body=Documentation+under+heading+%22session_handle%3A%3A%5Bsave_ip_filter%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>save_ip_filter</dt>
<dd>load or save the IP filter set on the <a class="reference external" href="reference-Session.html#session">session</a></dd>
</dl>
<a name="global_peer_class_id"></a>
<a name="tcp_peer_class_id"></a>
<a name="local_peer_class_id"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session_handle%3A%3A%5Bglobal_peer_class_id+tcp_peer_class_id+local_peer_class_id%5D&labels=documentation&body=Documentation+under+heading+%22session_handle%3A%3A%5Bglobal_peer_class_id+tcp_peer_class_id+local_peer_class_id%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>global_peer_class_id tcp_peer_class_id local_peer_class_id</dt>
<dd>built-in peer classes</dd>
</dl>
<a name="delete_files"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session_handle%3A%3A%5Bdelete_files%5D&labels=documentation&body=Documentation+under+heading+%22session_handle%3A%3A%5Bdelete_files%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>delete_files</dt>
<dd>delete the files belonging to the torrent from disk.
including the part-file, if there is one</dd>
</dl>
<a name="delete_partfile"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session_handle%3A%3A%5Bdelete_partfile%5D&labels=documentation&body=Documentation+under+heading+%22session_handle%3A%3A%5Bdelete_partfile%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>delete_partfile</dt>
<dd>delete just the part-file associated with this torrent</dd>
</dl>
<a name="paused"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session_handle%3A%3A%5Bpaused%5D&labels=documentation&body=Documentation+under+heading+%22session_handle%3A%3A%5Bpaused%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>paused</dt>
<dd>when set, the <a class="reference external" href="reference-Session.html#session">session</a> will start paused. Call
<a class="reference external" href="reference-Session.html#resume()">session_handle::resume()</a> to start</dd>
</dl>
<a name="udp"></a>
<a name="tcp"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session_handle%3A%3A%5Budp+tcp%5D&labels=documentation&body=Documentation+under+heading+%22session_handle%3A%3A%5Budp+tcp%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>udp tcp</dt>
<dd>protocols used by <a class="reference external" href="reference-Session.html#add_port_mapping()">add_port_mapping()</a></dd>
</dl>
<a name="reopen_map_ports"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session_handle%3A%3A%5Breopen_map_ports%5D&labels=documentation&body=Documentation+under+heading+%22session_handle%3A%3A%5Breopen_map_ports%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>reopen_map_ports</dt>
<dd>This option indicates if the ports are mapped using natpmp
and upnp. If mapping was already made, they are deleted and added
again. This only works if natpmp and/or upnp are configured to be
enable.</dd>
</dl>
<a name="write_session_params_buf()"></a>
<a name="write_session_params()"></a>
<a name="read_session_params()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:write_session_params_buf%28%29+write_session_params%28%29+read_session_params%28%29&labels=documentation&body=Documentation+under+heading+%22write_session_params_buf%28%29+write_session_params%28%29+read_session_params%28%29%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="write-session-params-buf-write-session-params-read-session-params">
<h1>write_session_params_buf() write_session_params() read_session_params()</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/session_params.hpp">libtorrent/session_params.hpp</a>&quot;</p>
<pre class="literal-block">
entry <strong>write_session_params</strong> (session_params const&amp; sp
   , save_state_flags_t flags = save_state_flags_t::all());
session_params <strong>read_session_params</strong> (span&lt;char const&gt; buf
   , save_state_flags_t flags = save_state_flags_t::all());
session_params <strong>read_session_params</strong> (bdecode_node const&amp; e
   , save_state_flags_t flags = save_state_flags_t::all());
std::vector&lt;char&gt; <strong>write_session_params_buf</strong> (session_params const&amp; sp
   , save_state_flags_t flags = save_state_flags_t::all());
</pre>
<p>These functions serialize and de-serialize a <tt class="docutils literal">session_params</tt> object to and
from bencoded form. The <a class="reference external" href="reference-Session.html#session_params">session_params</a> object is used to initialize a new
<a class="reference external" href="reference-Session.html#session">session</a> using the state from a previous one (or by programmatically configure
the <a class="reference external" href="reference-Session.html#session">session</a> up-front).
The flags parameter can be used to only save and load certain aspects of the
session's state.
The <tt class="docutils literal">_buf</tt> suffix indicates the function operates on buffer rather than the
bencoded structure.
The torrents in a <a class="reference external" href="reference-Session.html#session">session</a> are not part of the <a class="reference external" href="reference-Session.html#session_params">session_params</a> state, they have
to be restored separately.</p>
<a name="counters"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+counters&labels=documentation&body=Documentation+under+heading+%22class+counters%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="counters-1">
<h1>counters</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/performance_counters.hpp">libtorrent/performance_counters.hpp</a>&quot;</p>
<pre class="literal-block">
struct counters
{
   <strong>counters</strong> () ;
   <strong>counters</strong> (counters const&amp;) ;
   counters&amp; <strong>operator=</strong> (counters const&amp;) &amp; ;
   std::int64_t <strong>inc_stats_counter</strong> (int c, std::int64_t value = 1) ;
   std::int64_t <strong>operator[]</strong> (int i) const ;
   void <strong>set_value</strong> (int c, std::int64_t value) ;
   void <strong>blend_stats_counter</strong> (int c, std::int64_t value, int ratio) ;
};
</pre>
<a name="inc_stats_counter()"></a>
<a name="operator[]()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:counters%3A%3A%5Binc_stats_counter%28%29+operator%5B%5D%28%29%5D&labels=documentation&body=Documentation+under+heading+%22counters%3A%3A%5Binc_stats_counter%28%29+operator%5B%5D%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="inc-stats-counter-operator">
<h2>inc_stats_counter() operator[]()</h2>
<pre class="literal-block">
std::int64_t <strong>inc_stats_counter</strong> (int c, std::int64_t value = 1) ;
std::int64_t <strong>operator[]</strong> (int i) const ;
</pre>
<p>returns the new value</p>
<a name="stats_metric"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+stats_metric&labels=documentation&body=Documentation+under+heading+%22class+stats_metric%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="stats-metric">
<h1>stats_metric</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/session_stats.hpp">libtorrent/session_stats.hpp</a>&quot;</p>
<p>describes one statistics metric from the <a class="reference external" href="reference-Session.html#session">session</a>. For more information,
see the <a class="reference external" href="manual-ref.html#session-statistics">session statistics</a> section.</p>
<pre class="literal-block">
struct stats_metric
{
   char const* name;
   int value_index;
   metric_type_t type;
};
</pre>
<a name="name"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:stats_metric%3A%3A%5Bname%5D&labels=documentation&body=Documentation+under+heading+%22stats_metric%3A%3A%5Bname%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>name</dt>
<dd>the name of the counter or gauge</dd>
</dl>
<a name="value_index"></a>
<a name="type"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:stats_metric%3A%3A%5Bvalue_index+type%5D&labels=documentation&body=Documentation+under+heading+%22stats_metric%3A%3A%5Bvalue_index+type%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>value_index type</dt>
<dd>the index into the <a class="reference external" href="reference-Session.html#session">session</a> stats array, where the underlying value of
this counter or gauge is found. The <a class="reference external" href="reference-Session.html#session">session</a> stats array is part of the
<a class="reference external" href="reference-Alerts.html#session_stats_alert">session_stats_alert</a> object.</dd>
</dl>
<a name="session_stats_metrics()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:session_stats_metrics%28%29&labels=documentation&body=Documentation+under+heading+%22session_stats_metrics%28%29%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="session-stats-metrics">
<h1>session_stats_metrics()</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/session_stats.hpp">libtorrent/session_stats.hpp</a>&quot;</p>
<pre class="literal-block">
std::vector&lt;stats_metric&gt; <strong>session_stats_metrics</strong> ();
</pre>
<p>This free function returns the list of available metrics exposed by
libtorrent's statistics API. Each metric has a name and a <em>value index</em>.
The value index is the index into the array in <a class="reference external" href="reference-Alerts.html#session_stats_alert">session_stats_alert</a> where
this metric's value can be found when the <a class="reference external" href="reference-Session.html#session">session</a> stats is sampled (by
calling <a class="reference external" href="reference-Session.html#post_session_stats()">post_session_stats()</a>).</p>
<a name="find_metric_idx()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:find_metric_idx%28%29&labels=documentation&body=Documentation+under+heading+%22find_metric_idx%28%29%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="find-metric-idx">
<h1>find_metric_idx()</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/session_stats.hpp">libtorrent/session_stats.hpp</a>&quot;</p>
<pre class="literal-block">
int <strong>find_metric_idx</strong> (string_view name);
</pre>
<p>given a name of a metric, this function returns the counter index of it,
or -1 if it could not be found. The counter index is the index into the
values array returned by <a class="reference external" href="reference-Alerts.html#session_stats_alert">session_stats_alert</a>.</p>
<a name="metric_type_t"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+metric_type_t&labels=documentation&body=Documentation+under+heading+%22enum+metric_type_t%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-metric-type-t">
<h1>enum metric_type_t</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/session_stats.hpp">libtorrent/session_stats.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="24%" />
<col width="45%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>counter</td>
<td>0</td>
<td>&nbsp;</td>
</tr>
<tr><td>gauge</td>
<td>1</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<a name="peer_request"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+peer_request&labels=documentation&body=Documentation+under+heading+%22class+peer_request%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="peer-request">
<h1>peer_request</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/peer_request.hpp">libtorrent/peer_request.hpp</a>&quot;</p>
<p>represents a byte range within a piece. Internally this is is used for
incoming piece requests.</p>
<pre class="literal-block">
struct peer_request
{
   bool <strong>operator==</strong> (peer_request const&amp; r) const;

   piece_index_t piece;
   int start;
   int length;
};
</pre>
<a name="operator==()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_request%3A%3A%5Boperator%3D%3D%28%29%5D&labels=documentation&body=Documentation+under+heading+%22peer_request%3A%3A%5Boperator%3D%3D%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="operator">
<h2>operator==()</h2>
<pre class="literal-block">
bool <strong>operator==</strong> (peer_request const&amp; r) const;
</pre>
<p>returns true if the right hand side <a class="reference external" href="reference-Core.html#peer_request">peer_request</a> refers to the same
range as this does.</p>
<a name="piece"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_request%3A%3A%5Bpiece%5D&labels=documentation&body=Documentation+under+heading+%22peer_request%3A%3A%5Bpiece%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>piece</dt>
<dd>The index of the piece in which the range starts.</dd>
</dl>
<a name="start"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_request%3A%3A%5Bstart%5D&labels=documentation&body=Documentation+under+heading+%22peer_request%3A%3A%5Bstart%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>start</dt>
<dd>The byte offset within that piece where the range starts.</dd>
</dl>
<a name="length"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_request%3A%3A%5Blength%5D&labels=documentation&body=Documentation+under+heading+%22peer_request%3A%3A%5Blength%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>length</dt>
<dd>The size of the range, in bytes.</dd>
</dl>
<a name="peer_info"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+peer_info&labels=documentation&body=Documentation+under+heading+%22class+peer_info%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="peer-info">
<h1>peer_info</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/peer_info.hpp">libtorrent/peer_info.hpp</a>&quot;</p>
<p>holds information and statistics about one peer
that libtorrent is connected to</p>
<pre class="literal-block">
struct peer_info
{
   sha256_hash <strong>i2p_destination</strong> () const;

   std::string client;
   typed_bitfield&lt;piece_index_t&gt; pieces;
   std::int64_t total_download;
   std::int64_t total_upload;
   time_duration last_request;
   time_duration last_active;
   time_duration download_queue_time;
   static constexpr peer_flags_t <strong>interesting</strong>  = 0_bit;
   static constexpr peer_flags_t <strong>choked</strong>  = 1_bit;
   static constexpr peer_flags_t <strong>remote_interested</strong>  = 2_bit;
   static constexpr peer_flags_t <strong>remote_choked</strong>  = 3_bit;
   static constexpr peer_flags_t <strong>supports_extensions</strong>  = 4_bit;
   static constexpr peer_flags_t <strong>outgoing_connection</strong>  = 5_bit;
   static constexpr peer_flags_t <strong>local_connection</strong>  = 5_bit;
   static constexpr peer_flags_t <strong>handshake</strong>  = 6_bit;
   static constexpr peer_flags_t <strong>connecting</strong>  = 7_bit;
   static constexpr peer_flags_t <strong>on_parole</strong>  = 9_bit;
   static constexpr peer_flags_t <strong>seed</strong>  = 10_bit;
   static constexpr peer_flags_t <strong>optimistic_unchoke</strong>  = 11_bit;
   static constexpr peer_flags_t <strong>snubbed</strong>  = 12_bit;
   static constexpr peer_flags_t <strong>upload_only</strong>  = 13_bit;
   static constexpr peer_flags_t <strong>endgame_mode</strong>  = 14_bit;
   static constexpr peer_flags_t <strong>holepunched</strong>  = 15_bit;
   static constexpr peer_flags_t <strong>i2p_socket</strong>  = 16_bit;
   static constexpr peer_flags_t <strong>utp_socket</strong>  = 17_bit;
   static constexpr peer_flags_t <strong>ssl_socket</strong>  = 18_bit;
   static constexpr peer_flags_t <strong>rc4_encrypted</strong>  = 19_bit;
   static constexpr peer_flags_t <strong>plaintext_encrypted</strong>  = 20_bit;
   peer_flags_t flags;
   static constexpr peer_source_flags_t <strong>tracker</strong>  = 0_bit;
   static constexpr peer_source_flags_t <strong>dht</strong>  = 1_bit;
   static constexpr peer_source_flags_t <strong>pex</strong>  = 2_bit;
   static constexpr peer_source_flags_t <strong>lsd</strong>  = 3_bit;
   static constexpr peer_source_flags_t <strong>resume_data</strong>  = 4_bit;
   static constexpr peer_source_flags_t <strong>incoming</strong>  = 5_bit;
   peer_source_flags_t source;
   int up_speed;
   int down_speed;
   int payload_up_speed;
   int payload_down_speed;
   peer_id pid;
   int queue_bytes;
   int request_timeout;
   int send_buffer_size;
   int used_send_buffer;
   int receive_buffer_size;
   int used_receive_buffer;
   int receive_buffer_watermark;
   int num_hashfails;
   int download_queue_length;
   int timed_out_requests;
   int busy_requests;
   int requests_in_buffer;
   int target_dl_queue_length;
   int upload_queue_length;
   int failcount;
   piece_index_t downloading_piece_index;
   int downloading_block_index;
   int downloading_progress;
   int downloading_total;
   static constexpr connection_type_t <strong>standard_bittorrent</strong>  = 0_bit;
   static constexpr connection_type_t <strong>web_seed</strong>  = 1_bit;
   static constexpr connection_type_t <strong>http_seed</strong>  = 2_bit;
   connection_type_t connection_type;
   int pending_disk_bytes;
   int pending_disk_read_bytes;
   int send_quota;
   int receive_quota;
   int rtt;
   int num_pieces;
   int download_rate_peak;
   int upload_rate_peak;
   float progress;
   int progress_ppm;
   <a class="reference external" href="tcp::endpoint">tcp::endpoint</a> ip;
   <a class="reference external" href="tcp::endpoint">tcp::endpoint</a> local_endpoint;
   static constexpr bandwidth_state_flags_t <strong>bw_idle</strong>  = 0_bit;
   static constexpr bandwidth_state_flags_t <strong>bw_limit</strong>  = 1_bit;
   static constexpr bandwidth_state_flags_t <strong>bw_network</strong>  = 2_bit;
   static constexpr bandwidth_state_flags_t <strong>bw_disk</strong>  = 4_bit;
   bandwidth_state_flags_t read_state;
   bandwidth_state_flags_t write_state;
};
</pre>
<a name="i2p_destination()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bi2p_destination%28%29%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bi2p_destination%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="i2p-destination">
<h2>i2p_destination()</h2>
<pre class="literal-block">
sha256_hash <strong>i2p_destination</strong> () const;
</pre>
<p>If this peer is an i2p peer, this function returns the destination
address of the peer</p>
<a name="client"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bclient%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bclient%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>client</dt>
<dd>A human readable string describing the software at the other end of
the connection. In some cases this information is not available, then
it will contain a string that may give away something about which
software is running in the other end. In the case of a web seed, the
server type and version will be a part of this string. This is UTF-8
encoded.</dd>
</dl>
<a name="pieces"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bpieces%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bpieces%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>pieces</dt>
<dd>a <a class="reference external" href="reference-Utility.html#bitfield">bitfield</a>, with one bit per piece in the torrent. Each bit tells you
if the peer has that piece (if it's set to 1) or if the peer miss that
piece (set to 0).</dd>
</dl>
<a name="total_download"></a>
<a name="total_upload"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Btotal_download+total_upload%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Btotal_download+total_upload%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>total_download total_upload</dt>
<dd>the total number of bytes downloaded from and uploaded to this peer.
These numbers do not include the protocol chatter, but only the
payload data.</dd>
</dl>
<a name="last_request"></a>
<a name="last_active"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Blast_request+last_active%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Blast_request+last_active%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>last_request last_active</dt>
<dd>the time since we last sent a request to this peer and since any
transfer occurred with this peer</dd>
</dl>
<a name="download_queue_time"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bdownload_queue_time%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bdownload_queue_time%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>download_queue_time</dt>
<dd>the time until all blocks in the request queue will be downloaded</dd>
</dl>
<a name="interesting"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Binteresting%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Binteresting%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>interesting</dt>
<dd><strong>we</strong> are interested in pieces from this peer.</dd>
</dl>
<a name="choked"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bchoked%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bchoked%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>choked</dt>
<dd><strong>we</strong> have choked this peer.</dd>
</dl>
<a name="remote_interested"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bremote_interested%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bremote_interested%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>remote_interested</dt>
<dd>the peer is interested in <strong>us</strong></dd>
</dl>
<a name="remote_choked"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bremote_choked%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bremote_choked%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>remote_choked</dt>
<dd>the peer has choked <strong>us</strong>.</dd>
</dl>
<a name="supports_extensions"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bsupports_extensions%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bsupports_extensions%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>supports_extensions</dt>
<dd>means that this peer supports the
<a class="reference external" href="extension_protocol.html">extension protocol</a>.</dd>
</dl>
<a name="outgoing_connection"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Boutgoing_connection%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Boutgoing_connection%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>outgoing_connection</dt>
<dd>The connection was initiated by us, the peer has a
listen port open, and that port is the same as in the
address of this peer. If this flag is not set, this
peer connection was opened by this peer connecting to
us.</dd>
</dl>
<a name="local_connection"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Blocal_connection%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Blocal_connection%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>local_connection</dt>
<dd>deprecated synonym for outgoing_connection</dd>
</dl>
<a name="handshake"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bhandshake%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bhandshake%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>handshake</dt>
<dd>The connection is opened, and waiting for the
handshake. Until the handshake is done, the peer
cannot be identified.</dd>
</dl>
<a name="connecting"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bconnecting%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bconnecting%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>connecting</dt>
<dd>The connection is in a half-open state (i.e. it is
being connected).</dd>
</dl>
<a name="on_parole"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bon_parole%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bon_parole%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>on_parole</dt>
<dd>The peer has participated in a piece that failed the
hash check, and is now &quot;on parole&quot;, which means we're
only requesting whole pieces from this peer until
it either fails that piece or proves that it doesn't
send bad data.</dd>
</dl>
<a name="seed"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bseed%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bseed%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>seed</dt>
<dd>This peer is a seed (it has all the pieces).</dd>
</dl>
<a name="optimistic_unchoke"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Boptimistic_unchoke%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Boptimistic_unchoke%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>optimistic_unchoke</dt>
<dd>This peer is subject to an optimistic unchoke. It has
been unchoked for a while to see if it might unchoke
us in return an earn an upload/unchoke slot. If it
doesn't within some period of time, it will be choked
and another peer will be optimistically unchoked.</dd>
</dl>
<a name="snubbed"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bsnubbed%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bsnubbed%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>snubbed</dt>
<dd>This peer has recently failed to send a block within
the request timeout from when the request was sent.
We're currently picking one block at a time from this
peer.</dd>
</dl>
<a name="upload_only"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bupload_only%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bupload_only%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>upload_only</dt>
<dd>This peer has either explicitly (with an extension)
or implicitly (by becoming a seed) told us that it
will not downloading anything more, regardless of
which pieces we have.</dd>
</dl>
<a name="endgame_mode"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bendgame_mode%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bendgame_mode%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>endgame_mode</dt>
<dd>This means the last time this peer picket a piece,
it could not pick as many as it wanted because there
were not enough free ones. i.e. all pieces this peer
has were already requested from other peers.</dd>
</dl>
<a name="holepunched"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bholepunched%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bholepunched%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>holepunched</dt>
<dd>This flag is set if the peer was in holepunch mode
when the connection succeeded. This typically only
happens if both peers are behind a NAT and the peers
connect via the NAT holepunch mechanism.</dd>
</dl>
<a name="i2p_socket"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bi2p_socket%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bi2p_socket%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>i2p_socket</dt>
<dd>indicates that this socket is running on top of the
I2P transport.</dd>
</dl>
<a name="utp_socket"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Butp_socket%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Butp_socket%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>utp_socket</dt>
<dd>indicates that this socket is a uTP socket</dd>
</dl>
<a name="ssl_socket"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bssl_socket%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bssl_socket%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>ssl_socket</dt>
<dd>indicates that this socket is running on top of an SSL
(TLS) channel</dd>
</dl>
<a name="rc4_encrypted"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Brc4_encrypted%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Brc4_encrypted%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>rc4_encrypted</dt>
<dd>this connection is obfuscated with RC4</dd>
</dl>
<a name="plaintext_encrypted"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bplaintext_encrypted%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bplaintext_encrypted%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>plaintext_encrypted</dt>
<dd>the handshake of this connection was obfuscated
with a Diffie-Hellman exchange</dd>
</dl>
<a name="flags"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bflags%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bflags%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>flags</dt>
<dd>tells you in which state the peer is in. It is set to
any combination of the peer_flags_t flags above.</dd>
</dl>
<a name="tracker"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Btracker%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Btracker%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>tracker</dt>
<dd>The peer was received from the tracker.</dd>
</dl>
<a name="dht"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bdht%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bdht%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>dht</dt>
<dd>The peer was received from the kademlia DHT.</dd>
</dl>
<a name="pex"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bpex%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bpex%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>pex</dt>
<dd>The peer was received from the peer exchange
extension.</dd>
</dl>
<a name="lsd"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Blsd%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Blsd%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>lsd</dt>
<dd>The peer was received from the local service
discovery (The peer is on the local network).</dd>
</dl>
<a name="resume_data"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bresume_data%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bresume_data%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>resume_data</dt>
<dd>The peer was added from the fast resume data.</dd>
</dl>
<a name="incoming"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bincoming%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bincoming%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>incoming</dt>
<dd>we received an incoming connection from this peer</dd>
</dl>
<a name="source"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bsource%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bsource%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>source</dt>
<dd>a combination of flags describing from which sources this peer
was received. A combination of the peer_source_flags_t above.</dd>
</dl>
<a name="up_speed"></a>
<a name="down_speed"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bup_speed+down_speed%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bup_speed+down_speed%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>up_speed down_speed</dt>
<dd>the current upload and download speed we have to and from this peer
(including any protocol messages). updated about once per second</dd>
</dl>
<a name="payload_up_speed"></a>
<a name="payload_down_speed"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bpayload_up_speed+payload_down_speed%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bpayload_up_speed+payload_down_speed%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>payload_up_speed payload_down_speed</dt>
<dd>The transfer rates of payload data only updated about once per second</dd>
</dl>
<a name="pid"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bpid%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bpid%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>pid</dt>
<dd>the peer's id as used in the bittorrent protocol. This id can be used
to extract 'fingerprints' from the peer. Sometimes it can tell you
which client the peer is using. See identify_client()_</dd>
</dl>
<a name="queue_bytes"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bqueue_bytes%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bqueue_bytes%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>queue_bytes</dt>
<dd>the number of bytes we have requested from this peer, but not yet
received.</dd>
</dl>
<a name="request_timeout"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Brequest_timeout%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Brequest_timeout%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>request_timeout</dt>
<dd>the number of seconds until the current front piece request will time
out. This timeout can be adjusted through
<tt class="docutils literal"><span class="pre">settings_pack::request_timeout</span></tt>.
-1 means that there is not outstanding request.</dd>
</dl>
<a name="send_buffer_size"></a>
<a name="used_send_buffer"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bsend_buffer_size+used_send_buffer%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bsend_buffer_size+used_send_buffer%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>send_buffer_size used_send_buffer</dt>
<dd>the number of bytes allocated
and used for the peer's send buffer, respectively.</dd>
</dl>
<a name="receive_buffer_size"></a>
<a name="used_receive_buffer"></a>
<a name="receive_buffer_watermark"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Breceive_buffer_size+used_receive_buffer+receive_buffer_watermark%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Breceive_buffer_size+used_receive_buffer+receive_buffer_watermark%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>receive_buffer_size used_receive_buffer receive_buffer_watermark</dt>
<dd>the number of bytes
allocated and used as receive buffer, respectively.</dd>
</dl>
<a name="num_hashfails"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bnum_hashfails%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bnum_hashfails%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>num_hashfails</dt>
<dd>the number of pieces this peer has participated in sending us that
turned out to fail the hash check.</dd>
</dl>
<a name="download_queue_length"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bdownload_queue_length%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bdownload_queue_length%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>download_queue_length</dt>
<dd>this is the number of requests we have sent to this peer that we
haven't got a response for yet</dd>
</dl>
<a name="timed_out_requests"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Btimed_out_requests%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Btimed_out_requests%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>timed_out_requests</dt>
<dd>the number of block requests that have timed out, and are still in the
download queue</dd>
</dl>
<a name="busy_requests"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bbusy_requests%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bbusy_requests%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>busy_requests</dt>
<dd>the number of busy requests in the download queue. A busy request is a
request for a block we've also requested from a different peer</dd>
</dl>
<a name="requests_in_buffer"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Brequests_in_buffer%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Brequests_in_buffer%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>requests_in_buffer</dt>
<dd>the number of requests messages that are currently in the send buffer
waiting to be sent.</dd>
</dl>
<a name="target_dl_queue_length"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Btarget_dl_queue_length%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Btarget_dl_queue_length%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>target_dl_queue_length</dt>
<dd>the number of requests that is tried to be maintained (this is
typically a function of download speed)</dd>
</dl>
<a name="upload_queue_length"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bupload_queue_length%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bupload_queue_length%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>upload_queue_length</dt>
<dd>the number of piece-requests we have received from this peer
that we haven't answered with a piece yet.</dd>
</dl>
<a name="failcount"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bfailcount%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bfailcount%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>failcount</dt>
<dd>the number of times this peer has &quot;failed&quot;. i.e. failed to connect or
disconnected us. The failcount is decremented when we see this peer in
a tracker response or peer exchange message.</dd>
</dl>
<a name="downloading_piece_index"></a>
<a name="downloading_block_index"></a>
<a name="downloading_progress"></a>
<a name="downloading_total"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bdownloading_piece_index+downloading_block_index+downloading_progress+downloading_total%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bdownloading_piece_index+downloading_block_index+downloading_progress+downloading_total%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>downloading_piece_index downloading_block_index downloading_progress downloading_total</dt>
<dd>You can know which piece, and which part of that piece, that is
currently being downloaded from a specific peer by looking at these
four members. <tt class="docutils literal">downloading_piece_index</tt> is the index of the piece
that is currently being downloaded. This may be set to -1 if there's
currently no piece downloading from this peer. If it is &gt;= 0, the
other three members are valid. <tt class="docutils literal">downloading_block_index</tt> is the
index of the block (or sub-piece) that is being downloaded.
<tt class="docutils literal">downloading_progress</tt> is the number of bytes of this block we have
received from the peer, and <tt class="docutils literal">downloading_total</tt> is the total number
of bytes in this block.</dd>
</dl>
<a name="standard_bittorrent"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bstandard_bittorrent%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bstandard_bittorrent%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>standard_bittorrent</dt>
<dd>Regular bittorrent connection</dd>
</dl>
<a name="web_seed"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bweb_seed%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bweb_seed%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>web_seed</dt>
<dd>HTTP connection using the <a class="reference external" href="https://www.bittorrent.org/beps/bep_0019.html">BEP 19</a> protocol</dd>
</dl>
<a name="http_seed"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bhttp_seed%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bhttp_seed%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>http_seed</dt>
<dd>HTTP connection using the <a class="reference external" href="https://www.bittorrent.org/beps/bep_0017.html">BEP 17</a> protocol</dd>
</dl>
<a name="connection_type"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bconnection_type%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bconnection_type%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>connection_type</dt>
<dd>the kind of connection this peer uses. See connection_type_t.</dd>
</dl>
<a name="pending_disk_bytes"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bpending_disk_bytes%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bpending_disk_bytes%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>pending_disk_bytes</dt>
<dd>the number of bytes this peer has pending in the disk-io thread.
Downloaded and waiting to be written to disk. This is what is capped
by <tt class="docutils literal"><span class="pre">settings_pack::max_queued_disk_bytes</span></tt>.</dd>
</dl>
<a name="pending_disk_read_bytes"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bpending_disk_read_bytes%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bpending_disk_read_bytes%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>pending_disk_read_bytes</dt>
<dd>number of outstanding bytes to read
from disk</dd>
</dl>
<a name="send_quota"></a>
<a name="receive_quota"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bsend_quota+receive_quota%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bsend_quota+receive_quota%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>send_quota receive_quota</dt>
<dd>the number of bytes this peer has been assigned to be allowed to send
and receive until it has to request more quota from the bandwidth
manager.</dd>
</dl>
<a name="rtt"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Brtt%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Brtt%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>rtt</dt>
<dd>an estimated round trip time to this peer, in milliseconds. It is
estimated by timing the TCP <tt class="docutils literal">connect()</tt>. It may be 0 for
incoming connections.</dd>
</dl>
<a name="num_pieces"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bnum_pieces%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bnum_pieces%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>num_pieces</dt>
<dd>the number of pieces this peer has.</dd>
</dl>
<a name="download_rate_peak"></a>
<a name="upload_rate_peak"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bdownload_rate_peak+upload_rate_peak%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bdownload_rate_peak+upload_rate_peak%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>download_rate_peak upload_rate_peak</dt>
<dd>the highest download and upload rates seen on this connection. They
are given in bytes per second. This number is reset to 0 on reconnect.</dd>
</dl>
<a name="progress"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bprogress%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bprogress%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>progress</dt>
<dd>the progress of the peer in the range [0, 1]. This is always 0 when
floating point operations are disabled, instead use <tt class="docutils literal">progress_ppm</tt>.</dd>
</dl>
<a name="progress_ppm"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bprogress_ppm%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bprogress_ppm%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>progress_ppm</dt>
<dd>indicates the download progress of the peer in the range [0, 1000000]
(parts per million).</dd>
</dl>
<a name="ip"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bip%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bip%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>ip</dt>
<dd>the IP-address to this peer. The type is an asio endpoint. For
more info, see the <a class="reference external" href="http://asio.sourceforge.net/asio-0.3.8/doc/asio/reference.html">asio</a> documentation. This field is not valid for
i2p peers. Instead use the <a class="reference external" href="reference-Core.html#i2p_destination()">i2p_destination()</a> function.</dd>
</dl>
<a name="local_endpoint"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Blocal_endpoint%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Blocal_endpoint%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>local_endpoint</dt>
<dd>the IP and port pair the socket is bound to locally. i.e. the IP
address of the interface it's going out over. This may be useful for
multi-homed clients with multiple interfaces to the internet.
This field is not valid for i2p peers.</dd>
</dl>
<a name="bw_idle"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bbw_idle%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bbw_idle%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>bw_idle</dt>
<dd>The peer is not waiting for any external events to
send or receive data.</dd>
</dl>
<a name="bw_limit"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bbw_limit%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bbw_limit%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>bw_limit</dt>
<dd>The peer is waiting for the rate limiter.</dd>
</dl>
<a name="bw_network"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bbw_network%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bbw_network%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>bw_network</dt>
<dd>The peer has quota and is currently waiting for a
network read or write operation to complete. This is
the state all peers are in if there are no bandwidth
limits.</dd>
</dl>
<a name="bw_disk"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bbw_disk%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bbw_disk%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>bw_disk</dt>
<dd>The peer is waiting for the disk I/O thread to catch
up writing buffers to disk before downloading more.</dd>
</dl>
<a name="read_state"></a>
<a name="write_state"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bread_state+write_state%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bread_state+write_state%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>read_state write_state</dt>
<dd>bitmasks indicating what state this peer
is in with regards to sending and receiving data. The states are
defined as independent flags of type bandwidth_state_flags_t, in this
class.</dd>
</dl>
<a name="info_hash_t"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+info_hash_t&labels=documentation&body=Documentation+under+heading+%22class+info_hash_t%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="info-hash-t">
<h1>info_hash_t</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/info_hash.hpp">libtorrent/info_hash.hpp</a>&quot;</p>
<p>class holding the info-hash of a torrent. It can hold a v1 info-hash
(SHA-1) or a v2 info-hash (SHA-256) or both.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If <tt class="docutils literal">has_v2()</tt> is false then the v1 hash might actually be a truncated
v2 hash</p>
</div>
<pre class="literal-block">
struct info_hash_t
{
   explicit <strong>info_hash_t</strong> (sha256_hash h2) noexcept;
   <strong>info_hash_t</strong> () noexcept = default;
   <strong>info_hash_t</strong> (sha1_hash h1, sha256_hash h2) noexcept;
   explicit <strong>info_hash_t</strong> (sha1_hash h1) noexcept;
   bool <strong>has</strong> (protocol_version v) const;
   bool <strong>has_v2</strong> () const;
   bool <strong>has_v1</strong> () const;
   sha1_hash <strong>get</strong> (protocol_version v) const;
   sha1_hash <strong>get_best</strong> () const;
   friend bool <strong>operator!=</strong> (info_hash_t const&amp; lhs, info_hash_t const&amp; rhs);
   friend bool <strong>operator==</strong> (info_hash_t const&amp; lhs, info_hash_t const&amp; rhs) noexcept;
   template &lt;typename F&gt; void <strong>for_each</strong> (F f) const;
   bool <strong>operator&lt;</strong> (info_hash_t const&amp; o) const;
   friend std::ostream&amp; <strong>operator&lt;&lt;</strong> (std::ostream&amp; os, info_hash_t const&amp; ih);

   sha1_hash v1;
   sha256_hash v2;
};
</pre>
<a name="info_hash_t()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:info_hash_t%3A%3A%5Binfo_hash_t%28%29%5D&labels=documentation&body=Documentation+under+heading+%22info_hash_t%3A%3A%5Binfo_hash_t%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="info-hash-t-1">
<h2>info_hash_t()</h2>
<pre class="literal-block">
explicit <strong>info_hash_t</strong> (sha256_hash h2) noexcept;
<strong>info_hash_t</strong> () noexcept = default;
<strong>info_hash_t</strong> (sha1_hash h1, sha256_hash h2) noexcept;
explicit <strong>info_hash_t</strong> (sha1_hash h1) noexcept;
</pre>
<p>The default constructor creates an object that has neither a v1 or v2
hash.</p>
<p>For backwards compatibility, make it possible to construct directly
from a v1 hash. This constructor allows <em>implicit</em> conversion from a
v1 hash, but the implicitness is deprecated.</p>
<a name="has_v1()"></a>
<a name="has()"></a>
<a name="has_v2()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:info_hash_t%3A%3A%5Bhas_v1%28%29+has%28%29+has_v2%28%29%5D&labels=documentation&body=Documentation+under+heading+%22info_hash_t%3A%3A%5Bhas_v1%28%29+has%28%29+has_v2%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="has-v1-has-has-v2">
<h2>has_v1() has() has_v2()</h2>
<pre class="literal-block">
bool <strong>has</strong> (protocol_version v) const;
bool <strong>has_v2</strong> () const;
bool <strong>has_v1</strong> () const;
</pre>
<p>returns true if the corresponding info hash is present in this
object.</p>
<a name="get()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:info_hash_t%3A%3A%5Bget%28%29%5D&labels=documentation&body=Documentation+under+heading+%22info_hash_t%3A%3A%5Bget%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="get">
<h2>get()</h2>
<pre class="literal-block">
sha1_hash <strong>get</strong> (protocol_version v) const;
</pre>
<p>returns the has for the specified protocol version</p>
<a name="get_best()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:info_hash_t%3A%3A%5Bget_best%28%29%5D&labels=documentation&body=Documentation+under+heading+%22info_hash_t%3A%3A%5Bget_best%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="get-best">
<h2>get_best()</h2>
<pre class="literal-block">
sha1_hash <strong>get_best</strong> () const;
</pre>
<p>returns the v2 (truncated) info-hash, if there is one, otherwise
returns the v1 info-hash</p>
<a name="for_each()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:info_hash_t%3A%3A%5Bfor_each%28%29%5D&labels=documentation&body=Documentation+under+heading+%22info_hash_t%3A%3A%5Bfor_each%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="for-each">
<h2>for_each()</h2>
<pre class="literal-block">
template &lt;typename F&gt; void <strong>for_each</strong> (F f) const;
</pre>
<p>calls the function object <tt class="docutils literal">f</tt> for each hash that is available.
starting with v1. The signature of <tt class="docutils literal">F</tt> is:</p>
<pre class="literal-block">
void(sha1_hash const&amp;, protocol_version);
</pre>
<a name="piece_block"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+piece_block&labels=documentation&body=Documentation+under+heading+%22class+piece_block%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="piece-block">
<h1>piece_block</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/piece_block.hpp">libtorrent/piece_block.hpp</a>&quot;</p>
<pre class="literal-block">
struct piece_block
{
   <strong>piece_block</strong> (piece_index_t p_index, int b_index);
   <strong>piece_block</strong> () = default;
   bool <strong>operator&lt;</strong> (piece_block const&amp; b) const;
   bool <strong>operator==</strong> (piece_block const&amp; b) const;
   bool <strong>operator!=</strong> (piece_block const&amp; b) const;

   static const piece_block invalid;
   piece_index_t piece_index {0};
   int <strong>block_index</strong>  = 0;
};
</pre>
<a name="load_torrent_parsed()"></a>
<a name="load_torrent_file()"></a>
<a name="load_torrent_buffer()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:load_torrent_parsed%28%29+load_torrent_file%28%29+load_torrent_buffer%28%29&labels=documentation&body=Documentation+under+heading+%22load_torrent_parsed%28%29+load_torrent_file%28%29+load_torrent_buffer%28%29%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="load-torrent-parsed-load-torrent-file-load-torrent-buffer">
<h1>load_torrent_parsed() load_torrent_file() load_torrent_buffer()</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/load_torrent.hpp">libtorrent/load_torrent.hpp</a>&quot;</p>
<pre class="literal-block">
add_torrent_params <strong>load_torrent_buffer</strong> (
   span&lt;char const&gt; buffer);
add_torrent_params <strong>load_torrent_buffer</strong> (
   span&lt;char const&gt; buffer, load_torrent_limits const&amp; cfg);
add_torrent_params <strong>load_torrent_file</strong> (
   std::string const&amp; filename, load_torrent_limits const&amp; cfg);
add_torrent_params <strong>load_torrent_parsed</strong> (
   bdecode_node const&amp; torrent_file, load_torrent_limits const&amp; cfg);
add_torrent_params <strong>load_torrent_file</strong> (
   std::string const&amp; filename);
add_torrent_params <strong>load_torrent_parsed</strong> (
   bdecode_node const&amp; torrent_file);
</pre>
<p>These functions load the content of a .torrent file into an
<a class="reference external" href="reference-Add_Torrent.html#add_torrent_params">add_torrent_params</a> object.
The immutable part of a torrent file (the info-dictionary) is stored in
the <tt class="docutils literal">ti</tt> field in the <a class="reference external" href="reference-Add_Torrent.html#add_torrent_params">add_torrent_params</a> object (as a <a class="reference external" href="reference-Torrent_Info.html#torrent_info">torrent_info</a>
object).
The returned object is suitable to be:</p>
<blockquote>
<ul class="simple">
<li>added to a <a class="reference external" href="reference-Session.html#session">session</a> via <a class="reference external" href="reference-Session.html#add_torrent()">add_torrent()</a> or <a class="reference external" href="reference-Session.html#async_add_torrent()">async_add_torrent()</a></li>
<li>saved as a .torrent_file via <a class="reference external" href="reference-Resume_Data.html#write_torrent_file()">write_torrent_file()</a></li>
<li>turned into a magnet link via <a class="reference external" href="reference-Core.html#make_magnet_uri()">make_magnet_uri()</a></li>
</ul>
</blockquote>
<a name="torrent_peer_equal()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_peer_equal%28%29&labels=documentation&body=Documentation+under+heading+%22torrent_peer_equal%28%29%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="torrent-peer-equal">
<h1>torrent_peer_equal()</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/torrent_peer.hpp">libtorrent/torrent_peer.hpp</a>&quot;</p>
<pre class="literal-block">
inline bool <strong>torrent_peer_equal</strong> (torrent_peer const* lhs, torrent_peer const* rhs);
</pre>
<a name="make_magnet_uri()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:make_magnet_uri%28%29&labels=documentation&body=Documentation+under+heading+%22make_magnet_uri%28%29%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="make-magnet-uri">
<h1>make_magnet_uri()</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/magnet_uri.hpp">libtorrent/magnet_uri.hpp</a>&quot;</p>
<pre class="literal-block">
std::string <strong>make_magnet_uri</strong> (add_torrent_params const&amp; atp);
std::string <strong>make_magnet_uri</strong> (torrent_handle const&amp; handle);
std::string <strong>make_magnet_uri</strong> (torrent_info const&amp; info);
</pre>
<p>Generates a magnet URI from the specified torrent.</p>
<p>Several fields from the <a class="reference external" href="reference-Add_Torrent.html#add_torrent_params">add_torrent_params</a> objects are recorded in the
magnet link. In order to not include them, they have to be cleared before
calling <a class="reference external" href="reference-Core.html#make_magnet_uri()">make_magnet_uri()</a>. These fields are used:</p>
<blockquote>
<tt class="docutils literal">ti</tt>, <tt class="docutils literal">info_hashes</tt>, <tt class="docutils literal">url_seeds</tt>, <tt class="docutils literal">dht_nodes</tt>,
<tt class="docutils literal">file_priorities</tt>, <tt class="docutils literal">trackers</tt>, <tt class="docutils literal">name</tt>, <tt class="docutils literal">peers</tt>.</blockquote>
<p>Depending on what the use case for the resulting magnet link is, clearing
<tt class="docutils literal">peers</tt> and <tt class="docutils literal">dht_nodes</tt> is probably a good idea if the <a class="reference external" href="reference-Add_Torrent.html#add_torrent_params">add_torrent_params</a>
came from a running torrent. Those lists may be long and be ephemeral.</p>
<p>If none of the <tt class="docutils literal">info_hashes</tt> or <tt class="docutils literal">ti</tt> fields are set, there is not
info-hash available, and a magnet link cannot be created. In this case
<a class="reference external" href="reference-Core.html#make_magnet_uri()">make_magnet_uri()</a> returns an empty string.</p>
<p>The recommended way to generate a magnet link from a <a class="reference external" href="reference-Torrent_Handle.html#torrent_handle">torrent_handle</a> is to
call <a class="reference external" href="reference-Torrent_Handle.html#save_resume_data()">save_resume_data()</a>, which will post a <a class="reference external" href="reference-Alerts.html#save_resume_data_alert">save_resume_data_alert</a>
containing an <a class="reference external" href="reference-Add_Torrent.html#add_torrent_params">add_torrent_params</a> object. This can then be passed to
<a class="reference external" href="reference-Core.html#make_magnet_uri()">make_magnet_uri()</a>.</p>
<p>The overload that takes a <a class="reference external" href="reference-Torrent_Handle.html#torrent_handle">torrent_handle</a> will make blocking calls to
query information about the torrent. If the torrent handle is invalid,
an empty string is returned.</p>
<p>For more information about magnet links, see <a class="reference external" href="manual-ref.html#magnet-links">magnet links</a>.</p>
<a name="parse_magnet_uri()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:parse_magnet_uri%28%29&labels=documentation&body=Documentation+under+heading+%22parse_magnet_uri%28%29%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="parse-magnet-uri">
<h1>parse_magnet_uri()</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/magnet_uri.hpp">libtorrent/magnet_uri.hpp</a>&quot;</p>
<pre class="literal-block">
void <strong>parse_magnet_uri</strong> (string_view uri, add_torrent_params&amp; p, error_code&amp; ec);
add_torrent_params <strong>parse_magnet_uri</strong> (string_view uri);
add_torrent_params <strong>parse_magnet_uri</strong> (string_view uri, error_code&amp; ec);
</pre>
<p>This function parses out information from the magnet link and populates the
<a class="reference external" href="reference-Add_Torrent.html#add_torrent_params">add_torrent_params</a> object. The overload that does not take an
<tt class="docutils literal">error_code</tt> reference will throw a system_error on error
The overload taking an <tt class="docutils literal">add_torrent_params</tt> reference will fill in the
fields specified in the magnet URI.</p>
<a name="version()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:version%28%29&labels=documentation&body=Documentation+under+heading+%22version%28%29%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="version">
<h1>version()</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/version.hpp">libtorrent/version.hpp</a>&quot;</p>
<pre class="literal-block">
char const* <strong>version</strong> ();
</pre>
<p>returns the libtorrent version as string form in this format:
&quot;&lt;major&gt;.&lt;minor&gt;.&lt;tiny&gt;.&lt;tag&gt;&quot;</p>
<a name="truncate_files()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:truncate_files%28%29&labels=documentation&body=Documentation+under+heading+%22truncate_files%28%29%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="truncate-files">
<h1>truncate_files()</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/truncate.hpp">libtorrent/truncate.hpp</a>&quot;</p>
<pre class="literal-block">
void <strong>truncate_files</strong> (file_storage const&amp; fs, std::string const&amp; save_path, storage_error&amp; ec);
</pre>
<p>Truncates files larger than specified in the <a class="reference external" href="reference-Storage.html#file_storage">file_storage</a>, saved under
the specified save_path.</p>
<a name="event_t"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+event_t&labels=documentation&body=Documentation+under+heading+%22enum+event_t%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-event-t">
<h1>enum event_t</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/tracker_manager.hpp">libtorrent/tracker_manager.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="35%" />
<col width="23%" />
<col width="42%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>none</td>
<td>0</td>
<td>&nbsp;</td>
</tr>
<tr><td>completed</td>
<td>1</td>
<td>&nbsp;</td>
</tr>
<tr><td>started</td>
<td>2</td>
<td>&nbsp;</td>
</tr>
<tr><td>stopped</td>
<td>3</td>
<td>&nbsp;</td>
</tr>
<tr><td>paused</td>
<td>4</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<a name="socket_type_t"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+socket_type_t&labels=documentation&body=Documentation+under+heading+%22enum+socket_type_t%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-socket-type-t">
<h1>enum socket_type_t</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/socket_type.hpp">libtorrent/socket_type.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="38%" />
<col width="22%" />
<col width="41%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>tcp</td>
<td>0</td>
<td>&nbsp;</td>
</tr>
<tr><td>socks5</td>
<td>1</td>
<td>&nbsp;</td>
</tr>
<tr><td>http</td>
<td>2</td>
<td>&nbsp;</td>
</tr>
<tr><td>utp</td>
<td>3</td>
<td>&nbsp;</td>
</tr>
<tr><td>i2p</td>
<td>4</td>
<td>&nbsp;</td>
</tr>
<tr><td>tcp_ssl</td>
<td>5</td>
<td>&nbsp;</td>
</tr>
<tr><td>socks5_ssl</td>
<td>6</td>
<td>&nbsp;</td>
</tr>
<tr><td>http_ssl</td>
<td>7</td>
<td>&nbsp;</td>
</tr>
<tr><td>utp_ssl</td>
<td>8</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<a name="connection_type"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+connection_type&labels=documentation&body=Documentation+under+heading+%22enum+connection_type%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-connection-type">
<h1>enum connection_type</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/peer_connection.hpp">libtorrent/peer_connection.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="38%" />
<col width="22%" />
<col width="41%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>bittorrent</td>
<td>0</td>
<td>&nbsp;</td>
</tr>
<tr><td>url_seed</td>
<td>1</td>
<td>&nbsp;</td>
</tr>
<tr><td>http_seed</td>
<td>2</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<a name="portmap_transport"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+portmap_transport&labels=documentation&body=Documentation+under+heading+%22enum+portmap_transport%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-portmap-transport">
<h1>enum portmap_transport</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/portmap.hpp">libtorrent/portmap.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="18%" />
<col width="16%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>natpmp</td>
<td>0</td>
<td>natpmp can be NAT-PMP or PCP</td>
</tr>
<tr><td>upnp</td>
<td>1</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<a name="portmap_protocol"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+portmap_protocol&labels=documentation&body=Documentation+under+heading+%22enum+portmap_protocol%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-portmap-protocol">
<h1>enum portmap_protocol</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/portmap.hpp">libtorrent/portmap.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="27%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>none</td>
<td>0</td>
<td>&nbsp;</td>
</tr>
<tr><td>tcp</td>
<td>1</td>
<td>&nbsp;</td>
</tr>
<tr><td>udp</td>
<td>2</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<a name="protocol_version"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+protocol_version&labels=documentation&body=Documentation+under+heading+%22enum+protocol_version%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-protocol-version">
<h1>enum protocol_version</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/info_hash.hpp">libtorrent/info_hash.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="8%" />
<col width="10%" />
<col width="82%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>V1</td>
<td>0</td>
<td>The original BitTorrent version, using SHA-1 hashes</td>
</tr>
<tr><td>V2</td>
<td>1</td>
<td>Version 2 of the BitTorrent protocol, using SHA-256 hashes</td>
</tr>
<tr><td>NUM</td>
<td>2</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<a name="int"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:int&labels=documentation&body=Documentation+under+heading+%22int%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="int-1">
<h1>int</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/version.hpp">libtorrent/version.hpp</a>&quot;</p>
<a name="int::version_major"></a><dl class="docutils">
<dt>version_major</dt>
<dd>the major, minor and tiny versions of libtorrent</dd>
</dl>
<a name="int::version_minor"></a><dl class="docutils">
<dt>version_minor</dt>
<dd>the major, minor and tiny versions of libtorrent</dd>
</dl>
<a name="int::version_tiny"></a><dl class="docutils">
<dt>version_tiny</dt>
<dd>the major, minor and tiny versions of libtorrent</dd>
</dl>
<a name="download_priority_t"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:download_priority_t&labels=documentation&body=Documentation+under+heading+%22download_priority_t%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="download-priority-t">
<h1>download_priority_t</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/download_priority.hpp">libtorrent/download_priority.hpp</a>&quot;</p>
<a name="download_priority_t::dont_download"></a><dl class="docutils">
<dt>dont_download</dt>
<dd>Don't download the file or piece. Partial pieces may still be downloaded when
setting file priorities.</dd>
</dl>
<a name="download_priority_t::default_priority"></a><dl class="docutils">
<dt>default_priority</dt>
<dd>The default priority for files and pieces.</dd>
</dl>
<a name="download_priority_t::low_priority"></a><dl class="docutils">
<dt>low_priority</dt>
<dd>The lowest priority for files and pieces.</dd>
</dl>
<a name="download_priority_t::top_priority"></a><dl class="docutils">
<dt>top_priority</dt>
<dd>The highest priority for files and pieces.</dd>
</dl>
<a name="char const*"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:char+const%2A&labels=documentation&body=Documentation+under+heading+%22char+const%2A%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="char-const">
<h1>char const*</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/version.hpp">libtorrent/version.hpp</a>&quot;</p>
<a name="char const*::version_str"></a><dl class="docutils">
<dt>version_str</dt>
<dd>the libtorrent version in string form</dd>
</dl>
<a name="std::uint64_t"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:std%3A%3Auint64_t&labels=documentation&body=Documentation+under+heading+%22std%3A%3Auint64_t%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="std-uint64-t">
<h1>std::uint64_t</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/version.hpp">libtorrent/version.hpp</a>&quot;</p>
<a name="std::uint64_t::version_revision"></a><dl class="docutils">
<dt>version_revision</dt>
<dd>the git commit of this libtorrent version</dd>
</dl>
<a name="pex_flags_t"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:pex_flags_t&labels=documentation&body=Documentation+under+heading+%22pex_flags_t%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="pex-flags-t">
<h1>pex_flags_t</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/pex_flags.hpp">libtorrent/pex_flags.hpp</a>&quot;</p>
<a name="pex_flags_t::pex_encryption"></a><dl class="docutils">
<dt>pex_encryption</dt>
<dd>the peer supports protocol encryption</dd>
</dl>
<a name="pex_flags_t::pex_seed"></a><dl class="docutils">
<dt>pex_seed</dt>
<dd>the peer is a seed</dd>
</dl>
<a name="pex_flags_t::pex_utp"></a><dl class="docutils">
<dt>pex_utp</dt>
<dd>the peer supports the uTP, transport protocol over UDP.</dd>
</dl>
<a name="pex_flags_t::pex_holepunch"></a><dl class="docutils">
<dt>pex_holepunch</dt>
<dd>the peer supports the holepunch extension If this flag is received from a
peer, it can be used as a rendezvous point in case direct connections to
the peer fail</dd>
</dl>
<a name="pex_flags_t::pex_lt_v2"></a><dl class="docutils">
<dt>pex_lt_v2</dt>
<dd>protocol v2
this is not a standard flag, it is only used internally</dd>
</dl>
<a name="torrent_flags_t"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_flags_t&labels=documentation&body=Documentation+under+heading+%22torrent_flags_t%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="torrent-flags-t">
<h1>torrent_flags_t</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/torrent_flags.hpp">libtorrent/torrent_flags.hpp</a>&quot;</p>
<a name="torrent_flags_t::seed_mode"></a><dl class="docutils">
<dt>seed_mode</dt>
<dd><p class="first">If <tt class="docutils literal">seed_mode</tt> is set, libtorrent will assume that all files
are present for this torrent and that they all match the hashes in
the torrent file. Each time a peer requests to download a block,
the piece is verified against the hash, unless it has been verified
already. If a hash fails, the torrent will automatically leave the
seed mode and recheck all the files. The use case for this mode is
if a torrent is created and seeded, or if the user already know
that the files are complete, this is a way to avoid the initial
file checks, and significantly reduce the startup time.</p>
<p>Setting <tt class="docutils literal">seed_mode</tt> on a torrent without metadata (a
.torrent file) is a no-op and will be ignored.</p>
<p class="last">It is not possible to <em>set</em> the <tt class="docutils literal">seed_mode</tt> flag on a torrent after it has
been added to a <a class="reference external" href="reference-Session.html#session">session</a>. It is possible to <em>clear</em> it though.</p>
</dd>
</dl>
<a name="torrent_flags_t::upload_mode"></a><dl class="docutils">
<dt>upload_mode</dt>
<dd><p class="first">If <tt class="docutils literal">upload_mode</tt> is set, the torrent will be initialized in
upload-mode, which means it will not make any piece requests. This
state is typically entered on disk I/O errors, and if the torrent
is also auto managed, it will be taken out of this state
periodically (see <tt class="docutils literal"><span class="pre">settings_pack::optimistic_disk_retry</span></tt>).</p>
<p>This mode can be used to avoid race conditions when
adjusting priorities of pieces before allowing the torrent to start
downloading.</p>
<p class="last">If the torrent is auto-managed (<tt class="docutils literal">auto_managed</tt>), the torrent
will eventually be taken out of upload-mode, regardless of how it
got there. If it's important to manually control when the torrent
leaves upload mode, don't make it auto managed.</p>
</dd>
</dl>
<a name="torrent_flags_t::share_mode"></a><dl class="docutils">
<dt>share_mode</dt>
<dd><p class="first">determines if the torrent should be added in <em>share mode</em> or not.
Share mode indicates that we are not interested in downloading the
torrent, but merely want to improve our share ratio (i.e. increase
it). A torrent started in share mode will do its best to never
download more than it uploads to the swarm. If the swarm does not
have enough demand for upload capacity, the torrent will not
download anything. This mode is intended to be safe to add any
number of torrents to, without manual screening, without the risk
of downloading more than is uploaded.</p>
<p>A torrent in share mode sets the priority to all pieces to 0,
except for the pieces that are downloaded, when pieces are decided
to be downloaded. This affects the progress bar, which might be set
to &quot;100% finished&quot; most of the time. Do not change file or piece
priorities for torrents in share mode, it will make it not work.</p>
<p class="last">The share mode has one setting, the share ratio target, see
<tt class="docutils literal"><span class="pre">settings_pack::share_mode_target</span></tt> for more info.</p>
</dd>
</dl>
<a name="torrent_flags_t::apply_ip_filter"></a><dl class="docutils">
<dt>apply_ip_filter</dt>
<dd>determines if the IP filter should apply to this torrent or not. By
default all torrents are subject to filtering by the IP filter
(i.e. this flag is set by default). This is useful if certain
torrents needs to be exempt for some reason, being an auto-update
torrent for instance.</dd>
</dl>
<a name="torrent_flags_t::paused"></a><dl class="docutils">
<dt>paused</dt>
<dd>specifies whether or not the torrent is paused. i.e. it won't connect to the tracker or any of the peers
until it's resumed. Note that a paused torrent that also has the
auto_managed flag set can be started at any time by libtorrent's queuing
logic. See <a class="reference external" href="manual-ref.html#queuing">queuing</a>.</dd>
</dl>
<a name="torrent_flags_t::auto_managed"></a><dl class="docutils">
<dt>auto_managed</dt>
<dd><p class="first">If the torrent is auto-managed (<tt class="docutils literal">auto_managed</tt>), the torrent
may be resumed at any point, regardless of how it paused. If it's
important to manually control when the torrent is paused and
resumed, don't make it auto managed.</p>
<p class="last">If <tt class="docutils literal">auto_managed</tt> is set, the torrent will be queued,
started and seeded automatically by libtorrent. When this is set,
the torrent should also be started as paused. The default queue
order is the order the torrents were added. They are all downloaded
in that order. For more details, see <a class="reference external" href="manual-ref.html#queuing">queuing</a>.</p>
</dd>
</dl>
<a name="torrent_flags_t::duplicate_is_error"></a><dl class="docutils">
<dt>duplicate_is_error</dt>
<dd>used in <a class="reference external" href="reference-Add_Torrent.html#add_torrent_params">add_torrent_params</a> to indicate that it's an error to attempt
to add a torrent that's already in the <a class="reference external" href="reference-Session.html#session">session</a>. If it's not considered an
error, a handle to the existing torrent is returned.
This flag is not saved by <a class="reference external" href="reference-Resume_Data.html#write_resume_data()">write_resume_data()</a>, since it is only meant for
adding torrents.</dd>
</dl>
<a name="torrent_flags_t::update_subscribe"></a><dl class="docutils">
<dt>update_subscribe</dt>
<dd>on by default and means that this torrent will be part of state
updates when calling <a class="reference external" href="reference-Session.html#post_torrent_updates()">post_torrent_updates()</a>.
This flag is not saved by <a class="reference external" href="reference-Resume_Data.html#write_resume_data()">write_resume_data()</a>.</dd>
</dl>
<a name="torrent_flags_t::super_seeding"></a><dl class="docutils">
<dt>super_seeding</dt>
<dd>sets the torrent into super seeding/initial seeding mode. If the torrent
is not a seed, this flag has no effect.</dd>
</dl>
<a name="torrent_flags_t::sequential_download"></a><dl class="docutils">
<dt>sequential_download</dt>
<dd>sets the sequential download state for the torrent. In this mode the
piece picker will pick pieces with low index numbers before pieces with
high indices. The actual pieces that are picked depend on other factors
still, such as which pieces a peer has and whether it is in parole mode
or &quot;prefer whole pieces&quot;-mode. Sequential mode is not ideal for streaming
media. For that, see <a class="reference external" href="reference-Torrent_Handle.html#set_piece_deadline()">set_piece_deadline()</a> instead.</dd>
</dl>
<a name="torrent_flags_t::stop_when_ready"></a><dl class="docutils">
<dt>stop_when_ready</dt>
<dd><p class="first">When this flag is set, the torrent will <em>force stop</em> whenever it
transitions from a non-data-transferring state into a data-transferring
state (referred to as being ready to download or seed). This is useful
for torrents that should not start downloading or seeding yet, but want
to be made ready to do so. A torrent may need to have its files checked
for instance, so it needs to be started and possibly queued for checking
(auto-managed and started) but as soon as it's done, it should be
stopped.</p>
<p><em>Force stopped</em> means auto-managed is set to false and it's paused. As
if the auto_manages flag is cleared and the paused flag is set on the torrent.</p>
<p>Note that the torrent may transition into a downloading state while
setting this flag, and since the logic is edge triggered you may
miss the edge. To avoid this race, if the torrent already is in a
downloading state when this call is made, it will trigger the
stop-when-ready immediately.</p>
<p>When the stop-when-ready logic fires, the flag is cleared. Any
subsequent transitions between downloading and non-downloading states
will not be affected, until this flag is set again.</p>
<p>The behavior is more robust when setting this flag as part of adding
the torrent. See <a class="reference external" href="reference-Add_Torrent.html#add_torrent_params">add_torrent_params</a>.</p>
<p>The stop-when-ready flag fixes the inherent race condition of waiting
for the <a class="reference external" href="reference-Alerts.html#state_changed_alert">state_changed_alert</a> and then call <a class="reference external" href="reference-Session.html#pause()">pause()</a>. The download/seeding
will most likely start in between posting the <a class="reference external" href="reference-Alerts.html#alert">alert</a> and receiving the
call to pause.</p>
<p class="last">A downloading state is one where peers are being connected. Which means
just downloading the metadata via the <tt class="docutils literal">ut_metadata</tt> extension counts
as a downloading state. In order to stop a torrent once the metadata
has been downloaded, instead set all file priorities to dont_download</p>
</dd>
</dl>
<a name="torrent_flags_t::override_trackers"></a><dl class="docutils">
<dt>override_trackers</dt>
<dd>when this flag is set, the tracker list in the <a class="reference external" href="reference-Add_Torrent.html#add_torrent_params">add_torrent_params</a>
object override any trackers from the torrent file. If the flag is
not set, the trackers from the <a class="reference external" href="reference-Add_Torrent.html#add_torrent_params">add_torrent_params</a> object will be
added to the list of trackers used by the torrent.
This flag is set by <a class="reference external" href="reference-Resume_Data.html#read_resume_data()">read_resume_data()</a> if there are trackers present in
the resume data file. This effectively makes the trackers saved in the
resume data take precedence over the original trackers. This includes if
there's an empty list of trackers, to support the case where they were
explicitly removed in the previous <a class="reference external" href="reference-Session.html#session">session</a>.
This flag is not saved by <a class="reference external" href="reference-Resume_Data.html#write_resume_data()">write_resume_data()</a></dd>
</dl>
<a name="torrent_flags_t::override_web_seeds"></a><dl class="docutils">
<dt>override_web_seeds</dt>
<dd>If this flag is set, the web seeds from the <a class="reference external" href="reference-Add_Torrent.html#add_torrent_params">add_torrent_params</a>
object will override any web seeds in the torrent file. If it's not
set, web seeds in the <a class="reference external" href="reference-Add_Torrent.html#add_torrent_params">add_torrent_params</a> object will be added to the
list of web seeds used by the torrent.
This flag is set by <a class="reference external" href="reference-Resume_Data.html#read_resume_data()">read_resume_data()</a> if there are web seeds present in
the resume data file. This effectively makes the web seeds saved in the
resume data take precedence over the original ones. This includes if
there's an empty list of web seeds, to support the case where they were
explicitly removed in the previous <a class="reference external" href="reference-Session.html#session">session</a>.
This flag is not saved by <a class="reference external" href="reference-Resume_Data.html#write_resume_data()">write_resume_data()</a></dd>
</dl>
<a name="torrent_flags_t::need_save_resume"></a><dl class="docutils">
<dt>need_save_resume</dt>
<dd><p class="first">if this flag is set (which it is by default) the torrent will be
considered needing to save its resume data immediately, in the
category if_metadata_changed. See resume_data_flags_t and
<a class="reference external" href="reference-Torrent_Handle.html#save_resume_data()">save_resume_data()</a> for details.</p>
<p class="last">This flag is cleared by a successful call to <a class="reference external" href="reference-Torrent_Handle.html#save_resume_data()">save_resume_data()</a>
This flag is not saved by <a class="reference external" href="reference-Resume_Data.html#write_resume_data()">write_resume_data()</a>, since it represents an
ephemeral state of a running torrent.</p>
</dd>
</dl>
<a name="torrent_flags_t::disable_dht"></a><dl class="docutils">
<dt>disable_dht</dt>
<dd>set this flag to disable DHT for this torrent. This lets you have the DHT
enabled for the whole client, and still have specific torrents not
participating in it. i.e. not announcing to the DHT nor picking up peers
from it.</dd>
</dl>
<a name="torrent_flags_t::disable_lsd"></a><dl class="docutils">
<dt>disable_lsd</dt>
<dd>set this flag to disable local service discovery for this torrent.</dd>
</dl>
<a name="torrent_flags_t::disable_pex"></a><dl class="docutils">
<dt>disable_pex</dt>
<dd>set this flag to disable peer exchange for this torrent.</dd>
</dl>
<a name="torrent_flags_t::no_verify_files"></a><dl class="docutils">
<dt>no_verify_files</dt>
<dd>if this flag is set, the resume data will be assumed to be correct
without validating it against any files on disk. This may be used when
restoring a <a class="reference external" href="reference-Session.html#session">session</a> by loading resume data from disk. It will save time
and also delay any hard disk errors until files are actually needed. If
the resume data cannot be trusted, or if a torrent is added for the first
time to some save path that may already have some of the files, this flag
should not be set.</dd>
</dl>
<a name="torrent_flags_t::default_dont_download"></a><dl class="docutils">
<dt>default_dont_download</dt>
<dd>default all file priorities to dont_download. This is useful for adding
magnet links where the number of files is unknown, but the
file_priorities is still set for some files. Any file not covered by
the file_priorities list will be set to normal download priority,
unless this flag is set, in which case they will be set to 0
(dont_download).</dd>
</dl>
<a name="torrent_flags_t::i2p_torrent"></a><dl class="docutils">
<dt>i2p_torrent</dt>
<dd>this flag makes the torrent be considered an &quot;i2p torrent&quot; for purposes
of the allow_i2p_mixed setting. When mixing regular peers and i2p peers
is disabled, i2p torrents won't add normal peers to its peer list.
Note that non i2p torrents may still allow i2p peers (on the off-chance
that a tracker return them and the <a class="reference external" href="reference-Session.html#session">session</a> is configured with a SAM
connection).
This flag is set automatically when adding a torrent that has at least
one tracker whose hostname ends with .i2p.
It's also set by <a class="reference external" href="reference-Core.html#parse_magnet_uri()">parse_magnet_uri()</a> if the tracker list contains such
URL.</dd>
</dl>
<a name="torrent_flags_t::all"></a><dl class="docutils">
<dt>all</dt>
<dd>all torrent flags combined. Can conveniently be used when creating masks
for flags</dd>
</dl>
<p>Bencoding is a common representation in bittorrent used for dictionary,
list, <a class="reference external" href="reference-Core.html#int">int</a> and string hierarchies. It's used to encode .torrent files and
some messages in the network protocol. libtorrent also uses it to store
settings, resume data and other <a class="reference external" href="reference-Session.html#session">session</a> state.</p>
<p>Strings in bencoded structures do not necessarily represent text.
Strings are raw byte buffers of a certain length. If a string is meant to be
interpreted as text, it is required to be UTF-8 encoded. See <a class="reference external" href="https://www.bittorrent.org/beps/bep_0003.html">BEP 3</a>.</p>
<p>The function for decoding bencoded data <a class="reference external" href="reference-Bdecoding.html#bdecode()">bdecode()</a>, returning a <a class="reference external" href="reference-Bdecoding.html#bdecode_node">bdecode_node</a>.
This function builds a tree that points back into the original buffer. The
returned <a class="reference external" href="reference-Bdecoding.html#bdecode_node">bdecode_node</a> will not be valid once the buffer it was parsed out of
is discarded.</p>
<p>It's possible to construct an <a class="reference external" href="reference-Bencoding.html#entry">entry</a> from a <a class="reference external" href="reference-Bdecoding.html#bdecode_node">bdecode_node</a>, if a structure needs
to be altered and re-encoded.</p>
<a name="entry"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+entry&labels=documentation&body=Documentation+under+heading+%22class+entry%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="entry">
<h1>entry</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/entry.hpp">libtorrent/entry.hpp</a>&quot;</p>
<p>The <tt class="docutils literal">entry</tt> class represents one node in a bencoded hierarchy. It works as a
variant type, it can be either a list, a dictionary (<tt class="docutils literal"><span class="pre">std::map</span></tt>), an integer
or a string.</p>
<pre class="literal-block">
class entry
{
   data_type <strong>type</strong> () const;
   <strong>entry</strong> (integer_type);
   <strong>entry</strong> (dictionary_type);
   <strong>entry</strong> (list_type);
   <strong>entry</strong> (preformatted_type);
   <strong>entry</strong> (span&lt;char const&gt;);
   <strong>entry</strong> (U v);
   <strong>entry</strong> (data_type t);
   <strong>entry</strong> (bdecode_node const&amp; n);
   entry&amp; <strong>operator=</strong> (entry const&amp;) &amp;;
   entry&amp; <strong>operator=</strong> (span&lt;char const&gt;) &amp;;
   entry&amp; <strong>operator=</strong> (integer_type) &amp;;
   entry&amp; <strong>operator=</strong> (bdecode_node const&amp;) &amp;;
   entry&amp; <strong>operator=</strong> (dictionary_type) &amp;;
   entry&amp; <strong>operator=</strong> (list_type) &amp;;
   entry&amp; <strong>operator=</strong> (entry&amp;&amp;) &amp; noexcept;
   entry&amp; <strong>operator=</strong> (preformatted_type) &amp;;
   entry&amp; <strong>operator=</strong> (U v) &amp;;
   integer_type&amp; <strong>integer</strong> ();
   dictionary_type&amp; <strong>dict</strong> ();
   preformatted_type const&amp; <strong>preformatted</strong> () const;
   dictionary_type const&amp; <strong>dict</strong> () const;
   string_type&amp; <strong>string</strong> ();
   preformatted_type&amp; <strong>preformatted</strong> ();
   list_type&amp; <strong>list</strong> ();
   integer_type const&amp; <strong>integer</strong> () const;
   list_type const&amp; <strong>list</strong> () const;
   string_type const&amp; <strong>string</strong> () const;
   void <strong>swap</strong> (entry&amp; e);
   entry const&amp; <strong>operator[]</strong> (string_view key) const;
   entry&amp; <strong>operator[]</strong> (string_view key);
   entry* <strong>find_key</strong> (string_view key);
   entry const* <strong>find_key</strong> (string_view key) const;
   std::string <strong>to_string</strong> (bool single_line = false) const;

   enum data_type
   {
      int_t,
      string_t,
      list_t,
      dictionary_t,
      undefined_t,
      preformatted_t,
   };
};
</pre>
<a name="type()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:entry%3A%3A%5Btype%28%29%5D&labels=documentation&body=Documentation+under+heading+%22entry%3A%3A%5Btype%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="type-2">
<h2>type()</h2>
<pre class="literal-block">
data_type <strong>type</strong> () const;
</pre>
<p>returns the concrete type of the <a class="reference external" href="reference-Bencoding.html#entry">entry</a></p>
<a name="entry()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:entry%3A%3A%5Bentry%28%29%5D&labels=documentation&body=Documentation+under+heading+%22entry%3A%3A%5Bentry%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="entry-1">
<h2>entry()</h2>
<pre class="literal-block">
<strong>entry</strong> (integer_type);
<strong>entry</strong> (dictionary_type);
<strong>entry</strong> (list_type);
<strong>entry</strong> (preformatted_type);
<strong>entry</strong> (span&lt;char const&gt;);
</pre>
<p>constructors directly from a specific type.
The content of the argument is copied into the
newly constructed <a class="reference external" href="reference-Bencoding.html#entry">entry</a></p>
<a name="entry()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:entry%3A%3A%5Bentry%28%29%5D&labels=documentation&body=Documentation+under+heading+%22entry%3A%3A%5Bentry%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="entry-2">
<h2>entry()</h2>
<pre class="literal-block">
<strong>entry</strong> (data_type t);
</pre>
<p>construct an empty <a class="reference external" href="reference-Bencoding.html#entry">entry</a> of the specified type.
see <a class="reference external" href="reference-Bencoding.html#data_type">data_type</a> enum.</p>
<a name="entry()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:entry%3A%3A%5Bentry%28%29%5D&labels=documentation&body=Documentation+under+heading+%22entry%3A%3A%5Bentry%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="entry-3">
<h2>entry()</h2>
<pre class="literal-block">
<strong>entry</strong> (bdecode_node const&amp; n);
</pre>
<p>construct from <a class="reference external" href="reference-Bdecoding.html#bdecode_node">bdecode_node</a> parsed form (see <a class="reference external" href="reference-Bdecoding.html#bdecode()">bdecode()</a>)</p>
<a name="operator=()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:entry%3A%3A%5Boperator%3D%28%29%5D&labels=documentation&body=Documentation+under+heading+%22entry%3A%3A%5Boperator%3D%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="operator-1">
<h2>operator=()</h2>
<pre class="literal-block">
entry&amp; <strong>operator=</strong> (entry const&amp;) &amp;;
entry&amp; <strong>operator=</strong> (span&lt;char const&gt;) &amp;;
entry&amp; <strong>operator=</strong> (integer_type) &amp;;
entry&amp; <strong>operator=</strong> (bdecode_node const&amp;) &amp;;
entry&amp; <strong>operator=</strong> (dictionary_type) &amp;;
entry&amp; <strong>operator=</strong> (list_type) &amp;;
entry&amp; <strong>operator=</strong> (entry&amp;&amp;) &amp; noexcept;
entry&amp; <strong>operator=</strong> (preformatted_type) &amp;;
</pre>
<p>copies the structure of the right hand side into this
<a class="reference external" href="reference-Bencoding.html#entry">entry</a>.</p>
<a name="dict()"></a>
<a name="string()"></a>
<a name="integer()"></a>
<a name="list()"></a>
<a name="preformatted()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:entry%3A%3A%5Bdict%28%29+string%28%29+integer%28%29+list%28%29+preformatted%28%29%5D&labels=documentation&body=Documentation+under+heading+%22entry%3A%3A%5Bdict%28%29+string%28%29+integer%28%29+list%28%29+preformatted%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="dict-string-integer-list-preformatted">
<h2>dict() string() integer() list() preformatted()</h2>
<pre class="literal-block">
integer_type&amp; <strong>integer</strong> ();
dictionary_type&amp; <strong>dict</strong> ();
preformatted_type const&amp; <strong>preformatted</strong> () const;
dictionary_type const&amp; <strong>dict</strong> () const;
string_type&amp; <strong>string</strong> ();
preformatted_type&amp; <strong>preformatted</strong> ();
list_type&amp; <strong>list</strong> ();
integer_type const&amp; <strong>integer</strong> () const;
list_type const&amp; <strong>list</strong> () const;
string_type const&amp; <strong>string</strong> () const;
</pre>
<p>The <tt class="docutils literal">integer()</tt>, <tt class="docutils literal">string()</tt>, <tt class="docutils literal">list()</tt> and <tt class="docutils literal">dict()</tt> functions
are accessors that return the respective type. If the <tt class="docutils literal">entry</tt> object
isn't of the type you request, the accessor will throw
system_error. You can ask an <tt class="docutils literal">entry</tt> for its type through the
<tt class="docutils literal">type()</tt> function.</p>
<p>If you want to create an <tt class="docutils literal">entry</tt> you give it the type you want it to
have in its constructor, and then use one of the non-const accessors
to get a reference which you then can assign the value you want it to
have.</p>
<p>The typical code to get info from a torrent file will then look like
this:</p>
<pre class="code c++ literal-block">
<span class="name">entry</span><span class="whitespace"> </span><span class="name">torrent_file</span><span class="punctuation">;</span><span class="whitespace">
</span><span class="comment single">// ...
</span><span class="whitespace">
</span><span class="comment single">// throws if this is not a dictionary
</span><span class="name">entry</span><span class="operator">::</span><span class="name">dictionary_type</span><span class="whitespace"> </span><span class="keyword">const</span><span class="operator">&amp;</span><span class="whitespace"> </span><span class="name">dict</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">torrent_file</span><span class="punctuation">.</span><span class="name">dict</span><span class="punctuation">();</span><span class="whitespace">
</span><span class="name">entry</span><span class="operator">::</span><span class="name">dictionary_type</span><span class="operator">::</span><span class="name">const_iterator</span><span class="whitespace"> </span><span class="name">i</span><span class="punctuation">;</span><span class="whitespace">
</span><span class="name">i</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">dict</span><span class="punctuation">.</span><span class="name">find</span><span class="punctuation">(</span><span class="literal string">&quot;announce&quot;</span><span class="punctuation">);</span><span class="whitespace">
</span><span class="keyword">if</span><span class="whitespace"> </span><span class="punctuation">(</span><span class="name">i</span><span class="whitespace"> </span><span class="operator">!=</span><span class="whitespace"> </span><span class="name">dict</span><span class="punctuation">.</span><span class="name">end</span><span class="punctuation">())</span><span class="whitespace">
</span><span class="punctuation">{</span><span class="whitespace">
        </span><span class="name">std</span><span class="operator">::</span><span class="name">string</span><span class="whitespace"> </span><span class="name">tracker_url</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">i</span><span class="operator">-&gt;</span><span class="name">second</span><span class="punctuation">.</span><span class="name">string</span><span class="punctuation">();</span><span class="whitespace">
        </span><span class="name">std</span><span class="operator">::</span><span class="name">cout</span><span class="whitespace"> </span><span class="operator">&lt;&lt;</span><span class="whitespace"> </span><span class="name">tracker_url</span><span class="whitespace"> </span><span class="operator">&lt;&lt;</span><span class="whitespace"> </span><span class="literal string">&quot;</span><span class="literal string escape">\n</span><span class="literal string">&quot;</span><span class="punctuation">;</span><span class="whitespace">
</span><span class="punctuation">}</span>
</pre>
<p>The following code is equivalent, but a little bit shorter:</p>
<pre class="code c++ literal-block">
<span class="name">entry</span><span class="whitespace"> </span><span class="name">torrent_file</span><span class="punctuation">;</span><span class="whitespace">
</span><span class="comment single">// ...
</span><span class="whitespace">
</span><span class="comment single">// throws if this is not a dictionary
</span><span class="keyword">if</span><span class="whitespace"> </span><span class="punctuation">(</span><span class="name">entry</span><span class="operator">*</span><span class="whitespace"> </span><span class="name">i</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">torrent_file</span><span class="punctuation">.</span><span class="name">find_key</span><span class="punctuation">(</span><span class="literal string">&quot;announce&quot;</span><span class="punctuation">))</span><span class="whitespace">
</span><span class="punctuation">{</span><span class="whitespace">
        </span><span class="name">std</span><span class="operator">::</span><span class="name">string</span><span class="whitespace"> </span><span class="name">tracker_url</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">i</span><span class="operator">-&gt;</span><span class="name">string</span><span class="punctuation">();</span><span class="whitespace">
        </span><span class="name">std</span><span class="operator">::</span><span class="name">cout</span><span class="whitespace"> </span><span class="operator">&lt;&lt;</span><span class="whitespace"> </span><span class="name">tracker_url</span><span class="whitespace"> </span><span class="operator">&lt;&lt;</span><span class="whitespace"> </span><span class="literal string">&quot;</span><span class="literal string escape">\n</span><span class="literal string">&quot;</span><span class="punctuation">;</span><span class="whitespace">
</span><span class="punctuation">}</span>
</pre>
<p>To make it easier to extract information from a torrent file, the
class <a class="reference external" href="reference-Torrent_Info.html#torrent_info">torrent_info</a> exists.</p>
<a name="swap()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:entry%3A%3A%5Bswap%28%29%5D&labels=documentation&body=Documentation+under+heading+%22entry%3A%3A%5Bswap%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="swap-3">
<h2>swap()</h2>
<pre class="literal-block">
void <strong>swap</strong> (entry&amp; e);
</pre>
<p>swaps the content of <em>this</em> with <tt class="docutils literal">e</tt>.</p>
<a name="operator[]()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:entry%3A%3A%5Boperator%5B%5D%28%29%5D&labels=documentation&body=Documentation+under+heading+%22entry%3A%3A%5Boperator%5B%5D%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="operator-2">
<h2>operator[]()</h2>
<pre class="literal-block">
entry const&amp; <strong>operator[]</strong> (string_view key) const;
entry&amp; <strong>operator[]</strong> (string_view key);
</pre>
<p>All of these functions requires the <a class="reference external" href="reference-Bencoding.html#entry">entry</a> to be a dictionary, if it
isn't they will throw <tt class="docutils literal">system_error</tt>.</p>
<p>The non-const versions of the <tt class="docutils literal">operator[]</tt> will return a reference
to either the existing element at the given key or, if there is no
element with the given key, a reference to a newly inserted element at
that key.</p>
<p>The const version of <tt class="docutils literal">operator[]</tt> will only return a reference to an
existing element at the given key. If the key is not found, it will
throw <tt class="docutils literal">system_error</tt>.</p>
<a name="find_key()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:entry%3A%3A%5Bfind_key%28%29%5D&labels=documentation&body=Documentation+under+heading+%22entry%3A%3A%5Bfind_key%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="find-key">
<h2>find_key()</h2>
<pre class="literal-block">
entry* <strong>find_key</strong> (string_view key);
entry const* <strong>find_key</strong> (string_view key) const;
</pre>
<p>These functions requires the <a class="reference external" href="reference-Bencoding.html#entry">entry</a> to be a dictionary, if it isn't
they will throw <tt class="docutils literal">system_error</tt>.</p>
<p>They will look for an element at the given key in the dictionary, if
the element cannot be found, they will return nullptr. If an element
with the given key is found, the return a pointer to it.</p>
<a name="to_string()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:entry%3A%3A%5Bto_string%28%29%5D&labels=documentation&body=Documentation+under+heading+%22entry%3A%3A%5Bto_string%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="to-string">
<h2>to_string()</h2>
<pre class="literal-block">
std::string <strong>to_string</strong> (bool single_line = false) const;
</pre>
<p>returns a pretty-printed string representation
of the bencoded structure, with JSON-style syntax</p>
<a name="data_type"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+data_type&labels=documentation&body=Documentation+under+heading+%22enum+data_type%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-data-type">
<h2>enum data_type</h2>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/entry.hpp">libtorrent/entry.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="19%" />
<col width="36%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>int_t</td>
<td>0</td>
<td>&nbsp;</td>
</tr>
<tr><td>string_t</td>
<td>1</td>
<td>&nbsp;</td>
</tr>
<tr><td>list_t</td>
<td>2</td>
<td>&nbsp;</td>
</tr>
<tr><td>dictionary_t</td>
<td>3</td>
<td>&nbsp;</td>
</tr>
<tr><td>undefined_t</td>
<td>4</td>
<td>&nbsp;</td>
</tr>
<tr><td>preformatted_t</td>
<td>5</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<a name="operator<<()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:operator%3C%3C%28%29&labels=documentation&body=Documentation+under+heading+%22operator%3C%3C%28%29%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="operator-3">
<h1>operator&lt;&lt;()</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/entry.hpp">libtorrent/entry.hpp</a>&quot;</p>
<pre class="literal-block">
inline std::ostream&amp; <strong>operator&lt;&lt;</strong> (std::ostream&amp; os, const entry&amp; e);
</pre>
<p>prints the bencoded structure to the ostream as a JSON-style structure.</p>
<a name="bencode()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:bencode%28%29&labels=documentation&body=Documentation+under+heading+%22bencode%28%29%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="bencode">
<h1>bencode()</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/bencode.hpp">libtorrent/bencode.hpp</a>&quot;</p>
<pre class="literal-block">
template&lt;class OutIt&gt; int <strong>bencode</strong> (OutIt out, const entry&amp; e);
</pre>
<p>This function will encode data to bencoded form.</p>
<p>The <a class="reference internal" href="#entry">entry</a> class is the internal representation of the bencoded data
and it can be used to retrieve information, an <a class="reference internal" href="#entry">entry</a> can also be build by
the program and given to <tt class="docutils literal">bencode()</tt> to encode it into the <tt class="docutils literal">OutIt</tt>
iterator.</p>
<p><tt class="docutils literal">OutIt</tt> is an <a class="reference external" href="https://en.cppreference.com/w/cpp/named_req/OutputIterator">OutputIterator</a>. It's a template and usually
instantiated as <a class="reference external" href="https://en.cppreference.com/w/cpp/iterator/ostream_iterator">ostream_iterator</a> or <a class="reference external" href="https://en.cppreference.com/w/cpp/iterator/back_insert_iterator">back_insert_iterator</a>. This
function assumes the value_type of the iterator is a <tt class="docutils literal">char</tt>.
In order to encode <a class="reference external" href="reference-Bencoding.html#entry">entry</a> <tt class="docutils literal">e</tt> into a buffer, do:</p>
<pre class="literal-block">
std::vector&lt;char&gt; buf;
bencode(std::back_inserter(buf), e);
</pre>
<a name="ip_filter"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+ip_filter&labels=documentation&body=Documentation+under+heading+%22class+ip_filter%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="ip-filter">
<h1>ip_filter</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/ip_filter.hpp">libtorrent/ip_filter.hpp</a>&quot;</p>
<p>The <tt class="docutils literal">ip_filter</tt> class is a set of rules that uniquely categorizes all
ip addresses as allowed or disallowed. The default constructor creates
a single rule that allows all addresses (0.0.0.0 - 255.255.255.255 for
the IPv4 range, and the equivalent range covering all addresses for the
IPv6 range).</p>
<p>A default constructed <a class="reference external" href="reference-Filter.html#ip_filter">ip_filter</a> does not filter any address.</p>
<pre class="literal-block">
struct ip_filter
{
   ip_filter&amp; <strong>operator=</strong> (ip_filter const&amp;);
   <strong>~ip_filter</strong> ();
   <strong>ip_filter</strong> (ip_filter&amp;&amp;);
   <strong>ip_filter</strong> (ip_filter const&amp;);
   ip_filter&amp; <strong>operator=</strong> (ip_filter&amp;&amp;);
   <strong>ip_filter</strong> ();
   bool <strong>empty</strong> () const;
   void <strong>add_rule</strong> (address const&amp; first, address const&amp; last, std::uint32_t flags);
   std::uint32_t <strong>access</strong> (address const&amp; addr) const;
   filter_tuple_t <strong>export_filter</strong> () const;

   enum access_flags
   {
      blocked,
   };
};
</pre>
<a name="empty()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:ip_filter%3A%3A%5Bempty%28%29%5D&labels=documentation&body=Documentation+under+heading+%22ip_filter%3A%3A%5Bempty%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="empty-1">
<h2>empty()</h2>
<pre class="literal-block">
bool <strong>empty</strong> () const;
</pre>
<p>returns true if the filter does not contain any rules</p>
<a name="add_rule()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:ip_filter%3A%3A%5Badd_rule%28%29%5D&labels=documentation&body=Documentation+under+heading+%22ip_filter%3A%3A%5Badd_rule%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="add-rule">
<h2>add_rule()</h2>
<pre class="literal-block">
void <strong>add_rule</strong> (address const&amp; first, address const&amp; last, std::uint32_t flags);
</pre>
<p>Adds a rule to the filter. <tt class="docutils literal">first</tt> and <tt class="docutils literal">last</tt> defines a range of
ip addresses that will be marked with the given flags. The <tt class="docutils literal">flags</tt>
can currently be 0, which means allowed, or <tt class="docutils literal"><span class="pre">ip_filter::blocked</span></tt>, which
means disallowed.</p>
<p>precondition:
<tt class="docutils literal">first.is_v4() == last.is_v4() &amp;&amp; first.is_v6() == last.is_v6()</tt></p>
<p>postcondition:
<tt class="docutils literal">access(x) == flags</tt> for every <tt class="docutils literal">x</tt> in the range [<tt class="docutils literal">first</tt>, <tt class="docutils literal">last</tt>]</p>
<p>This means that in a case of overlapping ranges, the last one applied takes
precedence.</p>
<a name="access()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:ip_filter%3A%3A%5Baccess%28%29%5D&labels=documentation&body=Documentation+under+heading+%22ip_filter%3A%3A%5Baccess%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="access">
<h2>access()</h2>
<pre class="literal-block">
std::uint32_t <strong>access</strong> (address const&amp; addr) const;
</pre>
<p>Returns the access permissions for the given address (<tt class="docutils literal">addr</tt>). The permission
can currently be 0 or <tt class="docutils literal"><span class="pre">ip_filter::blocked</span></tt>. The complexity of this operation
is O(<tt class="docutils literal">log</tt> n), where n is the minimum number of non-overlapping ranges to describe
the current filter.</p>
<a name="export_filter()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:ip_filter%3A%3A%5Bexport_filter%28%29%5D&labels=documentation&body=Documentation+under+heading+%22ip_filter%3A%3A%5Bexport_filter%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="export-filter">
<h2>export_filter()</h2>
<pre class="literal-block">
filter_tuple_t <strong>export_filter</strong> () const;
</pre>
<p>This function will return the current state of the filter in the minimum number of
ranges possible. They are sorted from ranges in low addresses to high addresses. Each
<a class="reference external" href="reference-Bencoding.html#entry">entry</a> in the returned vector is a range with the access control specified in its
<tt class="docutils literal">flags</tt> field.</p>
<p>The return value is a tuple containing two range-lists. One for IPv4 addresses
and one for IPv6 addresses.</p>
<a name="access_flags"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+access_flags&labels=documentation&body=Documentation+under+heading+%22enum+access_flags%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-access-flags">
<h2>enum access_flags</h2>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/ip_filter.hpp">libtorrent/ip_filter.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="12%" />
<col width="9%" />
<col width="78%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>blocked</td>
<td>1</td>
<td>indicates that IPs in this range should not be connected
to nor accepted as incoming connections</td>
</tr>
</tbody>
</table>
<a name="port_filter"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+port_filter&labels=documentation&body=Documentation+under+heading+%22class+port_filter%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="port-filter">
<h1>port_filter</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/ip_filter.hpp">libtorrent/ip_filter.hpp</a>&quot;</p>
<p>the port filter maps non-overlapping port ranges to flags. This
is primarily used to indicate whether a range of ports should
be connected to or not. The default is to have the full port
range (0-65535) set to flag 0.</p>
<pre class="literal-block">
class port_filter
{
   <strong>port_filter</strong> (port_filter&amp;&amp;);
   <strong>~port_filter</strong> ();
   port_filter&amp; <strong>operator=</strong> (port_filter&amp;&amp;);
   <strong>port_filter</strong> (port_filter const&amp;);
   port_filter&amp; <strong>operator=</strong> (port_filter const&amp;);
   <strong>port_filter</strong> ();
   void <strong>add_rule</strong> (std::uint16_t first, std::uint16_t last, std::uint32_t flags);
   std::uint32_t <strong>access</strong> (std::uint16_t port) const;

   enum access_flags
   {
      blocked,
   };
};
</pre>
<a name="add_rule()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:port_filter%3A%3A%5Badd_rule%28%29%5D&labels=documentation&body=Documentation+under+heading+%22port_filter%3A%3A%5Badd_rule%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="add-rule-1">
<h2>add_rule()</h2>
<pre class="literal-block">
void <strong>add_rule</strong> (std::uint16_t first, std::uint16_t last, std::uint32_t flags);
</pre>
<p>set the flags for the specified port range (<tt class="docutils literal">first</tt>, <tt class="docutils literal">last</tt>) to
<tt class="docutils literal">flags</tt> overwriting any existing rule for those ports. The range
is inclusive, i.e. the port <tt class="docutils literal">last</tt> also has the flag set on it.</p>
<a name="access()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:port_filter%3A%3A%5Baccess%28%29%5D&labels=documentation&body=Documentation+under+heading+%22port_filter%3A%3A%5Baccess%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="access-1">
<h2>access()</h2>
<pre class="literal-block">
std::uint32_t <strong>access</strong> (std::uint16_t port) const;
</pre>
<p>test the specified port (<tt class="docutils literal">port</tt>) for whether it is blocked
or not. The returned value is the flags set for this port.
see <a class="reference external" href="reference-Filter.html#access_flags">access_flags</a>.</p>
<a name="access_flags"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+access_flags&labels=documentation&body=Documentation+under+heading+%22enum+access_flags%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-access-flags-1">
<h2>enum access_flags</h2>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/ip_filter.hpp">libtorrent/ip_filter.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="10%" />
<col width="76%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>blocked</td>
<td>1</td>
<td>this flag indicates that destination ports in the
range should not be connected to</td>
</tr>
</tbody>
</table>
<a name="peer_class_info"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+peer_class_info&labels=documentation&body=Documentation+under+heading+%22class+peer_class_info%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="peer-class-info">
<h1>peer_class_info</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/peer_class.hpp">libtorrent/peer_class.hpp</a>&quot;</p>
<p>holds settings for a peer class. Used in <a class="reference external" href="reference-Session.html#set_peer_class()">set_peer_class()</a> and
<a class="reference external" href="reference-Session.html#get_peer_class()">get_peer_class()</a> calls.</p>
<pre class="literal-block">
struct peer_class_info
{
   bool ignore_unchoke_slots;
   int connection_limit_factor;
   std::string label;
   int upload_limit;
   int download_limit;
   int upload_priority;
   int download_priority;
};
</pre>
<a name="ignore_unchoke_slots"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_class_info%3A%3A%5Bignore_unchoke_slots%5D&labels=documentation&body=Documentation+under+heading+%22peer_class_info%3A%3A%5Bignore_unchoke_slots%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>ignore_unchoke_slots</dt>
<dd><tt class="docutils literal">ignore_unchoke_slots</tt> determines whether peers should always
unchoke a peer, regardless of the choking algorithm, or if it should
honor the unchoke slot limits. It's used for local peers by default.
If <em>any</em> of the peer classes a peer belongs to has this set to true,
that peer will be unchoked at all times.</dd>
</dl>
<a name="connection_limit_factor"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_class_info%3A%3A%5Bconnection_limit_factor%5D&labels=documentation&body=Documentation+under+heading+%22peer_class_info%3A%3A%5Bconnection_limit_factor%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>connection_limit_factor</dt>
<dd>adjusts the connection limit (global and per torrent) that applies to
this peer class. By default, local peers are allowed to exceed the
normal connection limit for instance. This is specified as a percent
factor. 100 makes the peer class apply normally to the limit. 200
means as long as there are fewer connections than twice the limit, we
accept this peer. This factor applies both to the global connection
limit and the per-torrent limit. Note that if not used carefully one
peer class can potentially completely starve out all other over time.</dd>
</dl>
<a name="label"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_class_info%3A%3A%5Blabel%5D&labels=documentation&body=Documentation+under+heading+%22peer_class_info%3A%3A%5Blabel%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>label</dt>
<dd>not used by libtorrent. It's intended as a potentially user-facing
identifier of this peer class.</dd>
</dl>
<a name="upload_limit"></a>
<a name="download_limit"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_class_info%3A%3A%5Bupload_limit+download_limit%5D&labels=documentation&body=Documentation+under+heading+%22peer_class_info%3A%3A%5Bupload_limit+download_limit%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>upload_limit download_limit</dt>
<dd>transfer rates limits for the whole peer class. They are specified in
bytes per second and apply to the sum of all peers that are members of
this class.</dd>
</dl>
<a name="upload_priority"></a>
<a name="download_priority"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_class_info%3A%3A%5Bupload_priority+download_priority%5D&labels=documentation&body=Documentation+under+heading+%22peer_class_info%3A%3A%5Bupload_priority+download_priority%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>upload_priority download_priority</dt>
<dd>relative priorities used by the bandwidth allocator in the rate
limiter. If no rate limits are in use, the priority is not used
either. Priorities start at 1 (0 is not a valid priority) and may not
exceed 255.</dd>
</dl>
<a name="peer_class_type_filter"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+peer_class_type_filter&labels=documentation&body=Documentation+under+heading+%22class+peer_class_type_filter%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="peer-class-type-filter">
<h1>peer_class_type_filter</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/peer_class_type_filter.hpp">libtorrent/peer_class_type_filter.hpp</a>&quot;</p>
<p><tt class="docutils literal">peer_class_type_filter</tt> is a simple container for rules for adding and subtracting
peer-classes from peers. It is applied <em>after</em> the peer class filter is applied (which
is based on the peer's IP address).</p>
<pre class="literal-block">
struct peer_class_type_filter
{
   void <strong>remove</strong> (socket_type_t const st, peer_class_t const peer_class);
   void <strong>add</strong> (socket_type_t const st, peer_class_t const peer_class);
   void <strong>allow</strong> (socket_type_t const st, peer_class_t const peer_class);
   void <strong>disallow</strong> (socket_type_t const st, peer_class_t const peer_class);
   std::uint32_t <strong>apply</strong> (socket_type_t const st, std::uint32_t peer_class_mask);
   friend bool <strong>operator==</strong> (peer_class_type_filter const&amp; lhs
      , peer_class_type_filter const&amp; rhs);

   enum socket_type_t
   {
      tcp_socket,
      utp_socket,
      ssl_tcp_socket,
      ssl_utp_socket,
      i2p_socket,
      num_socket_types,
   };
};
</pre>
<a name="remove()"></a>
<a name="add()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_class_type_filter%3A%3A%5Bremove%28%29+add%28%29%5D&labels=documentation&body=Documentation+under+heading+%22peer_class_type_filter%3A%3A%5Bremove%28%29+add%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="remove-add">
<h2>remove() add()</h2>
<pre class="literal-block">
void <strong>remove</strong> (socket_type_t const st, peer_class_t const peer_class);
void <strong>add</strong> (socket_type_t const st, peer_class_t const peer_class);
</pre>
<p><tt class="docutils literal">add()</tt> and <tt class="docutils literal">remove()</tt> adds and removes a peer class to be added
to new peers based on socket type.</p>
<a name="disallow()"></a>
<a name="allow()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_class_type_filter%3A%3A%5Bdisallow%28%29+allow%28%29%5D&labels=documentation&body=Documentation+under+heading+%22peer_class_type_filter%3A%3A%5Bdisallow%28%29+allow%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="disallow-allow">
<h2>disallow() allow()</h2>
<pre class="literal-block">
void <strong>allow</strong> (socket_type_t const st, peer_class_t const peer_class);
void <strong>disallow</strong> (socket_type_t const st, peer_class_t const peer_class);
</pre>
<p><tt class="docutils literal">disallow()</tt> and <tt class="docutils literal">allow()</tt> adds and removes a peer class to be
removed from new peers based on socket type.</p>
<p>The <tt class="docutils literal">peer_class</tt> argument cannot be greater than 31. The bitmasks representing
peer classes in the <tt class="docutils literal">peer_class_type_filter</tt> are 32 bits.</p>
<a name="apply()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_class_type_filter%3A%3A%5Bapply%28%29%5D&labels=documentation&body=Documentation+under+heading+%22peer_class_type_filter%3A%3A%5Bapply%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="apply">
<h2>apply()</h2>
<pre class="literal-block">
std::uint32_t <strong>apply</strong> (socket_type_t const st, std::uint32_t peer_class_mask);
</pre>
<p>takes a bitmask of peer classes and returns a new bitmask of
peer classes after the rules have been applied, based on the socket type argument
(<tt class="docutils literal">st</tt>).</p>
<a name="socket_type_t"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+socket_type_t&labels=documentation&body=Documentation+under+heading+%22enum+socket_type_t%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-socket-type-t-1">
<h2>enum socket_type_t</h2>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/peer_class_type_filter.hpp">libtorrent/peer_class_type_filter.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="24%" />
<col width="9%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>tcp_socket</td>
<td>0</td>
<td>these match the socket types from socket_type.hpp
shifted one down</td>
</tr>
<tr><td>utp_socket</td>
<td>1</td>
<td>&nbsp;</td>
</tr>
<tr><td>ssl_tcp_socket</td>
<td>2</td>
<td>&nbsp;</td>
</tr>
<tr><td>ssl_utp_socket</td>
<td>3</td>
<td>&nbsp;</td>
</tr>
<tr><td>i2p_socket</td>
<td>4</td>
<td>&nbsp;</td>
</tr>
<tr><td>num_socket_types</td>
<td>5</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<p>This section describes the functions and classes that are used
to create torrent files. It is a layered API with low level classes
and higher level convenience functions. A torrent is created in 4
steps:</p>
<ol class="arabic simple">
<li>first the files that will be part of the torrent are determined.</li>
<li>the torrent properties are set, such as tracker url, web seeds,
DHT nodes etc.</li>
<li>Read through all the files in the torrent, SHA-1 all the data
and set the piece hashes.</li>
<li>The torrent is bencoded into a file or buffer.</li>
</ol>
<p>If there are a lot of files and or deep directory hierarchies to
traverse, step one can be time consuming.</p>
<p>Typically step 3 is by far the most time consuming step, since it
requires to read all the bytes from all the files in the torrent.</p>
<p>All of these classes and functions are declared by including
<tt class="docutils literal">libtorrent/create_torrent.hpp</tt>.</p>
<p>example:</p>
<pre class="code c++ literal-block">
<span class="name">file_storage</span><span class="whitespace"> </span><span class="name">fs</span><span class="punctuation">;</span><span class="whitespace">

</span><span class="comment single">// recursively adds files in directories
</span><span class="name">add_files</span><span class="punctuation">(</span><span class="name">fs</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="literal string">&quot;./my_torrent&quot;</span><span class="punctuation">);</span><span class="whitespace">

</span><span class="name">create_torrent</span><span class="whitespace"> </span><span class="name function">t</span><span class="punctuation">(</span><span class="name">fs</span><span class="punctuation">);</span><span class="whitespace">
</span><span class="name">t</span><span class="punctuation">.</span><span class="name">add_tracker</span><span class="punctuation">(</span><span class="literal string">&quot;http://my.tracker.com/announce&quot;</span><span class="punctuation">);</span><span class="whitespace">
</span><span class="name">t</span><span class="punctuation">.</span><span class="name">set_creator</span><span class="punctuation">(</span><span class="literal string">&quot;libtorrent example&quot;</span><span class="punctuation">);</span><span class="whitespace">

</span><span class="comment single">// reads the files and calculates the hashes
</span><span class="name">set_piece_hashes</span><span class="punctuation">(</span><span class="name">t</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="literal string">&quot;.&quot;</span><span class="punctuation">);</span><span class="whitespace">

</span><span class="name">ofstream</span><span class="whitespace"> </span><span class="name">out</span><span class="punctuation">(</span><span class="literal string">&quot;my_torrent.torrent&quot;</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">std</span><span class="operator">::</span><span class="name">ios_base</span><span class="operator">::</span><span class="name">binary</span><span class="punctuation">);</span><span class="whitespace">
</span><span class="name">std</span><span class="operator">::</span><span class="name">vector</span><span class="operator">&lt;</span><span class="keyword type">char</span><span class="operator">&gt;</span><span class="whitespace"> </span><span class="name">buf</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">t</span><span class="punctuation">.</span><span class="name">generate_buf</span><span class="punctuation">();</span><span class="whitespace">
</span><span class="name">out</span><span class="punctuation">.</span><span class="name">write</span><span class="punctuation">(</span><span class="name">buf</span><span class="punctuation">.</span><span class="name">data</span><span class="punctuation">(),</span><span class="whitespace"> </span><span class="name">buf</span><span class="punctuation">.</span><span class="name">size</span><span class="punctuation">());</span><span class="whitespace">

</span><span class="comment single">// alternatively, generate an entry and encode it directly to an ostream
// iterator
</span><span class="name">bencode</span><span class="punctuation">(</span><span class="name">std</span><span class="operator">::</span><span class="name">ostream_iterator</span><span class="operator">&lt;</span><span class="keyword type">char</span><span class="operator">&gt;</span><span class="punctuation">(</span><span class="name">out</span><span class="punctuation">),</span><span class="whitespace"> </span><span class="name">t</span><span class="punctuation">.</span><span class="name">generate</span><span class="punctuation">());</span>
</pre>
<a name="create_torrent"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+create_torrent&labels=documentation&body=Documentation+under+heading+%22class+create_torrent%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="create-torrent">
<h1>create_torrent</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/create_torrent.hpp">libtorrent/create_torrent.hpp</a>&quot;</p>
<p>This class holds state for creating a torrent. After having added
all information to it, call <a class="reference external" href="reference-Create_Torrents.html#generate()">create_torrent::generate()</a> to generate
the torrent. The <a class="reference external" href="reference-Bencoding.html#entry">entry</a> that's returned can then be bencoded into a
.torrent file using <a class="reference external" href="reference-Bencoding.html#bencode()">bencode()</a>.</p>
<pre class="literal-block">
struct create_torrent
{
   explicit <strong>create_torrent</strong> (torrent_info const&amp; ti);
   explicit <strong>create_torrent</strong> (file_storage&amp; fs, int piece_size = 0
      , create_flags_t flags = {});
   entry <strong>generate</strong> () const;
   std::vector&lt;char&gt; <strong>generate_buf</strong> () const;
   file_storage const&amp; <strong>files</strong> () const;
   void <strong>set_comment</strong> (char const* str);
   void <strong>set_creator</strong> (char const* str);
   void <strong>set_creation_date</strong> (std::time_t timestamp);
   void <strong>set_hash</strong> (piece_index_t index, sha1_hash const&amp; h);
   void <strong>set_hash2</strong> (file_index_t file, piece_index_t::diff_type piece, sha256_hash const&amp; h);
   void <strong>add_url_seed</strong> (string_view url);
   void <strong>add_http_seed</strong> (string_view url);
   void <strong>add_node</strong> (std::pair&lt;std::string, int&gt; node);
   void <strong>add_tracker</strong> (string_view url, int tier = 0);
   void <strong>set_root_cert</strong> (string_view cert);
   void <strong>set_priv</strong> (bool p);
   bool <strong>priv</strong> () const;
   bool <strong>is_v1_only</strong> () const;
   bool <strong>is_v2_only</strong> () const;
   int <strong>num_pieces</strong> () const;
   piece_index_t <strong>end_piece</strong> () const;
   index_range&lt;piece_index_t&gt; <strong>piece_range</strong> () const noexcept;
   file_index_t <strong>end_file</strong> () const;
   index_range&lt;file_index_t&gt; <strong>file_range</strong> () const noexcept;
   index_range&lt;piece_index_t::diff_type&gt; <strong>file_piece_range</strong> (file_index_t f);
   std::int64_t <strong>total_size</strong> () const;
   int <strong>piece_length</strong> () const;
   int <strong>piece_size</strong> (piece_index_t i) const;
   void <strong>add_similar_torrent</strong> (sha1_hash ih);
   void <strong>add_collection</strong> (string_view c);

   static constexpr create_flags_t <strong>modification_time</strong>  = 2_bit;
   static constexpr create_flags_t <strong>symlinks</strong>  = 3_bit;
   static constexpr create_flags_t <strong>v2_only</strong>  = 5_bit;
   static constexpr create_flags_t <strong>v1_only</strong>  = 6_bit;
   static constexpr create_flags_t <strong>canonical_files</strong>  = 7_bit;
   static constexpr create_flags_t <strong>no_attributes</strong>  = 8_bit;
   static constexpr create_flags_t <strong>canonical_files_no_tail_padding</strong>  = 9_bit;
};
</pre>
<a name="create_torrent()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:create_torrent%3A%3A%5Bcreate_torrent%28%29%5D&labels=documentation&body=Documentation+under+heading+%22create_torrent%3A%3A%5Bcreate_torrent%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="create-torrent-1">
<h2>create_torrent()</h2>
<pre class="literal-block">
explicit <strong>create_torrent</strong> (torrent_info const&amp; ti);
explicit <strong>create_torrent</strong> (file_storage&amp; fs, int piece_size = 0
      , create_flags_t flags = {});
</pre>
<p>The <tt class="docutils literal">piece_size</tt> is the size of each piece in bytes. It must be a
power of 2 and a minimum of 16 kiB. If a piece size of 0 is
specified, a piece_size will be set automatically.
Piece sizes greater than 128 MiB are considered unreasonable and will
be rejected (with an lt::system_error exception).</p>
<p>The <tt class="docutils literal">flags</tt> arguments specifies options for the torrent creation. It can
be any combination of the flags defined by create_flags_t.</p>
<p>The <a class="reference external" href="reference-Storage.html#file_storage">file_storage</a> (<tt class="docutils literal">fs</tt>) parameter defines the files, sizes and
their properties for the torrent to be created. Set this up first,
before passing it to the <a class="reference external" href="reference-Create_Torrents.html#create_torrent">create_torrent</a> constructor.</p>
<p>The overload that takes a <tt class="docutils literal">torrent_info</tt> object will make a verbatim
copy of its info dictionary (to preserve the info-hash). The copy of
the info dictionary will be used by <a class="reference external" href="reference-Create_Torrents.html#generate()">create_torrent::generate()</a>. This means
that none of the member functions of <a class="reference external" href="reference-Create_Torrents.html#create_torrent">create_torrent</a> that affects
the content of the info dictionary (such as <a class="reference external" href="reference-Create_Torrents.html#set_hash()">set_hash()</a>), will
have any affect. Instead of using this overload, consider using
<a class="reference external" href="reference-Resume_Data.html#write_torrent_file()">write_torrent_file()</a> instead.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The <a class="reference external" href="reference-Storage.html#file_storage">file_storage</a> and <a class="reference external" href="reference-Torrent_Info.html#torrent_info">torrent_info</a> objects must stay alive for the
entire duration of the <a class="reference external" href="reference-Create_Torrents.html#create_torrent">create_torrent</a> object.</p>
</div>
<a name="generate()"></a>
<a name="generate_buf()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:create_torrent%3A%3A%5Bgenerate%28%29+generate_buf%28%29%5D&labels=documentation&body=Documentation+under+heading+%22create_torrent%3A%3A%5Bgenerate%28%29+generate_buf%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="generate-generate-buf">
<h2>generate() generate_buf()</h2>
<pre class="literal-block">
entry <strong>generate</strong> () const;
std::vector&lt;char&gt; <strong>generate_buf</strong> () const;
</pre>
<p>This function will generate the .torrent file as a bencode tree, or a
bencoded into a buffer.
In order to encode the <a class="reference external" href="reference-Bencoding.html#entry">entry</a> into a flat file, use the <a class="reference external" href="reference-Bencoding.html#bencode()">bencode()</a> function.</p>
<p>The function returning an <a class="reference external" href="reference-Bencoding.html#entry">entry</a> may be useful to add custom entries
to the torrent file before bencoding it and saving it to disk.</p>
<p>Whether the resulting torrent object is v1, v2 or hybrid depends on
whether any of the v1_only or v2_only flags were set on the
constructor. If neither were set, the resulting torrent depends on
which hashes were set. If both v1 and v2 hashes were set, a hybrid
torrent is created.</p>
<p>Any failure will cause this function to throw system_error, with an
appropriate error message. These are the reasons this call may throw:</p>
<ul class="simple">
<li>the file storage has 0 files</li>
<li>the total size of the file storage is 0 bytes (i.e. it only has
empty files)</li>
<li>not all v1 hashes (<a class="reference external" href="reference-Create_Torrents.html#set_hash()">set_hash()</a>) and not all v2 hashes (<a class="reference external" href="reference-Create_Torrents.html#set_hash2()">set_hash2()</a>)
were set</li>
<li>for v2 torrents, you may not have a directory with the same name as
a file. If that's encountered in the file storage, <a class="reference external" href="reference-Create_Torrents.html#generate()">generate()</a>
fails.</li>
</ul>
<a name="files()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:create_torrent%3A%3A%5Bfiles%28%29%5D&labels=documentation&body=Documentation+under+heading+%22create_torrent%3A%3A%5Bfiles%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="files">
<h2>files()</h2>
<pre class="literal-block">
file_storage const&amp; <strong>files</strong> () const;
</pre>
<p>returns an immutable reference to the <a class="reference external" href="reference-Storage.html#file_storage">file_storage</a> used to create
the torrent from.</p>
<a name="set_comment()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:create_torrent%3A%3A%5Bset_comment%28%29%5D&labels=documentation&body=Documentation+under+heading+%22create_torrent%3A%3A%5Bset_comment%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="set-comment">
<h2>set_comment()</h2>
<pre class="literal-block">
void <strong>set_comment</strong> (char const* str);
</pre>
<p>Sets the comment for the torrent. The string <tt class="docutils literal">str</tt> should be utf-8 encoded.
The comment in a torrent file is optional.</p>
<a name="set_creator()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:create_torrent%3A%3A%5Bset_creator%28%29%5D&labels=documentation&body=Documentation+under+heading+%22create_torrent%3A%3A%5Bset_creator%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="set-creator">
<h2>set_creator()</h2>
<pre class="literal-block">
void <strong>set_creator</strong> (char const* str);
</pre>
<p>Sets the creator of the torrent. The string <tt class="docutils literal">str</tt> should be utf-8 encoded.
This is optional.</p>
<a name="set_creation_date()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:create_torrent%3A%3A%5Bset_creation_date%28%29%5D&labels=documentation&body=Documentation+under+heading+%22create_torrent%3A%3A%5Bset_creation_date%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="set-creation-date">
<h2>set_creation_date()</h2>
<pre class="literal-block">
void <strong>set_creation_date</strong> (std::time_t timestamp);
</pre>
<p>sets the &quot;creation time&quot; field. Defaults to the system clock at the
time of construction of the <a class="reference external" href="reference-Create_Torrents.html#create_torrent">create_torrent</a> object. The timestamp is
specified in seconds, posix time. If the creation date is set to 0,
the &quot;creation date&quot; field will be omitted from the generated torrent.</p>
<a name="set_hash()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:create_torrent%3A%3A%5Bset_hash%28%29%5D&labels=documentation&body=Documentation+under+heading+%22create_torrent%3A%3A%5Bset_hash%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="set-hash">
<h2>set_hash()</h2>
<pre class="literal-block">
void <strong>set_hash</strong> (piece_index_t index, sha1_hash const&amp; h);
</pre>
<p>This sets the SHA-1 hash for the specified piece (<tt class="docutils literal">index</tt>). You are required
to set the hash for every piece in the torrent before generating it. If you have
the files on disk, you can use the high level convenience function to do this.
See <a class="reference external" href="reference-Create_Torrents.html#set_piece_hashes()">set_piece_hashes()</a>.
A SHA-1 hash of all zeros is internally used to indicate a hash that
has not been set. Setting such hash will not be considered set when
calling <a class="reference external" href="reference-Create_Torrents.html#generate()">generate()</a>.
This function will throw <tt class="docutils literal"><span class="pre">std::system_error</span></tt> if it is called on an
object constructed with the v2_only flag.</p>
<a name="set_hash2()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:create_torrent%3A%3A%5Bset_hash2%28%29%5D&labels=documentation&body=Documentation+under+heading+%22create_torrent%3A%3A%5Bset_hash2%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="set-hash2">
<h2>set_hash2()</h2>
<pre class="literal-block">
void <strong>set_hash2</strong> (file_index_t file, piece_index_t::diff_type piece, sha256_hash const&amp; h);
</pre>
<p>sets the bittorrent v2 hash for file <cite>file</cite> of the piece <cite>piece</cite>.
<cite>piece</cite> is relative to the first piece of the file, starting at 0. The
first piece in the file can be computed with
<a class="reference external" href="reference-Storage.html#file_index_at_piece()">file_storage::file_index_at_piece()</a>.
The hash, <cite>h</cite>, is the root of the merkle tree formed by the piece's
16 kiB blocks. Note that piece sizes must be powers-of-2, so all
per-piece merkle trees are complete.
A SHA-256 hash of all zeros is internally used to indicate a hash
that has not been set. Setting such hash will not be considered set
when calling <a class="reference external" href="reference-Create_Torrents.html#generate()">generate()</a>.
This function will throw <tt class="docutils literal"><span class="pre">std::system_error</span></tt> if it is called on an
object constructed with the v1_only flag.</p>
<a name="add_url_seed()"></a>
<a name="add_http_seed()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:create_torrent%3A%3A%5Badd_url_seed%28%29+add_http_seed%28%29%5D&labels=documentation&body=Documentation+under+heading+%22create_torrent%3A%3A%5Badd_url_seed%28%29+add_http_seed%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="add-url-seed-add-http-seed">
<h2>add_url_seed() add_http_seed()</h2>
<pre class="literal-block">
void <strong>add_url_seed</strong> (string_view url);
void <strong>add_http_seed</strong> (string_view url);
</pre>
<p>This adds a url seed to the torrent. You can have any number of url seeds. For a
single file torrent, this should be an HTTP url, pointing to a file with identical
content as the file of the torrent. For a multi-file torrent, it should point to
a directory containing a directory with the same name as this torrent, and all the
files of the torrent in it.</p>
<p>The second function, <tt class="docutils literal">add_http_seed()</tt> adds an HTTP seed instead.</p>
<a name="add_node()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:create_torrent%3A%3A%5Badd_node%28%29%5D&labels=documentation&body=Documentation+under+heading+%22create_torrent%3A%3A%5Badd_node%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="add-node">
<h2>add_node()</h2>
<pre class="literal-block">
void <strong>add_node</strong> (std::pair&lt;std::string, int&gt; node);
</pre>
<p>This adds a DHT node to the torrent. This especially useful if you're creating a
tracker less torrent. It can be used by clients to bootstrap their DHT node from.
The node is a hostname and a port number where there is a DHT node running.
You can have any number of DHT nodes in a torrent.</p>
<a name="add_tracker()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:create_torrent%3A%3A%5Badd_tracker%28%29%5D&labels=documentation&body=Documentation+under+heading+%22create_torrent%3A%3A%5Badd_tracker%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="add-tracker">
<h2>add_tracker()</h2>
<pre class="literal-block">
void <strong>add_tracker</strong> (string_view url, int tier = 0);
</pre>
<p>Adds a tracker to the torrent. This is not strictly required, but most torrents
use a tracker as their main source of peers. The url should be an <a class="reference external" href="http://">http://</a> or udp://
url to a machine running a bittorrent tracker that accepts announces for this torrent's
info-hash. The tier is the fallback priority of the tracker. All trackers with tier 0 are
tried first (in any order). If all fail, trackers with tier 1 are tried. If all of those
fail, trackers with tier 2 are tried, and so on.</p>
<a name="set_root_cert()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:create_torrent%3A%3A%5Bset_root_cert%28%29%5D&labels=documentation&body=Documentation+under+heading+%22create_torrent%3A%3A%5Bset_root_cert%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="set-root-cert">
<h2>set_root_cert()</h2>
<pre class="literal-block">
void <strong>set_root_cert</strong> (string_view cert);
</pre>
<p>This function sets an X.509 certificate in PEM format to the torrent. This makes the
torrent an <em>SSL torrent</em>. An SSL torrent requires that each peer has a valid certificate
signed by this root certificate. For SSL torrents, all peers are connecting over SSL
connections. For more information, see the section on <a class="reference external" href="manual-ref.html#ssl-torrents">ssl torrents</a>.</p>
<p>The string is not the path to the cert, it's the actual content of the
certificate.</p>
<a name="priv()"></a>
<a name="set_priv()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:create_torrent%3A%3A%5Bpriv%28%29+set_priv%28%29%5D&labels=documentation&body=Documentation+under+heading+%22create_torrent%3A%3A%5Bpriv%28%29+set_priv%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="priv-set-priv">
<h2>priv() set_priv()</h2>
<pre class="literal-block">
void <strong>set_priv</strong> (bool p);
bool <strong>priv</strong> () const;
</pre>
<p>Sets and queries the private flag of the torrent.
Torrents with the private flag set ask the client to not use any other
sources than the tracker for peers, and to not use DHT to advertise itself publicly,
only the tracker.</p>
<a name="num_pieces()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:create_torrent%3A%3A%5Bnum_pieces%28%29%5D&labels=documentation&body=Documentation+under+heading+%22create_torrent%3A%3A%5Bnum_pieces%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="num-pieces">
<h2>num_pieces()</h2>
<pre class="literal-block">
int <strong>num_pieces</strong> () const;
</pre>
<p>returns the number of pieces in the associated <a class="reference external" href="reference-Storage.html#file_storage">file_storage</a> object.</p>
<a name="piece_range()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:create_torrent%3A%3A%5Bpiece_range%28%29%5D&labels=documentation&body=Documentation+under+heading+%22create_torrent%3A%3A%5Bpiece_range%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="piece-range-1">
<h2>piece_range()</h2>
<pre class="literal-block">
index_range&lt;piece_index_t&gt; <strong>piece_range</strong> () const noexcept;
</pre>
<p>all piece indices in the torrent to be created</p>
<a name="file_range()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:create_torrent%3A%3A%5Bfile_range%28%29%5D&labels=documentation&body=Documentation+under+heading+%22create_torrent%3A%3A%5Bfile_range%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="file-range-1">
<h2>file_range()</h2>
<pre class="literal-block">
index_range&lt;file_index_t&gt; <strong>file_range</strong> () const noexcept;
</pre>
<p>all file indices in the torrent to be created</p>
<a name="file_piece_range()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:create_torrent%3A%3A%5Bfile_piece_range%28%29%5D&labels=documentation&body=Documentation+under+heading+%22create_torrent%3A%3A%5Bfile_piece_range%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="file-piece-range">
<h2>file_piece_range()</h2>
<pre class="literal-block">
index_range&lt;piece_index_t::diff_type&gt; <strong>file_piece_range</strong> (file_index_t f);
</pre>
<p>for v2 and hybrid torrents only, the pieces in the
specified file, specified as delta from the first piece in the file.
i.e. the first index is 0.</p>
<a name="total_size()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:create_torrent%3A%3A%5Btotal_size%28%29%5D&labels=documentation&body=Documentation+under+heading+%22create_torrent%3A%3A%5Btotal_size%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="total-size-1">
<h2>total_size()</h2>
<pre class="literal-block">
std::int64_t <strong>total_size</strong> () const;
</pre>
<p>the total number of bytes of all files and pad files</p>
<a name="piece_length()"></a>
<a name="piece_size()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:create_torrent%3A%3A%5Bpiece_length%28%29+piece_size%28%29%5D&labels=documentation&body=Documentation+under+heading+%22create_torrent%3A%3A%5Bpiece_length%28%29+piece_size%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="piece-length-piece-size">
<h2>piece_length() piece_size()</h2>
<pre class="literal-block">
int <strong>piece_length</strong> () const;
int <strong>piece_size</strong> (piece_index_t i) const;
</pre>
<p><tt class="docutils literal">piece_length()</tt> returns the piece size of all pieces but the
last one. <tt class="docutils literal">piece_size()</tt> returns the size of the specified piece.
these functions are just forwarding to the associated <a class="reference external" href="reference-Storage.html#file_storage">file_storage</a>.</p>
<a name="add_similar_torrent()"></a>
<a name="add_collection()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:create_torrent%3A%3A%5Badd_similar_torrent%28%29+add_collection%28%29%5D&labels=documentation&body=Documentation+under+heading+%22create_torrent%3A%3A%5Badd_similar_torrent%28%29+add_collection%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="add-similar-torrent-add-collection">
<h2>add_similar_torrent() add_collection()</h2>
<pre class="literal-block">
void <strong>add_similar_torrent</strong> (sha1_hash ih);
void <strong>add_collection</strong> (string_view c);
</pre>
<p>Add similar torrents (by info-hash) or collections of similar torrents.
Similar torrents are expected to share some files with this torrent.
Torrents sharing a collection name with this torrent are also expected
to share files with this torrent. A torrent may have more than one
collection and more than one similar torrents. For more information,
see <a class="reference external" href="https://www.bittorrent.org/beps/bep_0038.html">BEP 38</a>.</p>
<a name="modification_time"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:create_torrent%3A%3A%5Bmodification_time%5D&labels=documentation&body=Documentation+under+heading+%22create_torrent%3A%3A%5Bmodification_time%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>modification_time</dt>
<dd>This will include the file modification time as part of the torrent.
This is not enabled by default, as it might cause problems when you
create a torrent from separate files with the same content, hoping to
yield the same info-hash. If the files have different modification times,
with this option enabled, you would get different info-hashes for the
files.</dd>
</dl>
<a name="symlinks"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:create_torrent%3A%3A%5Bsymlinks%5D&labels=documentation&body=Documentation+under+heading+%22create_torrent%3A%3A%5Bsymlinks%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>symlinks</dt>
<dd>If this flag is set, files that are symlinks get a symlink attribute
set on them and their data will not be included in the torrent. This
is useful if you need to reconstruct a file hierarchy which contains
symlinks.</dd>
</dl>
<a name="v2_only"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:create_torrent%3A%3A%5Bv2_only%5D&labels=documentation&body=Documentation+under+heading+%22create_torrent%3A%3A%5Bv2_only%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>v2_only</dt>
<dd>Do not generate v1 metadata. The resulting torrent will only be usable by
clients which support v2. This requires setting all v2 hashes, with
<a class="reference external" href="reference-Create_Torrents.html#set_hash2()">set_hash2()</a> before calling <a class="reference external" href="reference-Create_Torrents.html#generate()">generate()</a>. Setting v1 hashes (with
<a class="reference external" href="reference-Create_Torrents.html#set_hash()">set_hash()</a>) is an error with this flag set.</dd>
</dl>
<a name="v1_only"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:create_torrent%3A%3A%5Bv1_only%5D&labels=documentation&body=Documentation+under+heading+%22create_torrent%3A%3A%5Bv1_only%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>v1_only</dt>
<dd>do not generate v2 metadata or enforce v2 alignment and padding rules
this is mainly for tests, not recommended for production use. This
requires setting all v1 hashes, with <a class="reference external" href="reference-Create_Torrents.html#set_hash()">set_hash()</a>, before calling
<a class="reference external" href="reference-Create_Torrents.html#generate()">generate()</a>. Setting v2 hashes (with <a class="reference external" href="reference-Create_Torrents.html#set_hash2()">set_hash2()</a>) is an error with
this flag set.</dd>
</dl>
<a name="canonical_files"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:create_torrent%3A%3A%5Bcanonical_files%5D&labels=documentation&body=Documentation+under+heading+%22create_torrent%3A%3A%5Bcanonical_files%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>canonical_files</dt>
<dd>This flag only affects v1-only torrents, and is only relevant
together with the v1_only_flag. This flag will force the
same file order and padding as a v2 (or hybrid) torrent would have.
It has the effect of ordering files and inserting pad files to align
them with piece boundaries.</dd>
</dl>
<a name="no_attributes"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:create_torrent%3A%3A%5Bno_attributes%5D&labels=documentation&body=Documentation+under+heading+%22create_torrent%3A%3A%5Bno_attributes%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>no_attributes</dt>
<dd>passing this flag to <a class="reference external" href="reference-Create_Torrents.html#add_files()">add_files()</a> will ignore file attributes (such as
executable or hidden) when adding the files to the file storage.
Since not all filesystems and operating systems support all file
attributes the resulting torrent may differ depending on where it's
created. If it's important for torrents to be created consistently
across systems, this flag should be set.</dd>
</dl>
<a name="canonical_files_no_tail_padding"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:create_torrent%3A%3A%5Bcanonical_files_no_tail_padding%5D&labels=documentation&body=Documentation+under+heading+%22create_torrent%3A%3A%5Bcanonical_files_no_tail_padding%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>canonical_files_no_tail_padding</dt>
<dd>this flag enforces the file layout to be canonical according to the
bittorrent v2 specification (just like the <tt class="docutils literal">canonical_files</tt> flag)
with the one exception that tail padding is not added to the last
file.
This behavior deviates from the specification but was the way
libtorrent created torrents in version up to and including 2.0.7.
This flag is here for backwards compatibility.</dd>
</dl>
<a name="add_files()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_files%28%29&labels=documentation&body=Documentation+under+heading+%22add_files%28%29%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="add-files">
<h1>add_files()</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/create_torrent.hpp">libtorrent/create_torrent.hpp</a>&quot;</p>
<pre class="literal-block">
void <strong>add_files</strong> (file_storage&amp; fs, std::string const&amp; file
   , std::function&lt;bool(std::string)&gt; p, create_flags_t flags = {});
void <strong>add_files</strong> (file_storage&amp; fs, std::string const&amp; file
   , create_flags_t flags = {});
</pre>
<p>Adds the file specified by <tt class="docutils literal">path</tt> to the <a class="reference external" href="reference-Storage.html#file_storage">file_storage</a> object. In case <tt class="docutils literal">path</tt>
refers to a directory, files will be added recursively from the directory.</p>
<p>If specified, the predicate <tt class="docutils literal">p</tt> is called once for every file and directory that
is encountered. Files for which <tt class="docutils literal">p</tt> returns true are added, and directories for
which <tt class="docutils literal">p</tt> returns true are traversed. <tt class="docutils literal">p</tt> must have the following signature:</p>
<pre class="code c++ literal-block">
<span class="keyword type">bool</span><span class="whitespace"> </span><span class="name function">Pred</span><span class="punctuation">(</span><span class="name">std</span><span class="operator">::</span><span class="name">string</span><span class="whitespace"> </span><span class="keyword">const</span><span class="operator">&amp;</span><span class="whitespace"> </span><span class="name">p</span><span class="punctuation">);</span>
</pre>
<p>The path that is passed in to the predicate is the full path of the file or
directory. If no predicate is specified, all files are added, and all directories
are traversed.</p>
<p>The &quot;..&quot; directory is never traversed.</p>
<p>The <tt class="docutils literal">flags</tt> argument should be the same as the flags passed to the <a class="reference internal" href="#create-torrent">create_torrent</a>
constructor.</p>
<a name="set_piece_hashes()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:set_piece_hashes%28%29&labels=documentation&body=Documentation+under+heading+%22set_piece_hashes%28%29%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="set-piece-hashes">
<h1>set_piece_hashes()</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/create_torrent.hpp">libtorrent/create_torrent.hpp</a>&quot;</p>
<pre class="literal-block">
inline void <strong>set_piece_hashes</strong> (create_torrent&amp; t, std::string const&amp; p
   , settings_interface const&amp; settings
   , std::function&lt;void(piece_index_t)&gt; const&amp; f);
inline void <strong>set_piece_hashes</strong> (create_torrent&amp; t, std::string const&amp; p);
void <strong>set_piece_hashes</strong> (create_torrent&amp; t, std::string const&amp; p
   , settings_interface const&amp; settings
   , std::function&lt;void(piece_index_t)&gt; const&amp; f, error_code&amp; ec);
inline void <strong>set_piece_hashes</strong> (create_torrent&amp; t, std::string const&amp; p
   , std::function&lt;void(piece_index_t)&gt; const&amp; f);
inline void <strong>set_piece_hashes</strong> (create_torrent&amp; t, std::string const&amp; p, error_code&amp; ec);
void <strong>set_piece_hashes</strong> (create_torrent&amp; t, std::string const&amp; p
   , std::function&lt;void(piece_index_t)&gt; const&amp; f, error_code&amp; ec);
void <strong>set_piece_hashes</strong> (create_torrent&amp; t, std::string const&amp; p
   , settings_interface const&amp; settings, disk_io_constructor_type disk_io
   , std::function&lt;void(piece_index_t)&gt; const&amp; f, error_code&amp; ec);
</pre>
<p>This function will assume that the files added to the torrent file exists at path
<tt class="docutils literal">p</tt>, read those files and hash the content and set the hashes in the <tt class="docutils literal">create_torrent</tt>
object. The optional function <tt class="docutils literal">f</tt> is called in between every hash that is set. <tt class="docutils literal">f</tt>
must have the following signature:</p>
<pre class="code c++ literal-block">
<span class="keyword type">void</span><span class="whitespace"> </span><span class="name function">Fun</span><span class="punctuation">(</span><span class="name">piece_index_t</span><span class="punctuation">);</span>
</pre>
<p>The overloads taking a <a class="reference external" href="reference-Settings.html#settings_pack">settings_pack</a> may be used to configure the
underlying disk access. Such as <tt class="docutils literal"><span class="pre">settings_pack::aio_threads</span></tt>.</p>
<p>The overloads that don't take an <tt class="docutils literal">error_code&amp;</tt> may throw an exception in case of a
file error, the other overloads sets the error code to reflect the error, if any.</p>
<a name="bdecode_node"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+bdecode_node&labels=documentation&body=Documentation+under+heading+%22class+bdecode_node%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="bdecode-node">
<h1>bdecode_node</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/bdecode.hpp">libtorrent/bdecode.hpp</a>&quot;</p>
<p>Sometimes it's important to get a non-owning reference to the root node (
to be able to copy it as a reference for instance). For that, use the
<a class="reference external" href="reference-Bdecoding.html#non_owning()">non_owning()</a> member function.</p>
<p>There are 5 different types of nodes, see <a class="reference external" href="reference-Torrent_Info.html#type_t">type_t</a>.</p>
<pre class="literal-block">
struct bdecode_node
{
   <strong>bdecode_node</strong> () = default;
   bdecode_node&amp; <strong>operator=</strong> (bdecode_node const&amp;) &amp;;
   <strong>bdecode_node</strong> (bdecode_node&amp;&amp;) noexcept;
   <strong>bdecode_node</strong> (bdecode_node const&amp;);
   bdecode_node&amp; <strong>operator=</strong> (bdecode_node&amp;&amp;) &amp; = default;
   type_t <strong>type</strong> () const noexcept;
   explicit operator <strong>bool</strong> () const noexcept;
   bdecode_node <strong>non_owning</strong> () const;
   std::ptrdiff_t <strong>data_offset</strong> () const noexcept;
   span&lt;char const&gt; <strong>data_section</strong> () const noexcept;
   string_view <strong>list_string_value_at</strong> (int i
      , string_view default_val = string_view()) const;
   bdecode_node <strong>list_at</strong> (int i) const;
   std::int64_t <strong>list_int_value_at</strong> (int i
      , std::int64_t default_val = 0) const;
   int <strong>list_size</strong> () const;
   std::pair&lt;bdecode_node, bdecode_node&gt; <strong>dict_at_node</strong> (int i) const;
   string_view <strong>dict_find_string_value</strong> (string_view key
      , string_view default_value = string_view()) const;
   bdecode_node <strong>dict_find_int</strong> (string_view key) const;
   bdecode_node <strong>dict_find_dict</strong> (string_view key) const;
   std::int64_t <strong>dict_find_int_value</strong> (string_view key
      , std::int64_t default_val = 0) const;
   bdecode_node <strong>dict_find</strong> (string_view key) const;
   std::pair&lt;string_view, bdecode_node&gt; <strong>dict_at</strong> (int i) const;
   int <strong>dict_size</strong> () const;
   bdecode_node <strong>dict_find_string</strong> (string_view key) const;
   bdecode_node <strong>dict_find_list</strong> (string_view key) const;
   std::int64_t <strong>int_value</strong> () const;
   char const* <strong>string_ptr</strong> () const;
   int <strong>string_length</strong> () const;
   std::ptrdiff_t <strong>string_offset</strong> () const;
   string_view <strong>string_value</strong> () const;
   void <strong>clear</strong> ();
   void <strong>swap</strong> (bdecode_node&amp; n);
   void <strong>reserve</strong> (int tokens);
   void <strong>switch_underlying_buffer</strong> (char const* buf) noexcept;
   bool <strong>has_soft_error</strong> (span&lt;char&gt; error) const;

   enum type_t
   {
      none_t,
      dict_t,
      list_t,
      string_t,
      int_t,
   };
};
</pre>
<a name="bdecode_node()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:bdecode_node%3A%3A%5Bbdecode_node%28%29%5D&labels=documentation&body=Documentation+under+heading+%22bdecode_node%3A%3A%5Bbdecode_node%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="bdecode-node-1">
<h2>bdecode_node()</h2>
<pre class="literal-block">
<strong>bdecode_node</strong> () = default;
</pre>
<p>creates a default constructed node, it will have the type <tt class="docutils literal">none_t</tt>.</p>
<a name="operator=()"></a>
<a name="bdecode_node()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:bdecode_node%3A%3A%5Boperator%3D%28%29+bdecode_node%28%29%5D&labels=documentation&body=Documentation+under+heading+%22bdecode_node%3A%3A%5Boperator%3D%28%29+bdecode_node%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="operator-bdecode-node">
<h2>operator=() bdecode_node()</h2>
<pre class="literal-block">
bdecode_node&amp; <strong>operator=</strong> (bdecode_node const&amp;) &amp;;
<strong>bdecode_node</strong> (bdecode_node&amp;&amp;) noexcept;
<strong>bdecode_node</strong> (bdecode_node const&amp;);
bdecode_node&amp; <strong>operator=</strong> (bdecode_node&amp;&amp;) &amp; = default;
</pre>
<p>For owning nodes, the copy will create a copy of the tree, but the
underlying buffer remains the same.</p>
<a name="type()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:bdecode_node%3A%3A%5Btype%28%29%5D&labels=documentation&body=Documentation+under+heading+%22bdecode_node%3A%3A%5Btype%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="type-3">
<h2>type()</h2>
<pre class="literal-block">
type_t <strong>type</strong> () const noexcept;
</pre>
<p>the type of this node. See <a class="reference external" href="reference-Torrent_Info.html#type_t">type_t</a>.</p>
<a name="bool()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:bdecode_node%3A%3A%5Bbool%28%29%5D&labels=documentation&body=Documentation+under+heading+%22bdecode_node%3A%3A%5Bbool%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="bool-1">
<h2>bool()</h2>
<pre class="literal-block">
explicit operator <strong>bool</strong> () const noexcept;
</pre>
<p>returns true if <a class="reference external" href="reference-Plugins.html#type()">type()</a> != none_t.</p>
<a name="non_owning()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:bdecode_node%3A%3A%5Bnon_owning%28%29%5D&labels=documentation&body=Documentation+under+heading+%22bdecode_node%3A%3A%5Bnon_owning%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="non-owning">
<h2>non_owning()</h2>
<pre class="literal-block">
bdecode_node <strong>non_owning</strong> () const;
</pre>
<p>return a non-owning reference to this node. This is useful to refer to
the root node without copying it in assignments.</p>
<a name="data_offset()"></a>
<a name="data_section()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:bdecode_node%3A%3A%5Bdata_offset%28%29+data_section%28%29%5D&labels=documentation&body=Documentation+under+heading+%22bdecode_node%3A%3A%5Bdata_offset%28%29+data_section%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="data-offset-data-section">
<h2>data_offset() data_section()</h2>
<pre class="literal-block">
std::ptrdiff_t <strong>data_offset</strong> () const noexcept;
span&lt;char const&gt; <strong>data_section</strong> () const noexcept;
</pre>
<p>returns the buffer and length of the section in the original bencoded
buffer where this node is defined. For a dictionary for instance, this
starts with <tt class="docutils literal">d</tt> and ends with <tt class="docutils literal">e</tt>, and has all the content of the
dictionary in between.
the <tt class="docutils literal">data_offset()</tt> function returns the byte-offset to this node in,
starting from the beginning of the buffer that was parsed.</p>
<a name="list_int_value_at()"></a>
<a name="list_string_value_at()"></a>
<a name="list_size()"></a>
<a name="list_at()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:bdecode_node%3A%3A%5Blist_int_value_at%28%29+list_string_value_at%28%29+list_size%28%29+list_at%28%29%5D&labels=documentation&body=Documentation+under+heading+%22bdecode_node%3A%3A%5Blist_int_value_at%28%29+list_string_value_at%28%29+list_size%28%29+list_at%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="list-int-value-at-list-string-value-at-list-size-list-at">
<h2>list_int_value_at() list_string_value_at() list_size() list_at()</h2>
<pre class="literal-block">
string_view <strong>list_string_value_at</strong> (int i
      , string_view default_val = string_view()) const;
bdecode_node <strong>list_at</strong> (int i) const;
std::int64_t <strong>list_int_value_at</strong> (int i
      , std::int64_t default_val = 0) const;
int <strong>list_size</strong> () const;
</pre>
<p>functions with the <tt class="docutils literal">list_</tt> prefix operate on lists. These functions are
only valid if <tt class="docutils literal">type()</tt> == <tt class="docutils literal">list_t</tt>. <tt class="docutils literal">list_at()</tt> returns the item
in the list at index <tt class="docutils literal">i</tt>. <tt class="docutils literal">i</tt> may not be greater than or equal to the
size of the list. <tt class="docutils literal">size()</tt> returns the size of the list.</p>
<a name="dict_find_dict()"></a>
<a name="dict_find_string()"></a>
<a name="dict_find_list()"></a>
<a name="dict_at()"></a>
<a name="dict_find_int()"></a>
<a name="dict_find_string_value()"></a>
<a name="dict_find_int_value()"></a>
<a name="dict_at_node()"></a>
<a name="dict_size()"></a>
<a name="dict_find()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:bdecode_node%3A%3A%5Bdict_find_dict%28%29+dict_find_string%28%29+dict_find_list%28%29+dict_at%28%29+dict_find_int%28%29+dict_find_string_value%28%29+dict_find_int_value%28%29+dict_at_node%28%29+dict_size%28%29+dict_find%28%29%5D&labels=documentation&body=Documentation+under+heading+%22bdecode_node%3A%3A%5Bdict_find_dict%28%29+dict_find_string%28%29+dict_find_list%28%29+dict_at%28%29+dict_find_int%28%29+dict_find_string_value%28%29+dict_find_int_value%28%29+dict_at_node%28%29+dict_size%28%29+dict_find%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="dict-find-dict-dict-find-string-dict-find-list-dict-at-dict-find-int-dict-find-string-value-dict-find-int-value-dict-at-node-dict-size-dict-find">
<h2>dict_find_dict() dict_find_string() dict_find_list() dict_at() dict_find_int() dict_find_string_value() dict_find_int_value() dict_at_node() dict_size() dict_find()</h2>
<pre class="literal-block">
std::pair&lt;bdecode_node, bdecode_node&gt; <strong>dict_at_node</strong> (int i) const;
string_view <strong>dict_find_string_value</strong> (string_view key
      , string_view default_value = string_view()) const;
bdecode_node <strong>dict_find_int</strong> (string_view key) const;
bdecode_node <strong>dict_find_dict</strong> (string_view key) const;
std::int64_t <strong>dict_find_int_value</strong> (string_view key
      , std::int64_t default_val = 0) const;
bdecode_node <strong>dict_find</strong> (string_view key) const;
std::pair&lt;string_view, bdecode_node&gt; <strong>dict_at</strong> (int i) const;
int <strong>dict_size</strong> () const;
bdecode_node <strong>dict_find_string</strong> (string_view key) const;
bdecode_node <strong>dict_find_list</strong> (string_view key) const;
</pre>
<p>Functions with the <tt class="docutils literal">dict_</tt> prefix operates on dictionaries. They are
only valid if <tt class="docutils literal">type()</tt> == <tt class="docutils literal">dict_t</tt>. In case a key you're looking up
contains a 0 byte, you cannot use the 0-terminated string overloads,
but have to use <tt class="docutils literal">string_view</tt> instead. <tt class="docutils literal">dict_find_list</tt> will return a
valid <tt class="docutils literal">bdecode_node</tt> if the key is found _and_ it is a list. Otherwise
it will return a default-constructed <a class="reference external" href="reference-Bdecoding.html#bdecode_node">bdecode_node</a>.</p>
<p>Functions with the <tt class="docutils literal">_value</tt> suffix return the value of the node
directly, rather than the nodes. In case the node is not found, or it has
a different type, a default value is returned (which can be specified).</p>
<p><tt class="docutils literal">dict_at()</tt> returns the (key, value)-pair at the specified index in a
dictionary. Keys are only allowed to be strings. <tt class="docutils literal">dict_at_node()</tt> also
returns the (key, value)-pair, but the key is returned as a
<tt class="docutils literal">bdecode_node</tt> (and it will always be a string).</p>
<a name="int_value()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:bdecode_node%3A%3A%5Bint_value%28%29%5D&labels=documentation&body=Documentation+under+heading+%22bdecode_node%3A%3A%5Bint_value%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="int-value">
<h2>int_value()</h2>
<pre class="literal-block">
std::int64_t <strong>int_value</strong> () const;
</pre>
<p>this function is only valid if <tt class="docutils literal">type()</tt> == <tt class="docutils literal">int_t</tt>. It returns the
value of the integer.</p>
<a name="string_length()"></a>
<a name="string_value()"></a>
<a name="string_offset()"></a>
<a name="string_ptr()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:bdecode_node%3A%3A%5Bstring_length%28%29+string_value%28%29+string_offset%28%29+string_ptr%28%29%5D&labels=documentation&body=Documentation+under+heading+%22bdecode_node%3A%3A%5Bstring_length%28%29+string_value%28%29+string_offset%28%29+string_ptr%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="string-length-string-value-string-offset-string-ptr">
<h2>string_length() string_value() string_offset() string_ptr()</h2>
<pre class="literal-block">
char const* <strong>string_ptr</strong> () const;
int <strong>string_length</strong> () const;
std::ptrdiff_t <strong>string_offset</strong> () const;
string_view <strong>string_value</strong> () const;
</pre>
<p>these functions are only valid if <tt class="docutils literal">type()</tt> == <tt class="docutils literal">string_t</tt>. They return
the string values. Note that <tt class="docutils literal">string_ptr()</tt> is <em>not</em> 0-terminated.
<tt class="docutils literal">string_length()</tt> returns the number of bytes in the string.
<tt class="docutils literal">string_offset()</tt> returns the byte offset from the start of the parsed
bencoded buffer this string can be found.</p>
<a name="clear()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:bdecode_node%3A%3A%5Bclear%28%29%5D&labels=documentation&body=Documentation+under+heading+%22bdecode_node%3A%3A%5Bclear%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="clear">
<h2>clear()</h2>
<pre class="literal-block">
void <strong>clear</strong> ();
</pre>
<p>resets the <tt class="docutils literal">bdecoded_node</tt> to a default constructed state. If this is
an owning node, the tree is freed and all child nodes are invalidated.</p>
<a name="swap()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:bdecode_node%3A%3A%5Bswap%28%29%5D&labels=documentation&body=Documentation+under+heading+%22bdecode_node%3A%3A%5Bswap%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="swap-4">
<h2>swap()</h2>
<pre class="literal-block">
void <strong>swap</strong> (bdecode_node&amp; n);
</pre>
<p>Swap contents.</p>
<a name="reserve()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:bdecode_node%3A%3A%5Breserve%28%29%5D&labels=documentation&body=Documentation+under+heading+%22bdecode_node%3A%3A%5Breserve%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="reserve-1">
<h2>reserve()</h2>
<pre class="literal-block">
void <strong>reserve</strong> (int tokens);
</pre>
<p>preallocate memory for the specified numbers of tokens. This is
useful if you know approximately how many tokens are in the file
you are about to parse. Doing so will save realloc operations
while parsing. You should only call this on the root node, before
passing it in to <a class="reference external" href="reference-Bdecoding.html#bdecode()">bdecode()</a>.</p>
<a name="switch_underlying_buffer()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:bdecode_node%3A%3A%5Bswitch_underlying_buffer%28%29%5D&labels=documentation&body=Documentation+under+heading+%22bdecode_node%3A%3A%5Bswitch_underlying_buffer%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="switch-underlying-buffer">
<h2>switch_underlying_buffer()</h2>
<pre class="literal-block">
void <strong>switch_underlying_buffer</strong> (char const* buf) noexcept;
</pre>
<p>this buffer <em>MUST</em> be identical to the one originally parsed. This
operation is only defined on owning root nodes, i.e. the one passed in to
decode().</p>
<a name="has_soft_error()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:bdecode_node%3A%3A%5Bhas_soft_error%28%29%5D&labels=documentation&body=Documentation+under+heading+%22bdecode_node%3A%3A%5Bhas_soft_error%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="has-soft-error">
<h2>has_soft_error()</h2>
<pre class="literal-block">
bool <strong>has_soft_error</strong> (span&lt;char&gt; error) const;
</pre>
<p>returns true if there is a non-fatal error in the bencoding of this node
or its children</p>
<a name="type_t"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+type_t&labels=documentation&body=Documentation+under+heading+%22enum+type_t%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-type-t">
<h2>enum type_t</h2>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/bdecode.hpp">libtorrent/bdecode.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="9%" />
<col width="78%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>none_t</td>
<td>0</td>
<td>uninitialized or default constructed. This is also used
to indicate that a node was not found in some cases.</td>
</tr>
<tr><td>dict_t</td>
<td>1</td>
<td>a dictionary node. The <tt class="docutils literal">dict_find_</tt> functions are valid.</td>
</tr>
<tr><td>list_t</td>
<td>2</td>
<td>a list node. The <tt class="docutils literal">list_</tt> functions are valid.</td>
</tr>
<tr><td>string_t</td>
<td>3</td>
<td>a string node, the <tt class="docutils literal">string_</tt> functions are valid.</td>
</tr>
<tr><td>int_t</td>
<td>4</td>
<td>an integer node. The <tt class="docutils literal">int_</tt> functions are valid.</td>
</tr>
</tbody>
</table>
<a name="print_entry()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:print_entry%28%29&labels=documentation&body=Documentation+under+heading+%22print_entry%28%29%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="print-entry">
<h1>print_entry()</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/bdecode.hpp">libtorrent/bdecode.hpp</a>&quot;</p>
<pre class="literal-block">
std::string <strong>print_entry</strong> (bdecode_node const&amp; e
   , bool single_line = false, int indent = 0);
</pre>
<p>print the bencoded structure in a human-readable format to a string
that's returned.</p>
<a name="bdecode()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:bdecode%28%29&labels=documentation&body=Documentation+under+heading+%22bdecode%28%29%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="bdecode">
<h1>bdecode()</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/bdecode.hpp">libtorrent/bdecode.hpp</a>&quot;</p>
<pre class="literal-block">
bdecode_node <strong>bdecode</strong> (span&lt;char const&gt; buffer
   , int depth_limit = 100, int token_limit = 2000000);
bdecode_node <strong>bdecode</strong> (span&lt;char const&gt; buffer
   , error_code&amp; ec, int* error_pos = nullptr, int depth_limit = 100
   , int token_limit = 2000000);
int <strong>bdecode</strong> (char const* start, char const* end, bdecode_node&amp; ret
   , error_code&amp; ec, int* error_pos = nullptr, int depth_limit = 100
   , int token_limit = 2000000);
</pre>
<p>This function decodes/parses bdecoded data (for example a .torrent file).
The data structure is returned in the <tt class="docutils literal">ret</tt> argument. the buffer to parse
is specified by the <tt class="docutils literal">start</tt> of the buffer as well as the <tt class="docutils literal">end</tt>, i.e. one
byte past the end. If the buffer fails to parse, the function returns a
non-zero value and fills in <tt class="docutils literal">ec</tt> with the error code. The optional
argument <tt class="docutils literal">error_pos</tt>, if set to non-nullptr, will be set to the byte offset
into the buffer where the parse failure occurred.</p>
<p><tt class="docutils literal">depth_limit</tt> specifies the max number of nested lists or dictionaries are
allowed in the data structure. (This affects the stack usage of the
function, be careful not to set it too high).</p>
<p><tt class="docutils literal">token_limit</tt> is the max number of tokens allowed to be parsed from the
buffer. This is simply a sanity check to not have unbounded memory usage.</p>
<p>The resulting <tt class="docutils literal">bdecode_node</tt> is an <em>owning</em> node. That means it will
be holding the whole parsed tree. When iterating lists and dictionaries,
those <tt class="docutils literal">bdecode_node</tt> objects will simply have references to the root or
owning <tt class="docutils literal">bdecode_node</tt>. If the root node is destructed, all other nodes
that refer to anything in that tree become invalid.</p>
<p>However, the underlying buffer passed in to this function (<tt class="docutils literal">start</tt>, <tt class="docutils literal">end</tt>)
must also remain valid while the bdecoded tree is used. The parsed tree
produced by this function does not copy any data out of the buffer, but
simply produces references back into it.</p>
<a name="client_data_t"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+client_data_t&labels=documentation&body=Documentation+under+heading+%22class+client_data_t%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="client-data-t">
<h1>client_data_t</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/client_data.hpp">libtorrent/client_data.hpp</a>&quot;</p>
<p>A thin wrapper around a void pointer used as &quot;user data&quot;. i.e. an opaque
cookie passed in to libtorrent and returned on demand. It adds type-safety by
requiring the same type be requested out of it as was assigned to it.</p>
<pre class="literal-block">
struct client_data_t
{
   <strong>client_data_t</strong> () = default;
   explicit <strong>client_data_t</strong> (T* v);
   client_data_t&amp; <strong>operator=</strong> (T* v);
   T* <strong>get</strong> () const;
   explicit operator <strong>T</strong> () const;
   client_data_t&amp; <strong>operator=</strong> (void*) = delete;
   operator <strong>void*</strong> () const = delete;
   client_data_t&amp; <strong>operator=</strong> (void const*) = delete;
   operator void <strong>const*</strong> () const = delete;

   template &lt;typename T, typename <strong>U</strong>  = typename std::enable_if&lt;std::is_pointer&lt;T&gt;::value&gt;::type&gt;
};
</pre>
<a name="client_data_t()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:client_data_t%3A%3A%5Bclient_data_t%28%29%5D&labels=documentation&body=Documentation+under+heading+%22client_data_t%3A%3A%5Bclient_data_t%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="client-data-t-1">
<h2>client_data_t()</h2>
<pre class="literal-block">
<strong>client_data_t</strong> () = default;
</pre>
<p>construct a nullptr client data</p>
<a name="void*()"></a>
<a name="operator=()"></a>
<a name="const*()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:client_data_t%3A%3A%5Bvoid%2A%28%29+operator%3D%28%29+const%2A%28%29%5D&labels=documentation&body=Documentation+under+heading+%22client_data_t%3A%3A%5Bvoid%2A%28%29+operator%3D%28%29+const%2A%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="void-operator-const">
<h2>void*() operator=() const*()</h2>
<pre class="literal-block">
client_data_t&amp; <strong>operator=</strong> (void*) = delete;
operator <strong>void*</strong> () const = delete;
client_data_t&amp; <strong>operator=</strong> (void const*) = delete;
operator void <strong>const*</strong> () const = delete;
</pre>
<p>we don't allow type-unsafe operations</p>
<a name="add_torrent_params"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+add_torrent_params&labels=documentation&body=Documentation+under+heading+%22class+add_torrent_params%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="add-torrent-params">
<h1>add_torrent_params</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/add_torrent_params.hpp">libtorrent/add_torrent_params.hpp</a>&quot;</p>
<p>The <a class="reference external" href="reference-Add_Torrent.html#add_torrent_params">add_torrent_params</a> contains all the information in a .torrent file
along with all information necessary to add that torrent to a <a class="reference external" href="reference-Session.html#session">session</a>.
The key fields when adding a torrent are:</p>
<ul class="simple">
<li>ti - the immutable info-dict part of the torrent</li>
<li>info_hash - when you don't have the metadata (.torrent file). This
uniquely identifies the torrent and can validate the info-dict when
received from the swarm.</li>
</ul>
<p>In order to add a torrent to a <a class="reference external" href="reference-Session.html#session">session</a>, one of those fields must be set
in addition to <tt class="docutils literal">save_path</tt>. The <a class="reference external" href="reference-Add_Torrent.html#add_torrent_params">add_torrent_params</a> object can then be
passed into one of the <tt class="docutils literal"><span class="pre">session::add_torrent()</span></tt> overloads or
<tt class="docutils literal"><span class="pre">session::async_add_torrent()</span></tt>.</p>
<p>If you only specify the info-hash, the torrent file will be downloaded
from peers, which requires them to support the metadata extension. For
the metadata extension to work, libtorrent must be built with extensions
enabled (<tt class="docutils literal">TORRENT_DISABLE_EXTENSIONS</tt> must not be defined). It also
takes an optional <tt class="docutils literal">name</tt> argument. This may be left empty in case no
name should be assigned to the torrent. In case it's not, the name is
used for the torrent as long as it doesn't have metadata. See
<tt class="docutils literal"><span class="pre">torrent_handle::name</span></tt>.</p>
<p>The <tt class="docutils literal">add_torrent_params</tt> is also used when requesting resume data for a
torrent. It can be saved to and restored from a file and added back to a
new <a class="reference external" href="reference-Session.html#session">session</a>. For serialization and de-serialization of
<tt class="docutils literal">add_torrent_params</tt> objects, see <a class="reference external" href="reference-Resume_Data.html#read_resume_data()">read_resume_data()</a> and
<a class="reference external" href="reference-Resume_Data.html#write_resume_data()">write_resume_data()</a>.</p>
<p>The <tt class="docutils literal">add_torrent_params</tt> is also used to represent a parsed .torrent
file. It can be loaded via <a class="reference external" href="reference-Core.html#load_torrent_file()">load_torrent_file()</a>, <a class="reference external" href="reference-Core.html#load_torrent_buffer()">load_torrent_buffer()</a> and
<a class="reference external" href="reference-Core.html#load_torrent_parsed()">load_torrent_parsed()</a>. It can be saved via <a class="reference external" href="reference-Resume_Data.html#write_torrent_file()">write_torrent_file()</a>.</p>
<pre class="literal-block">
struct add_torrent_params
{
   int <strong>version</strong>  = LIBTORRENT_VERSION_NUM;
   std::shared_ptr&lt;torrent_info&gt; ti;
   aux::noexcept_movable&lt;std::vector&lt;std::string&gt;&gt; trackers;
   aux::noexcept_movable&lt;std::vector&lt;int&gt;&gt; tracker_tiers;
   aux::noexcept_movable&lt;std::vector&lt;std::pair&lt;std::string, int&gt;&gt;&gt; dht_nodes;
   std::string name;
   std::string save_path;
   storage_mode_t <strong>storage_mode</strong>  = storage_mode_sparse;
   client_data_t userdata;
   aux::noexcept_movable&lt;std::vector&lt;download_priority_t&gt;&gt; file_priorities;
   std::string trackerid;
   torrent_flags_t <strong>flags</strong>  = torrent_flags::default_flags;
   info_hash_t info_hashes;
   int <strong>max_uploads</strong>  = -1;
   int <strong>max_connections</strong>  = -1;
   int <strong>upload_limit</strong>  = -1;
   int <strong>download_limit</strong>  = -1;
   std::int64_t <strong>total_uploaded</strong>  = 0;
   std::int64_t <strong>total_downloaded</strong>  = 0;
   int <strong>active_time</strong>  = 0;
   int <strong>finished_time</strong>  = 0;
   int <strong>seeding_time</strong>  = 0;
   std::time_t <strong>added_time</strong>  = 0;
   std::time_t <strong>completed_time</strong>  = 0;
   std::time_t <strong>last_seen_complete</strong>  = 0;
   int <strong>num_complete</strong>  = -1;
   int <strong>num_incomplete</strong>  = -1;
   int <strong>num_downloaded</strong>  = -1;
   aux::noexcept_movable&lt;std::vector&lt;std::string&gt;&gt; http_seeds;
   aux::noexcept_movable&lt;std::vector&lt;std::string&gt;&gt; url_seeds;
   aux::noexcept_movable&lt;std::vector&lt;tcp::endpoint&gt;&gt; peers;
   aux::noexcept_movable&lt;std::vector&lt;tcp::endpoint&gt;&gt; banned_peers;
   aux::noexcept_movable&lt;std::map&lt;piece_index_t, bitfield&gt;&gt; unfinished_pieces;
   typed_bitfield&lt;piece_index_t&gt; have_pieces;
   typed_bitfield&lt;piece_index_t&gt; verified_pieces;
   aux::noexcept_movable&lt;std::vector&lt;download_priority_t&gt;&gt; piece_priorities;
   aux::vector&lt;std::vector&lt;sha256_hash&gt;, file_index_t&gt; merkle_trees;
   aux::vector&lt;std::vector&lt;bool&gt;, file_index_t&gt; merkle_tree_mask;
   aux::vector&lt;std::vector&lt;bool&gt;, file_index_t&gt; verified_leaf_hashes;
   aux::noexcept_movable&lt;std::map&lt;file_index_t, std::string&gt;&gt; renamed_files;
   std::time_t <strong>last_download</strong>  = 0;
   std::time_t <strong>last_upload</strong>  = 0;
};
</pre>
<a name="version"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Bversion%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Bversion%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>version</dt>
<dd>filled in by the constructor and should be left untouched. It is used
for forward binary compatibility.</dd>
</dl>
<a name="ti"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Bti%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Bti%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>ti</dt>
<dd><a class="reference external" href="reference-Torrent_Info.html#torrent_info">torrent_info</a> object with the torrent to add. Unless the
info_hash is set, this is required to be initialized.</dd>
</dl>
<a name="trackers"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Btrackers%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Btrackers%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>trackers</dt>
<dd>If the torrent doesn't have a tracker, but relies on the DHT to find
peers, the <tt class="docutils literal">trackers</tt> can specify tracker URLs for the torrent.</dd>
</dl>
<a name="tracker_tiers"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Btracker_tiers%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Btracker_tiers%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>tracker_tiers</dt>
<dd>the tiers the URLs in <tt class="docutils literal">trackers</tt> belong to. Trackers belonging to
different tiers may be treated differently, as defined by the multi
tracker extension. This is optional, if not specified trackers are
assumed to be part of tier 0, or whichever the last tier was as
iterating over the trackers.</dd>
</dl>
<a name="dht_nodes"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Bdht_nodes%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Bdht_nodes%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>dht_nodes</dt>
<dd>a list of hostname and port pairs, representing DHT nodes to be added
to the <a class="reference external" href="reference-Session.html#session">session</a> (if DHT is enabled). The hostname may be an IP address.</dd>
</dl>
<a name="name"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Bname%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Bname%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>name</dt>
<dd>in case there's no other name in this torrent, this name will be used.
The name out of the <a class="reference external" href="reference-Torrent_Info.html#torrent_info">torrent_info</a> object takes precedence if available.</dd>
</dl>
<a name="save_path"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Bsave_path%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Bsave_path%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>save_path</dt>
<dd><p class="first">the path where the torrent is or will be stored.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">On windows this path (and other paths) are interpreted as UNC
paths. This means they must use backslashes as directory separators
and may not contain the special directories &quot;.&quot; or &quot;..&quot;.</p>
</div>
<p class="last">Setting this to an absolute path performs slightly better than a
relative path.</p>
</dd>
</dl>
<a name="storage_mode"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Bstorage_mode%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Bstorage_mode%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>storage_mode</dt>
<dd>One of the values from <a class="reference external" href="reference-Storage.html#storage_mode_t">storage_mode_t</a>. For more information, see
<a class="reference external" href="manual-ref.html#storage-allocation">storage allocation</a>.</dd>
</dl>
<a name="userdata"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Buserdata%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Buserdata%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>userdata</dt>
<dd>The <tt class="docutils literal">userdata</tt> parameter is optional and will be passed on to the
extension constructor functions, if any
(see <a class="reference external" href="reference-Torrent_Handle.html#add_extension()">torrent_handle::add_extension()</a>). It will also be stored in the
torrent object and can be retrieved by calling <a class="reference external" href="reference-Torrent_Handle.html#userdata()">userdata()</a>.</dd>
</dl>
<a name="file_priorities"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Bfile_priorities%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Bfile_priorities%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>file_priorities</dt>
<dd>can be set to control the initial file priorities when adding a
torrent. The semantics are the same as for
<tt class="docutils literal"><span class="pre">torrent_handle::prioritize_files()</span></tt>. The file priorities specified
in here take precedence over those specified in the resume data, if
any.
If this vector of file priorities is shorter than the number of files
in the torrent, the remaining files (not covered by this) will still
have the default download priority. This default can be changed by
setting the default_dont_download torrent_flag.</dd>
</dl>
<a name="trackerid"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Btrackerid%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Btrackerid%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>trackerid</dt>
<dd>the default tracker id to be used when announcing to trackers. By
default this is empty, and no tracker ID is used, since this is an
optional argument. If a tracker returns a tracker ID, that ID is used
instead of this.</dd>
</dl>
<a name="flags"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Bflags%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Bflags%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>flags</dt>
<dd><p class="first">flags controlling aspects of this torrent and how it's added. See
<a class="reference external" href="reference-Core.html#torrent_flags_t">torrent_flags_t</a> for details.</p>
<div class="admonition note last">
<p class="first admonition-title">Note</p>
<p class="last">The <tt class="docutils literal">flags</tt> field is initialized with default flags by the
constructor. In order to preserve default behavior when clearing or
setting other flags, make sure to bitwise OR or in a flag or bitwise
AND the inverse of a flag to clear it.</p>
</div>
</dd>
</dl>
<a name="info_hashes"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Binfo_hashes%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Binfo_hashes%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>info_hashes</dt>
<dd>set this to the info hash of the torrent to add in case the info-hash
is the only known property of the torrent. i.e. you don't have a
.torrent file nor a magnet link.
To add a magnet link, use <a class="reference external" href="reference-Core.html#parse_magnet_uri()">parse_magnet_uri()</a> to populate fields in the
<a class="reference external" href="reference-Add_Torrent.html#add_torrent_params">add_torrent_params</a> object.</dd>
</dl>
<a name="max_uploads"></a>
<a name="max_connections"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Bmax_uploads+max_connections%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Bmax_uploads+max_connections%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>max_uploads max_connections</dt>
<dd><p class="first"><tt class="docutils literal">max_uploads</tt>, <tt class="docutils literal">max_connections</tt>, <tt class="docutils literal">upload_limit</tt>,
<tt class="docutils literal">download_limit</tt> correspond to the <tt class="docutils literal">set_max_uploads()</tt>,
<tt class="docutils literal">set_max_connections()</tt>, <tt class="docutils literal">set_upload_limit()</tt> and
<tt class="docutils literal">set_download_limit()</tt> functions on <a class="reference external" href="reference-Torrent_Handle.html#torrent_handle">torrent_handle</a>. These values let
you initialize these settings when the torrent is added, instead of
calling these functions immediately following adding it.</p>
<p>-1 means unlimited on these settings just like their counterpart
functions on <a class="reference external" href="reference-Torrent_Handle.html#torrent_handle">torrent_handle</a></p>
<p class="last">For fine grained control over rate limits, including making them apply
to local peers, see <a class="reference external" href="manual-ref.html#peer-classes">peer classes</a>.</p>
</dd>
</dl>
<a name="upload_limit"></a>
<a name="download_limit"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Bupload_limit+download_limit%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Bupload_limit+download_limit%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>upload_limit download_limit</dt>
<dd>the upload and download rate limits for this torrent, specified in
bytes per second. -1 means unlimited.</dd>
</dl>
<a name="total_uploaded"></a>
<a name="total_downloaded"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Btotal_uploaded+total_downloaded%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Btotal_uploaded+total_downloaded%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>total_uploaded total_downloaded</dt>
<dd>the total number of bytes uploaded and downloaded by this torrent so
far.</dd>
</dl>
<a name="active_time"></a>
<a name="finished_time"></a>
<a name="seeding_time"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Bactive_time+finished_time+seeding_time%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Bactive_time+finished_time+seeding_time%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>active_time finished_time seeding_time</dt>
<dd>the number of seconds this torrent has spent in started, finished and
seeding state so far, respectively.</dd>
</dl>
<a name="added_time"></a>
<a name="completed_time"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Badded_time+completed_time%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Badded_time+completed_time%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>added_time completed_time</dt>
<dd>if set to a non-zero value, this is the posix time of when this torrent
was first added, including previous runs/sessions. If set to zero, the
internal added_time will be set to the time of when <a class="reference external" href="reference-Session.html#add_torrent()">add_torrent()</a> is
called.</dd>
</dl>
<a name="last_seen_complete"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Blast_seen_complete%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Blast_seen_complete%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>last_seen_complete</dt>
<dd>if set to non-zero, initializes the time (expressed in posix time) when
we last saw a seed or peers that together formed a complete copy of the
torrent. If left set to zero, the internal counterpart to this field
will be updated when we see a seed or a distributed copies &gt;= 1.0.</dd>
</dl>
<a name="num_complete"></a>
<a name="num_incomplete"></a>
<a name="num_downloaded"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Bnum_complete+num_incomplete+num_downloaded%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Bnum_complete+num_incomplete+num_downloaded%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>num_complete num_incomplete num_downloaded</dt>
<dd><p class="first">these field can be used to initialize the torrent's cached scrape data.
The scrape data is high level metadata about the current state of the
swarm, as returned by the tracker (either when announcing to it or by
sending a specific scrape request). <tt class="docutils literal">num_complete</tt> is the number of
peers in the swarm that are seeds, or have every piece in the torrent.
<tt class="docutils literal">num_incomplete</tt> is the number of peers in the swarm that do not have
every piece. <tt class="docutils literal">num_downloaded</tt> is the number of times the torrent has
been downloaded (not initiated, but the number of times a download has
completed).</p>
<p class="last">Leaving any of these values set to -1 indicates we don't know, or we
have not received any scrape data.</p>
</dd>
</dl>
<a name="http_seeds"></a>
<a name="url_seeds"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Bhttp_seeds+url_seeds%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Bhttp_seeds+url_seeds%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>http_seeds url_seeds</dt>
<dd><p class="first">URLs can be added to these two lists to specify additional web
seeds to be used by the torrent. If the <tt class="docutils literal">flag_override_web_seeds</tt>
is set, these will be the _only_ ones to be used. i.e. any web seeds
found in the .torrent file will be overridden.</p>
<p>http_seeds expects URLs to web servers implementing the original HTTP
seed specification <a class="reference external" href="https://www.bittorrent.org/beps/bep_0017.html">BEP 17</a>.</p>
<p class="last">url_seeds expects URLs to regular web servers, aka &quot;get right&quot; style,
specified in <a class="reference external" href="https://www.bittorrent.org/beps/bep_0019.html">BEP 19</a>.</p>
</dd>
</dl>
<a name="peers"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Bpeers%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Bpeers%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>peers</dt>
<dd>peers to add to the torrent, to be tried to be connected to as
bittorrent peers.</dd>
</dl>
<a name="banned_peers"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Bbanned_peers%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Bbanned_peers%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>banned_peers</dt>
<dd>peers banned from this torrent. The will not be connected to</dd>
</dl>
<a name="unfinished_pieces"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Bunfinished_pieces%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Bunfinished_pieces%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>unfinished_pieces</dt>
<dd>this is a map of partially downloaded piece. The key is the piece index
and the value is a <a class="reference external" href="reference-Utility.html#bitfield">bitfield</a> where each bit represents a 16 kiB block.
A set bit means we have that block.</dd>
</dl>
<a name="have_pieces"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Bhave_pieces%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Bhave_pieces%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>have_pieces</dt>
<dd>this is a <a class="reference external" href="reference-Utility.html#bitfield">bitfield</a> indicating which pieces we already have of this
torrent.</dd>
</dl>
<a name="verified_pieces"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Bverified_pieces%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Bverified_pieces%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>verified_pieces</dt>
<dd>when in seed_mode, pieces with a set bit in this <a class="reference external" href="reference-Utility.html#bitfield">bitfield</a> have been
verified to be valid. Other pieces will be verified the first time a
peer requests it.</dd>
</dl>
<a name="piece_priorities"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Bpiece_priorities%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Bpiece_priorities%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>piece_priorities</dt>
<dd>this sets the priorities for each individual piece in the torrent. Each
element in the vector represent the piece with the same index. If you
set both file- and piece priorities, file priorities will take
precedence.</dd>
</dl>
<a name="merkle_trees"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Bmerkle_trees%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Bmerkle_trees%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>merkle_trees</dt>
<dd>v2 hashes, if known</dd>
</dl>
<a name="merkle_tree_mask"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Bmerkle_tree_mask%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Bmerkle_tree_mask%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>merkle_tree_mask</dt>
<dd>if set, indicates which hashes are included in the corresponding
vector of <tt class="docutils literal">merkle_trees</tt>. These bitmasks always cover the full
tree, a cleared bit means the hash is all zeros (i.e. not set) and
set bit means the next hash in the corresponding vector in
<tt class="docutils literal">merkle_trees</tt> is the hash for that node. This is an optimization
to avoid storing a lot of zeros.</dd>
</dl>
<a name="verified_leaf_hashes"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Bverified_leaf_hashes%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Bverified_leaf_hashes%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>verified_leaf_hashes</dt>
<dd>bit-fields indicating which v2 leaf hashes have been verified
against the root hash. If this vector is empty and merkle_trees is
non-empty it implies that all hashes in merkle_trees are verified.</dd>
</dl>
<a name="renamed_files"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Brenamed_files%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Brenamed_files%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>renamed_files</dt>
<dd>this is a map of file indices in the torrent and new filenames to be
applied before the torrent is added.</dd>
</dl>
<a name="last_download"></a>
<a name="last_upload"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Blast_download+last_upload%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Blast_download+last_upload%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>last_download last_upload</dt>
<dd>the posix time of the last time payload was received or sent for this
torrent, respectively. A value of 0 means we don't know when we last
uploaded or downloaded, or we have never uploaded or downloaded any
payload for this torrent.</dd>
</dl>
<a name="storage_error"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+storage_error&labels=documentation&body=Documentation+under+heading+%22class+storage_error%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="storage-error">
<h1>storage_error</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/error_code.hpp">libtorrent/error_code.hpp</a>&quot;</p>
<p>used by storage to return errors
also includes which underlying file the
error happened on</p>
<pre class="literal-block">
struct storage_error
{
   explicit operator <strong>bool</strong> () const;
   void <strong>file</strong> (file_index_t f);
   file_index_t <strong>file</strong> () const;

   error_code ec;
   operation_t operation;
};
</pre>
<a name="bool()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:storage_error%3A%3A%5Bbool%28%29%5D&labels=documentation&body=Documentation+under+heading+%22storage_error%3A%3A%5Bbool%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="bool-2">
<h2>bool()</h2>
<pre class="literal-block">
explicit operator <strong>bool</strong> () const;
</pre>
<p>explicitly converts to true if this object represents an error, and
false if it does not.</p>
<a name="file()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:storage_error%3A%3A%5Bfile%28%29%5D&labels=documentation&body=Documentation+under+heading+%22storage_error%3A%3A%5Bfile%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="file">
<h2>file()</h2>
<pre class="literal-block">
void <strong>file</strong> (file_index_t f);
file_index_t <strong>file</strong> () const;
</pre>
<p>set and query the index (in the torrent) of the file this error
occurred on. This may also have special values defined in
<a class="reference external" href="reference-Torrent_Status.html#torrent_status">torrent_status</a>.</p>
<a name="ec"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:storage_error%3A%3A%5Bec%5D&labels=documentation&body=Documentation+under+heading+%22storage_error%3A%3A%5Bec%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>ec</dt>
<dd>the error that occurred</dd>
</dl>
<a name="operation"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:storage_error%3A%3A%5Boperation%5D&labels=documentation&body=Documentation+under+heading+%22storage_error%3A%3A%5Boperation%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>operation</dt>
<dd>A code from <a class="reference external" href="reference-Alerts.html#operation_t">operation_t</a> enum, indicating what
kind of operation failed.</dd>
</dl>
<a name="gzip_category()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:gzip_category%28%29&labels=documentation&body=Documentation+under+heading+%22gzip_category%28%29%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="gzip-category">
<h1>gzip_category()</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/gzip.hpp">libtorrent/gzip.hpp</a>&quot;</p>
<pre class="literal-block">
boost::system::error_category&amp; <strong>gzip_category</strong> ();
</pre>
<p>get the <tt class="docutils literal">error_category</tt> for zip errors</p>
<a name="pcp_category()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:pcp_category%28%29&labels=documentation&body=Documentation+under+heading+%22pcp_category%28%29%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="pcp-category">
<h1>pcp_category()</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/natpmp.hpp">libtorrent/natpmp.hpp</a>&quot;</p>
<pre class="literal-block">
boost::system::error_category&amp; <strong>pcp_category</strong> ();
</pre>
<a name="bdecode_category()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:bdecode_category%28%29&labels=documentation&body=Documentation+under+heading+%22bdecode_category%28%29%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="bdecode-category">
<h1>bdecode_category()</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/bdecode.hpp">libtorrent/bdecode.hpp</a>&quot;</p>
<pre class="literal-block">
boost::system::error_category&amp; <strong>bdecode_category</strong> ();
</pre>
<a name="libtorrent_category()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:libtorrent_category%28%29&labels=documentation&body=Documentation+under+heading+%22libtorrent_category%28%29%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="libtorrent-category">
<h1>libtorrent_category()</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/error_code.hpp">libtorrent/error_code.hpp</a>&quot;</p>
<pre class="literal-block">
boost::system::error_category&amp; <strong>libtorrent_category</strong> ();
</pre>
<p>return the instance of the libtorrent_error_category which
maps libtorrent error codes to human readable error messages.</p>
<a name="http_category()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:http_category%28%29&labels=documentation&body=Documentation+under+heading+%22http_category%28%29%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="http-category">
<h1>http_category()</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/error_code.hpp">libtorrent/error_code.hpp</a>&quot;</p>
<pre class="literal-block">
boost::system::error_category&amp; <strong>http_category</strong> ();
</pre>
<p>returns the error_category for HTTP errors</p>
<a name="i2p_category()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:i2p_category%28%29&labels=documentation&body=Documentation+under+heading+%22i2p_category%28%29%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="i2p-category">
<h1>i2p_category()</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/i2p_stream.hpp">libtorrent/i2p_stream.hpp</a>&quot;</p>
<pre class="literal-block">
boost::system::error_category&amp; <strong>i2p_category</strong> ();
</pre>
<p>returns the error category for I2P errors</p>
<a name="socks_category()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:socks_category%28%29&labels=documentation&body=Documentation+under+heading+%22socks_category%28%29%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="socks-category">
<h1>socks_category()</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/socks5_stream.hpp">libtorrent/socks5_stream.hpp</a>&quot;</p>
<pre class="literal-block">
boost::system::error_category&amp; <strong>socks_category</strong> ();
</pre>
<p>returns the error_category for SOCKS5 errors</p>
<a name="upnp_category()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:upnp_category%28%29&labels=documentation&body=Documentation+under+heading+%22upnp_category%28%29%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="upnp-category">
<h1>upnp_category()</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/upnp.hpp">libtorrent/upnp.hpp</a>&quot;</p>
<pre class="literal-block">
boost::system::error_category&amp; <strong>upnp_category</strong> ();
</pre>
<p>the boost.system error category for UPnP errors</p>
<a name="error_code_enum"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+error_code_enum&labels=documentation&body=Documentation+under+heading+%22enum+error_code_enum%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-error-code-enum">
<h1>enum error_code_enum</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/gzip.hpp">libtorrent/gzip.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="6%" />
<col width="61%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>no_error</td>
<td>0</td>
<td>Not an error</td>
</tr>
<tr><td>invalid_gzip_header</td>
<td>1</td>
<td>the supplied gzip buffer has invalid header</td>
</tr>
<tr><td>inflated_data_too_large</td>
<td>2</td>
<td>the gzip buffer would inflate to more bytes than the specified
maximum size, and was rejected.</td>
</tr>
<tr><td>data_did_not_terminate</td>
<td>3</td>
<td>available inflate data did not terminate</td>
</tr>
<tr><td>space_exhausted</td>
<td>4</td>
<td>output space exhausted before completing inflate</td>
</tr>
<tr><td>invalid_block_type</td>
<td>5</td>
<td>invalid block type (type == 3)</td>
</tr>
<tr><td>invalid_stored_block_length</td>
<td>6</td>
<td>stored block length did not match one's complement</td>
</tr>
<tr><td>too_many_length_or_distance_codes</td>
<td>7</td>
<td>dynamic block code description: too many length or distance codes</td>
</tr>
<tr><td>code_lengths_codes_incomplete</td>
<td>8</td>
<td>dynamic block code description: code lengths codes incomplete</td>
</tr>
<tr><td>repeat_lengths_with_no_first_length</td>
<td>9</td>
<td>dynamic block code description: repeat lengths with no first length</td>
</tr>
<tr><td>repeat_more_than_specified_lengths</td>
<td>10</td>
<td>dynamic block code description: repeat more than specified lengths</td>
</tr>
<tr><td>invalid_literal_length_code_lengths</td>
<td>11</td>
<td>dynamic block code description: invalid literal/length code lengths</td>
</tr>
<tr><td>invalid_distance_code_lengths</td>
<td>12</td>
<td>dynamic block code description: invalid distance code lengths</td>
</tr>
<tr><td>invalid_literal_code_in_block</td>
<td>13</td>
<td>invalid literal/length or distance code in fixed or dynamic block</td>
</tr>
<tr><td>distance_too_far_back_in_block</td>
<td>14</td>
<td>distance is too far back in fixed or dynamic block</td>
</tr>
<tr><td>unknown_gzip_error</td>
<td>15</td>
<td>an unknown error occurred during gzip inflation</td>
</tr>
<tr><td>error_code_max</td>
<td>16</td>
<td>the number of error codes</td>
</tr>
</tbody>
</table>
<a name="pcp_errors"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+pcp_errors&labels=documentation&body=Documentation+under+heading+%22enum+pcp_errors%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-pcp-errors">
<h1>enum pcp_errors</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/natpmp.hpp">libtorrent/natpmp.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="59%" />
<col width="14%" />
<col width="27%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>pcp_success</td>
<td>0</td>
<td>&nbsp;</td>
</tr>
<tr><td>pcp_unsupp_version</td>
<td>1</td>
<td>&nbsp;</td>
</tr>
<tr><td>pcp_not_authorized</td>
<td>2</td>
<td>&nbsp;</td>
</tr>
<tr><td>pcp_malformed_request</td>
<td>3</td>
<td>&nbsp;</td>
</tr>
<tr><td>pcp_unsupp_opcode</td>
<td>4</td>
<td>&nbsp;</td>
</tr>
<tr><td>pcp_unsupp_option</td>
<td>5</td>
<td>&nbsp;</td>
</tr>
<tr><td>pcp_malformed_option</td>
<td>6</td>
<td>&nbsp;</td>
</tr>
<tr><td>pcp_network_failure</td>
<td>7</td>
<td>&nbsp;</td>
</tr>
<tr><td>pcp_no_resources</td>
<td>8</td>
<td>&nbsp;</td>
</tr>
<tr><td>pcp_unsupp_protocol</td>
<td>9</td>
<td>&nbsp;</td>
</tr>
<tr><td>pcp_user_ex_quota</td>
<td>10</td>
<td>&nbsp;</td>
</tr>
<tr><td>pcp_cannot_provide_external</td>
<td>11</td>
<td>&nbsp;</td>
</tr>
<tr><td>pcp_address_mismatch</td>
<td>12</td>
<td>&nbsp;</td>
</tr>
<tr><td>pcp_excessive_remote_peers</td>
<td>13</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<a name="error_code_enum"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+error_code_enum&labels=documentation&body=Documentation+under+heading+%22enum+error_code_enum%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-error-code-enum-1">
<h1>enum error_code_enum</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/bdecode.hpp">libtorrent/bdecode.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="18%" />
<col width="8%" />
<col width="74%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>no_error</td>
<td>0</td>
<td>Not an error</td>
</tr>
<tr><td>expected_digit</td>
<td>1</td>
<td>expected digit in bencoded string</td>
</tr>
<tr><td>expected_colon</td>
<td>2</td>
<td>expected colon in bencoded string</td>
</tr>
<tr><td>unexpected_eof</td>
<td>3</td>
<td>unexpected end of file in bencoded string</td>
</tr>
<tr><td>expected_value</td>
<td>4</td>
<td>expected value (list, dict, <a class="reference external" href="reference-Core.html#int">int</a> or string) in bencoded string</td>
</tr>
<tr><td>depth_exceeded</td>
<td>5</td>
<td>bencoded recursion depth limit exceeded</td>
</tr>
<tr><td>limit_exceeded</td>
<td>6</td>
<td>bencoded item count limit exceeded</td>
</tr>
<tr><td>overflow</td>
<td>7</td>
<td>integer overflow</td>
</tr>
<tr><td>error_code_max</td>
<td>8</td>
<td>the number of error codes</td>
</tr>
</tbody>
</table>
<a name="error_code_enum"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+error_code_enum&labels=documentation&body=Documentation+under+heading+%22enum+error_code_enum%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-error-code-enum-2">
<h1>enum error_code_enum</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/error_code.hpp">libtorrent/error_code.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="6%" />
<col width="63%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>no_error</td>
<td>0</td>
<td>Not an error</td>
</tr>
<tr><td>file_collision</td>
<td>1</td>
<td>Two torrents has files which end up overwriting each other</td>
</tr>
<tr><td>failed_hash_check</td>
<td>2</td>
<td>A piece did not match its piece hash</td>
</tr>
<tr><td>torrent_is_no_dict</td>
<td>3</td>
<td>The .torrent file does not contain a bencoded dictionary at
its top level</td>
</tr>
<tr><td>torrent_missing_info</td>
<td>4</td>
<td>The .torrent file does not have an <tt class="docutils literal">info</tt> dictionary</td>
</tr>
<tr><td>torrent_info_no_dict</td>
<td>5</td>
<td>The .torrent file's <tt class="docutils literal">info</tt> <a class="reference external" href="reference-Bencoding.html#entry">entry</a> is not a dictionary</td>
</tr>
<tr><td>torrent_missing_piece_length</td>
<td>6</td>
<td>The .torrent file does not have a <tt class="docutils literal">piece length</tt> <a class="reference external" href="reference-Bencoding.html#entry">entry</a></td>
</tr>
<tr><td>torrent_missing_name</td>
<td>7</td>
<td>The .torrent file does not have a <tt class="docutils literal">name</tt> <a class="reference external" href="reference-Bencoding.html#entry">entry</a></td>
</tr>
<tr><td>torrent_invalid_name</td>
<td>8</td>
<td>The .torrent file's name <a class="reference external" href="reference-Bencoding.html#entry">entry</a> is invalid</td>
</tr>
<tr><td>torrent_invalid_length</td>
<td>9</td>
<td>The length of a file, or of the whole .torrent file is invalid.
Either negative or not an integer</td>
</tr>
<tr><td>torrent_file_parse_failed</td>
<td>10</td>
<td>Failed to parse a file <a class="reference external" href="reference-Bencoding.html#entry">entry</a> in the .torrent</td>
</tr>
<tr><td>torrent_missing_pieces</td>
<td>11</td>
<td>The <tt class="docutils literal">pieces</tt> field is missing or invalid in the .torrent file</td>
</tr>
<tr><td>torrent_invalid_hashes</td>
<td>12</td>
<td>The <tt class="docutils literal">pieces</tt> string has incorrect length</td>
</tr>
<tr><td>too_many_pieces_in_torrent</td>
<td>13</td>
<td>The .torrent file has more pieces than is supported by libtorrent</td>
</tr>
<tr><td>invalid_swarm_metadata</td>
<td>14</td>
<td>The metadata (.torrent file) that was received from the swarm
matched the info-hash, but failed to be parsed</td>
</tr>
<tr><td>invalid_bencoding</td>
<td>15</td>
<td>The file or buffer is not correctly bencoded</td>
</tr>
<tr><td>no_files_in_torrent</td>
<td>16</td>
<td>The .torrent file does not contain any files</td>
</tr>
<tr><td>invalid_escaped_string</td>
<td>17</td>
<td>The string was not properly url-encoded as expected</td>
</tr>
<tr><td>session_is_closing</td>
<td>18</td>
<td>Operation is not permitted since the <a class="reference external" href="reference-Session.html#session">session</a> is shutting down</td>
</tr>
<tr><td>duplicate_torrent</td>
<td>19</td>
<td>There's already a torrent with that info-hash added to the
<a class="reference external" href="reference-Session.html#session">session</a></td>
</tr>
<tr><td>invalid_torrent_handle</td>
<td>20</td>
<td>The supplied <a class="reference external" href="reference-Torrent_Handle.html#torrent_handle">torrent_handle</a> is not referring to a valid torrent</td>
</tr>
<tr><td>invalid_entry_type</td>
<td>21</td>
<td>The type requested from the <a class="reference external" href="reference-Bencoding.html#entry">entry</a> did not match its type</td>
</tr>
<tr><td>missing_info_hash_in_uri</td>
<td>22</td>
<td>The specified URI does not contain a valid info-hash</td>
</tr>
<tr><td>file_too_short</td>
<td>23</td>
<td>One of the files in the torrent was unexpectedly small. This
might be caused by files being changed by an external process</td>
</tr>
<tr><td>unsupported_url_protocol</td>
<td>24</td>
<td>The URL used an unknown protocol. Currently <tt class="docutils literal">http</tt> and
<tt class="docutils literal">https</tt> (if built with openssl support) are recognized. For
trackers <tt class="docutils literal">udp</tt> is recognized as well.</td>
</tr>
<tr><td>url_parse_error</td>
<td>25</td>
<td>The URL did not conform to URL syntax and failed to be parsed</td>
</tr>
<tr><td>peer_sent_empty_piece</td>
<td>26</td>
<td>The peer sent a piece message of length 0</td>
</tr>
<tr><td>parse_failed</td>
<td>27</td>
<td>A bencoded structure was corrupt and failed to be parsed</td>
</tr>
<tr><td>invalid_file_tag</td>
<td>28</td>
<td>The fast resume file was missing or had an invalid file version
tag</td>
</tr>
<tr><td>missing_info_hash</td>
<td>29</td>
<td>The fast resume file was missing or had an invalid info-hash</td>
</tr>
<tr><td>mismatching_info_hash</td>
<td>30</td>
<td>The info-hash did not match the torrent</td>
</tr>
<tr><td>invalid_hostname</td>
<td>31</td>
<td>The URL contained an invalid hostname</td>
</tr>
<tr><td>invalid_port</td>
<td>32</td>
<td>The URL had an invalid port</td>
</tr>
<tr><td>port_blocked</td>
<td>33</td>
<td>The port is blocked by the port-filter, and prevented the
connection</td>
</tr>
<tr><td>expected_close_bracket_in_address</td>
<td>34</td>
<td>The IPv6 address was expected to end with &quot;]&quot;</td>
</tr>
<tr><td>destructing_torrent</td>
<td>35</td>
<td>The torrent is being destructed, preventing the operation to
succeed</td>
</tr>
<tr><td>timed_out</td>
<td>36</td>
<td>The connection timed out</td>
</tr>
<tr><td>upload_upload_connection</td>
<td>37</td>
<td>The peer is upload only, and we are upload only. There's no point
in keeping the connection</td>
</tr>
<tr><td>uninteresting_upload_peer</td>
<td>38</td>
<td>The peer is upload only, and we're not interested in it. There's
no point in keeping the connection</td>
</tr>
<tr><td>invalid_info_hash</td>
<td>39</td>
<td>The peer sent an unknown info-hash</td>
</tr>
<tr><td>torrent_paused</td>
<td>40</td>
<td>The torrent is paused, preventing the operation from succeeding</td>
</tr>
<tr><td>invalid_have</td>
<td>41</td>
<td>The peer sent an invalid have message, either wrong size or
referring to a piece that doesn't exist in the torrent</td>
</tr>
<tr><td>invalid_bitfield_size</td>
<td>42</td>
<td>The <a class="reference external" href="reference-Utility.html#bitfield">bitfield</a> message had the incorrect size</td>
</tr>
<tr><td>too_many_requests_when_choked</td>
<td>43</td>
<td>The peer kept requesting pieces after it was choked, possible
abuse attempt.</td>
</tr>
<tr><td>invalid_piece</td>
<td>44</td>
<td>The peer sent a piece message that does not correspond to a
piece request sent by the client</td>
</tr>
<tr><td>no_memory</td>
<td>45</td>
<td>memory allocation failed</td>
</tr>
<tr><td>torrent_aborted</td>
<td>46</td>
<td>The torrent is aborted, preventing the operation to succeed</td>
</tr>
<tr><td>self_connection</td>
<td>47</td>
<td>The peer is a connection to ourself, no point in keeping it</td>
</tr>
<tr><td>invalid_piece_size</td>
<td>48</td>
<td>The peer sent a piece message with invalid size, either negative
or greater than one block</td>
</tr>
<tr><td>timed_out_no_interest</td>
<td>49</td>
<td>The peer has not been interesting or interested in us for too
long, no point in keeping it around</td>
</tr>
<tr><td>timed_out_inactivity</td>
<td>50</td>
<td>The peer has not said anything in a long time, possibly dead</td>
</tr>
<tr><td>timed_out_no_handshake</td>
<td>51</td>
<td>The peer did not send a handshake within a reasonable amount of
time, it might not be a bittorrent peer</td>
</tr>
<tr><td>timed_out_no_request</td>
<td>52</td>
<td>The peer has been unchoked for too long without requesting any
data. It might be lying about its interest in us</td>
</tr>
<tr><td>invalid_choke</td>
<td>53</td>
<td>The peer sent an invalid choke message</td>
</tr>
<tr><td>invalid_unchoke</td>
<td>54</td>
<td>The peer send an invalid unchoke message</td>
</tr>
<tr><td>invalid_interested</td>
<td>55</td>
<td>The peer sent an invalid interested message</td>
</tr>
<tr><td>invalid_not_interested</td>
<td>56</td>
<td>The peer sent an invalid not-interested message</td>
</tr>
<tr><td>invalid_request</td>
<td>57</td>
<td>The peer sent an invalid piece request message</td>
</tr>
<tr><td>invalid_hash_list</td>
<td>58</td>
<td>The peer sent an invalid hash-list message (this is part of the
merkle-torrent extension)</td>
</tr>
<tr><td>invalid_hash_piece</td>
<td>59</td>
<td>The peer sent an invalid hash-piece message (this is part of the
merkle-torrent extension)</td>
</tr>
<tr><td>invalid_cancel</td>
<td>60</td>
<td>The peer sent an invalid cancel message</td>
</tr>
<tr><td>invalid_dht_port</td>
<td>61</td>
<td>The peer sent an invalid DHT port-message</td>
</tr>
<tr><td>invalid_suggest</td>
<td>62</td>
<td>The peer sent an invalid suggest piece-message</td>
</tr>
<tr><td>invalid_have_all</td>
<td>63</td>
<td>The peer sent an invalid have all-message</td>
</tr>
<tr><td>invalid_have_none</td>
<td>64</td>
<td>The peer sent an invalid have none-message</td>
</tr>
<tr><td>invalid_reject</td>
<td>65</td>
<td>The peer sent an invalid reject message</td>
</tr>
<tr><td>invalid_allow_fast</td>
<td>66</td>
<td>The peer sent an invalid allow fast-message</td>
</tr>
<tr><td>invalid_extended</td>
<td>67</td>
<td>The peer sent an invalid extension message ID</td>
</tr>
<tr><td>invalid_message</td>
<td>68</td>
<td>The peer sent an invalid message ID</td>
</tr>
<tr><td>sync_hash_not_found</td>
<td>69</td>
<td>The synchronization hash was not found in the encrypted handshake</td>
</tr>
<tr><td>invalid_encryption_constant</td>
<td>70</td>
<td>The encryption constant in the handshake is invalid</td>
</tr>
<tr><td>no_plaintext_mode</td>
<td>71</td>
<td>The peer does not support plain text, which is the selected mode</td>
</tr>
<tr><td>no_rc4_mode</td>
<td>72</td>
<td>The peer does not support RC4, which is the selected mode</td>
</tr>
<tr><td>unsupported_encryption_mode</td>
<td>73</td>
<td>The peer does not support any of the encryption modes that the
client supports</td>
</tr>
<tr><td>unsupported_encryption_mode_selected</td>
<td>74</td>
<td>The peer selected an encryption mode that the client did not
advertise and does not support</td>
</tr>
<tr><td>invalid_pad_size</td>
<td>75</td>
<td>The pad size used in the encryption handshake is of invalid size</td>
</tr>
<tr><td>invalid_encrypt_handshake</td>
<td>76</td>
<td>The encryption handshake is invalid</td>
</tr>
<tr><td>no_incoming_encrypted</td>
<td>77</td>
<td>The client is set to not support incoming encrypted connections
and this is an encrypted connection</td>
</tr>
<tr><td>no_incoming_regular</td>
<td>78</td>
<td>The client is set to not support incoming regular bittorrent
connections, and this is a regular connection</td>
</tr>
<tr><td>duplicate_peer_id</td>
<td>79</td>
<td>The client is already connected to this peer-ID</td>
</tr>
<tr><td>torrent_removed</td>
<td>80</td>
<td>Torrent was removed</td>
</tr>
<tr><td>packet_too_large</td>
<td>81</td>
<td>The packet size exceeded the upper sanity check-limit</td>
</tr>
<tr><td>reserved</td>
<td>82</td>
<td>&nbsp;</td>
</tr>
<tr><td>http_error</td>
<td>83</td>
<td>The web server responded with an error</td>
</tr>
<tr><td>missing_location</td>
<td>84</td>
<td>The web server response is missing a location header</td>
</tr>
<tr><td>invalid_redirection</td>
<td>85</td>
<td>The web seed redirected to a path that no longer matches the
.torrent directory structure</td>
</tr>
<tr><td>redirecting</td>
<td>86</td>
<td>The connection was closed because it redirected to a different
URL</td>
</tr>
<tr><td>invalid_range</td>
<td>87</td>
<td>The HTTP range header is invalid</td>
</tr>
<tr><td>no_content_length</td>
<td>88</td>
<td>The HTTP response did not have a content length</td>
</tr>
<tr><td>banned_by_ip_filter</td>
<td>89</td>
<td>The IP is blocked by the IP filter</td>
</tr>
<tr><td>too_many_connections</td>
<td>90</td>
<td>At the connection limit</td>
</tr>
<tr><td>peer_banned</td>
<td>91</td>
<td>The peer is marked as banned</td>
</tr>
<tr><td>stopping_torrent</td>
<td>92</td>
<td>The torrent is stopping, causing the operation to fail</td>
</tr>
<tr><td>too_many_corrupt_pieces</td>
<td>93</td>
<td>The peer has sent too many corrupt pieces and is banned</td>
</tr>
<tr><td>torrent_not_ready</td>
<td>94</td>
<td>The torrent is not ready to receive peers</td>
</tr>
<tr><td>peer_not_constructed</td>
<td>95</td>
<td>The peer is not completely constructed yet</td>
</tr>
<tr><td>session_closing</td>
<td>96</td>
<td>The <a class="reference external" href="reference-Session.html#session">session</a> is closing, causing the operation to fail</td>
</tr>
<tr><td>optimistic_disconnect</td>
<td>97</td>
<td>The peer was disconnected in order to leave room for a
potentially better peer</td>
</tr>
<tr><td>torrent_finished</td>
<td>98</td>
<td>The torrent is finished</td>
</tr>
<tr><td>no_router</td>
<td>99</td>
<td>No UPnP router found</td>
</tr>
<tr><td>metadata_too_large</td>
<td>100</td>
<td>The metadata message says the metadata exceeds the limit</td>
</tr>
<tr><td>invalid_metadata_request</td>
<td>101</td>
<td>The peer sent an invalid metadata request message</td>
</tr>
<tr><td>invalid_metadata_size</td>
<td>102</td>
<td>The peer advertised an invalid metadata size</td>
</tr>
<tr><td>invalid_metadata_offset</td>
<td>103</td>
<td>The peer sent a message with an invalid metadata offset</td>
</tr>
<tr><td>invalid_metadata_message</td>
<td>104</td>
<td>The peer sent an invalid metadata message</td>
</tr>
<tr><td>pex_message_too_large</td>
<td>105</td>
<td>The peer sent a peer exchange message that was too large</td>
</tr>
<tr><td>invalid_pex_message</td>
<td>106</td>
<td>The peer sent an invalid peer exchange message</td>
</tr>
<tr><td>invalid_lt_tracker_message</td>
<td>107</td>
<td>The peer sent an invalid tracker exchange message</td>
</tr>
<tr><td>too_frequent_pex</td>
<td>108</td>
<td>The peer sent an pex messages too often. This is a possible
attempt of and attack</td>
</tr>
<tr><td>no_metadata</td>
<td>109</td>
<td>The operation failed because it requires the torrent to have
the metadata (.torrent file) and it doesn't have it yet.
This happens for magnet links before they have downloaded the
metadata, and also torrents added by URL.</td>
</tr>
<tr><td>invalid_dont_have</td>
<td>110</td>
<td>The peer sent an invalid <tt class="docutils literal">dont_have</tt> message. The don't have
message is an extension to allow peers to advertise that the
no longer has a piece they previously had.</td>
</tr>
<tr><td>requires_ssl_connection</td>
<td>111</td>
<td>The peer tried to connect to an SSL torrent without connecting
over SSL.</td>
</tr>
<tr><td>invalid_ssl_cert</td>
<td>112</td>
<td>The peer tried to connect to a torrent with a certificate
for a different torrent.</td>
</tr>
<tr><td>not_an_ssl_torrent</td>
<td>113</td>
<td>the torrent is not an SSL torrent, and the operation requires
an SSL torrent</td>
</tr>
<tr><td>banned_by_port_filter</td>
<td>114</td>
<td>peer was banned because its listen port is within a banned port
range, as specified by the <a class="reference external" href="reference-Filter.html#port_filter">port_filter</a>.</td>
</tr>
<tr><td>invalid_session_handle</td>
<td>115</td>
<td>The <a class="reference external" href="reference-Session.html#session_handle">session_handle</a> is not referring to a valid session_impl</td>
</tr>
<tr><td>invalid_listen_socket</td>
<td>116</td>
<td>the listen socket associated with this request was closed</td>
</tr>
<tr><td>invalid_hash_request</td>
<td>117</td>
<td>&nbsp;</td>
</tr>
<tr><td>invalid_hashes</td>
<td>118</td>
<td>&nbsp;</td>
</tr>
<tr><td>invalid_hash_reject</td>
<td>119</td>
<td>&nbsp;</td>
</tr>
<tr><td>deprecated_120</td>
<td>120</td>
<td>&nbsp;</td>
</tr>
<tr><td>deprecated_121</td>
<td>121</td>
<td>&nbsp;</td>
</tr>
<tr><td>deprecated_122</td>
<td>122</td>
<td>&nbsp;</td>
</tr>
<tr><td>deprecated_123</td>
<td>123</td>
<td>&nbsp;</td>
</tr>
<tr><td>deprecated_124</td>
<td>124</td>
<td>&nbsp;</td>
</tr>
<tr><td>missing_file_sizes</td>
<td>130</td>
<td>The resume data file is missing the <tt class="docutils literal">file sizes</tt> <a class="reference external" href="reference-Bencoding.html#entry">entry</a></td>
</tr>
<tr><td>no_files_in_resume_data</td>
<td>131</td>
<td>The resume data file <tt class="docutils literal">file sizes</tt> <a class="reference external" href="reference-Bencoding.html#entry">entry</a> is empty</td>
</tr>
<tr><td>missing_pieces</td>
<td>132</td>
<td>The resume data file is missing the <tt class="docutils literal">pieces</tt> and <tt class="docutils literal">slots</tt> <a class="reference external" href="reference-Bencoding.html#entry">entry</a></td>
</tr>
<tr><td>mismatching_number_of_files</td>
<td>133</td>
<td>The number of files in the resume data does not match the number
of files in the torrent</td>
</tr>
<tr><td>mismatching_file_size</td>
<td>134</td>
<td>One of the files on disk has a different size than in the fast
resume file</td>
</tr>
<tr><td>mismatching_file_timestamp</td>
<td>135</td>
<td>One of the files on disk has a different timestamp than in the
fast resume file</td>
</tr>
<tr><td>not_a_dictionary</td>
<td>136</td>
<td>The resume data file is not a dictionary</td>
</tr>
<tr><td>invalid_blocks_per_piece</td>
<td>137</td>
<td>The <tt class="docutils literal">blocks per piece</tt> <a class="reference external" href="reference-Bencoding.html#entry">entry</a> is invalid in the resume data file</td>
</tr>
<tr><td>missing_slots</td>
<td>138</td>
<td>The resume file is missing the <tt class="docutils literal">slots</tt> <a class="reference external" href="reference-Bencoding.html#entry">entry</a>, which is required
for torrents with compact allocation. <em>DEPRECATED</em></td>
</tr>
<tr><td>too_many_slots</td>
<td>139</td>
<td>The resume file contains more slots than the torrent</td>
</tr>
<tr><td>invalid_slot_list</td>
<td>140</td>
<td>The <tt class="docutils literal">slot</tt> <a class="reference external" href="reference-Bencoding.html#entry">entry</a> is invalid in the resume data</td>
</tr>
<tr><td>invalid_piece_index</td>
<td>141</td>
<td>One index in the <tt class="docutils literal">slot</tt> list is invalid</td>
</tr>
<tr><td>pieces_need_reorder</td>
<td>142</td>
<td>The pieces on disk needs to be re-ordered for the specified
allocation mode. This happens if you specify sparse allocation
and the files on disk are using compact storage. The pieces needs
to be moved to their right position. <em>DEPRECATED</em></td>
</tr>
<tr><td>resume_data_not_modified</td>
<td>143</td>
<td>this error is returned when asking to save resume data and
specifying the flag to only save when there's anything new to save
(<a class="reference external" href="reference-Torrent_Handle.html#only_if_modified">torrent_handle::only_if_modified</a>) and there wasn't anything changed.</td>
</tr>
<tr><td>invalid_save_path</td>
<td>144</td>
<td>the save_path in <a class="reference external" href="reference-Add_Torrent.html#add_torrent_params">add_torrent_params</a> is not valid</td>
</tr>
<tr><td>http_parse_error</td>
<td>150</td>
<td>The HTTP header was not correctly formatted</td>
</tr>
<tr><td>http_missing_location</td>
<td>151</td>
<td>The HTTP response was in the 300-399 range but lacked a location
header</td>
</tr>
<tr><td>http_failed_decompress</td>
<td>152</td>
<td>The HTTP response was encoded with gzip or deflate but
decompressing it failed</td>
</tr>
<tr><td>no_i2p_router</td>
<td>160</td>
<td>The URL specified an i2p address, but no i2p router is configured</td>
</tr>
<tr><td>no_i2p_endpoint</td>
<td>161</td>
<td>i2p acceptor is not available yet, can't announce without endpoint</td>
</tr>
<tr><td>scrape_not_available</td>
<td>170</td>
<td>The tracker URL doesn't support transforming it into a scrape
URL. i.e. it doesn't contain &quot;announce.</td>
</tr>
<tr><td>invalid_tracker_response</td>
<td>171</td>
<td>invalid tracker response</td>
</tr>
<tr><td>invalid_peer_dict</td>
<td>172</td>
<td>invalid peer dictionary <a class="reference external" href="reference-Bencoding.html#entry">entry</a>. Not a dictionary</td>
</tr>
<tr><td>tracker_failure</td>
<td>173</td>
<td>tracker sent a failure message</td>
</tr>
<tr><td>invalid_files_entry</td>
<td>174</td>
<td>missing or invalid <tt class="docutils literal">files</tt> <a class="reference external" href="reference-Bencoding.html#entry">entry</a></td>
</tr>
<tr><td>invalid_hash_entry</td>
<td>175</td>
<td>missing or invalid <tt class="docutils literal">hash</tt> <a class="reference external" href="reference-Bencoding.html#entry">entry</a></td>
</tr>
<tr><td>invalid_peers_entry</td>
<td>176</td>
<td>missing or invalid <tt class="docutils literal">peers</tt> and <tt class="docutils literal">peers6</tt> <a class="reference external" href="reference-Bencoding.html#entry">entry</a></td>
</tr>
<tr><td>invalid_tracker_response_length</td>
<td>177</td>
<td>UDP tracker response packet has invalid size</td>
</tr>
<tr><td>invalid_tracker_transaction_id</td>
<td>178</td>
<td>invalid transaction id in UDP tracker response</td>
</tr>
<tr><td>invalid_tracker_action</td>
<td>179</td>
<td>invalid action field in UDP tracker response</td>
</tr>
<tr><td>announce_skipped</td>
<td>180</td>
<td>skipped announce (because it's assumed to be unreachable over the
given source network interface)</td>
</tr>
<tr><td>no_entropy</td>
<td>200</td>
<td>random number generation failed</td>
</tr>
<tr><td>ssrf_mitigation</td>
<td>201</td>
<td>blocked by SSRF mitigation</td>
</tr>
<tr><td>blocked_by_idna</td>
<td>202</td>
<td>blocked because IDNA host names are banned</td>
</tr>
<tr><td>torrent_unknown_version</td>
<td>210</td>
<td>the torrent file has an unknown meta version</td>
</tr>
<tr><td>torrent_missing_file_tree</td>
<td>211</td>
<td>the v2 torrent file has no file tree</td>
</tr>
<tr><td>torrent_missing_meta_version</td>
<td>212</td>
<td>the torrent contains v2 keys but does not specify meta version 2</td>
</tr>
<tr><td>torrent_inconsistent_files</td>
<td>213</td>
<td>the v1 and v2 file metadata does not match</td>
</tr>
<tr><td>torrent_missing_piece_layer</td>
<td>214</td>
<td>one or more files are missing piece layer hashes</td>
</tr>
<tr><td>torrent_invalid_piece_layer</td>
<td>215</td>
<td>a piece layer has the wrong size or failed hash check</td>
</tr>
<tr><td>torrent_missing_pieces_root</td>
<td>216</td>
<td>a v2 file <a class="reference external" href="reference-Bencoding.html#entry">entry</a> has no root hash</td>
</tr>
<tr><td>torrent_inconsistent_hashes</td>
<td>217</td>
<td>the v1 and v2 hashes do not describe the same data</td>
</tr>
<tr><td>torrent_invalid_pad_file</td>
<td>218</td>
<td>a file in the v2 metadata has the pad attribute set</td>
</tr>
<tr><td>error_code_max</td>
<td>219</td>
<td>the number of error codes</td>
</tr>
</tbody>
</table>
<a name="http_errors"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+http_errors&labels=documentation&body=Documentation+under+heading+%22enum+http_errors%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-http-errors">
<h1>enum http_errors</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/error_code.hpp">libtorrent/error_code.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="53%" />
<col width="16%" />
<col width="30%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>cont</td>
<td>100</td>
<td>&nbsp;</td>
</tr>
<tr><td>ok</td>
<td>200</td>
<td>&nbsp;</td>
</tr>
<tr><td>created</td>
<td>201</td>
<td>&nbsp;</td>
</tr>
<tr><td>accepted</td>
<td>202</td>
<td>&nbsp;</td>
</tr>
<tr><td>no_content</td>
<td>204</td>
<td>&nbsp;</td>
</tr>
<tr><td>multiple_choices</td>
<td>300</td>
<td>&nbsp;</td>
</tr>
<tr><td>moved_permanently</td>
<td>301</td>
<td>&nbsp;</td>
</tr>
<tr><td>moved_temporarily</td>
<td>302</td>
<td>&nbsp;</td>
</tr>
<tr><td>not_modified</td>
<td>304</td>
<td>&nbsp;</td>
</tr>
<tr><td>bad_request</td>
<td>400</td>
<td>&nbsp;</td>
</tr>
<tr><td>unauthorized</td>
<td>401</td>
<td>&nbsp;</td>
</tr>
<tr><td>forbidden</td>
<td>403</td>
<td>&nbsp;</td>
</tr>
<tr><td>not_found</td>
<td>404</td>
<td>&nbsp;</td>
</tr>
<tr><td>internal_server_error</td>
<td>500</td>
<td>&nbsp;</td>
</tr>
<tr><td>not_implemented</td>
<td>501</td>
<td>&nbsp;</td>
</tr>
<tr><td>bad_gateway</td>
<td>502</td>
<td>&nbsp;</td>
</tr>
<tr><td>service_unavailable</td>
<td>503</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<a name="i2p_error_code"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+i2p_error_code&labels=documentation&body=Documentation+under+heading+%22enum+i2p_error_code%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-i2p-error-code">
<h1>enum i2p_error_code</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/i2p_stream.hpp">libtorrent/i2p_stream.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="46%" />
<col width="19%" />
<col width="35%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>no_error</td>
<td>0</td>
<td>&nbsp;</td>
</tr>
<tr><td>parse_failed</td>
<td>1</td>
<td>&nbsp;</td>
</tr>
<tr><td>cant_reach_peer</td>
<td>2</td>
<td>&nbsp;</td>
</tr>
<tr><td>i2p_error</td>
<td>3</td>
<td>&nbsp;</td>
</tr>
<tr><td>invalid_key</td>
<td>4</td>
<td>&nbsp;</td>
</tr>
<tr><td>invalid_id</td>
<td>5</td>
<td>&nbsp;</td>
</tr>
<tr><td>timeout</td>
<td>6</td>
<td>&nbsp;</td>
</tr>
<tr><td>key_not_found</td>
<td>7</td>
<td>&nbsp;</td>
</tr>
<tr><td>duplicated_id</td>
<td>8</td>
<td>&nbsp;</td>
</tr>
<tr><td>num_errors</td>
<td>9</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<a name="socks_error_code"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+socks_error_code&labels=documentation&body=Documentation+under+heading+%22enum+socks_error_code%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-socks-error-code">
<h1>enum socks_error_code</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/socks5_stream.hpp">libtorrent/socks5_stream.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="64%" />
<col width="13%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>no_error</td>
<td>0</td>
<td>&nbsp;</td>
</tr>
<tr><td>unsupported_version</td>
<td>1</td>
<td>&nbsp;</td>
</tr>
<tr><td>unsupported_authentication_method</td>
<td>2</td>
<td>&nbsp;</td>
</tr>
<tr><td>unsupported_authentication_version</td>
<td>3</td>
<td>&nbsp;</td>
</tr>
<tr><td>authentication_error</td>
<td>4</td>
<td>&nbsp;</td>
</tr>
<tr><td>username_required</td>
<td>5</td>
<td>&nbsp;</td>
</tr>
<tr><td>general_failure</td>
<td>6</td>
<td>&nbsp;</td>
</tr>
<tr><td>command_not_supported</td>
<td>7</td>
<td>&nbsp;</td>
</tr>
<tr><td>no_identd</td>
<td>8</td>
<td>&nbsp;</td>
</tr>
<tr><td>identd_error</td>
<td>9</td>
<td>&nbsp;</td>
</tr>
<tr><td>num_errors</td>
<td>10</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<a name="error_code_enum"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+error_code_enum&labels=documentation&body=Documentation+under+heading+%22enum+error_code_enum%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-error-code-enum-3">
<h1>enum error_code_enum</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/upnp.hpp">libtorrent/upnp.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="37%" />
<col width="7%" />
<col width="56%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>no_error</td>
<td>0</td>
<td>No error</td>
</tr>
<tr><td>invalid_argument</td>
<td>402</td>
<td>One of the arguments in the request is invalid</td>
</tr>
<tr><td>action_failed</td>
<td>501</td>
<td>The request failed</td>
</tr>
<tr><td>value_not_in_array</td>
<td>714</td>
<td>The specified value does not exist in the array</td>
</tr>
<tr><td>source_ip_cannot_be_wildcarded</td>
<td>715</td>
<td>The source IP address cannot be wild-carded, but
must be fully specified</td>
</tr>
<tr><td>external_port_cannot_be_wildcarded</td>
<td>716</td>
<td>The external port cannot be a wildcard, but must
be specified</td>
</tr>
<tr><td>port_mapping_conflict</td>
<td>718</td>
<td>The port mapping <a class="reference external" href="reference-Bencoding.html#entry">entry</a> specified conflicts with a
mapping assigned previously to another client</td>
</tr>
<tr><td>internal_port_must_match_external</td>
<td>724</td>
<td>Internal and external port value must be the same</td>
</tr>
<tr><td>only_permanent_leases_supported</td>
<td>725</td>
<td>The NAT implementation only supports permanent
lease times on port mappings</td>
</tr>
<tr><td>remote_host_must_be_wildcard</td>
<td>726</td>
<td>RemoteHost must be a wildcard and cannot be a
specific IP address or DNS name</td>
</tr>
<tr><td>external_port_must_be_wildcard</td>
<td>727</td>
<td>ExternalPort must be a wildcard and cannot be a
specific port</td>
</tr>
</tbody>
</table>
<p>You have some control over <a class="reference external" href="reference-Session.html#session">session</a> configuration through the session::apply_settings()
member function. To change one or more configuration options, create a <a class="reference external" href="reference-Settings.html#settings_pack">settings_pack</a>
object and fill it with the settings to be set and pass it in to session::apply_settings().</p>
<p>The <a class="reference external" href="reference-Settings.html#settings_pack">settings_pack</a> object is a collection of settings updates that are applied
to the <a class="reference external" href="reference-Session.html#session">session</a> when passed to session::apply_settings(). It's empty when
constructed.</p>
<p>You have control over proxy and authorization settings and also the user-agent
that will be sent to the tracker. The user-agent will also be used to identify the
client with other peers.</p>
<p>Each configuration option is named with an enum value inside the
<a class="reference external" href="reference-Settings.html#settings_pack">settings_pack</a> class. These are the available settings:</p>
<a name="settings_pack"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+settings_pack&labels=documentation&body=Documentation+under+heading+%22class+settings_pack%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="settings-pack">
<h1>settings_pack</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/settings_pack.hpp">libtorrent/settings_pack.hpp</a>&quot;</p>
<p>The <tt class="docutils literal">settings_pack</tt> struct, contains the names of all settings as
enum values. These values are passed in to the <tt class="docutils literal">set_str()</tt>,
<tt class="docutils literal">set_int()</tt>, <tt class="docutils literal">set_bool()</tt> functions, to specify the setting to
change.</p>
<p>The <tt class="docutils literal">settings_pack</tt> only stores values for settings that have been
explicitly set on this object. However, it can still be queried for
settings that have not been set and returns the default value for those
settings.</p>
<a name="user_agent"></a><table border="1" class="docutils">
<colgroup>
<col width="36%" />
<col width="24%" />
<col width="39%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>user_agent</td>
<td>string</td>
<td>libtorrent/</td>
</tr>
</tbody>
</table>
<p>this is the client identification to the tracker. The recommended
format of this string is: &quot;client-name/client-version
libtorrent/libtorrent-version&quot;. This name will not only be used when
making HTTP requests, but also when sending extended headers to
peers that support that extension. It may not contain r or n</p>
<a name="announce_ip"></a><table border="1" class="docutils">
<colgroup>
<col width="43%" />
<col width="27%" />
<col width="30%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>announce_ip</td>
<td>string</td>
<td>nullptr</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">announce_ip</tt> is the ip address passed along to trackers as the
<tt class="docutils literal">&amp;ip=</tt> parameter. If left as the default, that parameter is
omitted.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This setting is only meant for very special cases where a seed is
running on the same host as the tracker, and the tracker accepts
the IP parameter (which normal trackers don't). Do not set this
option unless you also control the tracker.</p>
</div>
<a name="handshake_client_version"></a><table border="1" class="docutils">
<colgroup>
<col width="60%" />
<col width="19%" />
<col width="21%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>handshake_client_version</td>
<td>string</td>
<td>nullptr</td>
</tr>
</tbody>
</table>
<p>this is the client name and version identifier sent to peers in the
handshake message. If this is an empty string, the user_agent is
used instead. This string must be a UTF-8 encoded unicode string.</p>
<a name="outgoing_interfaces"></a><table border="1" class="docutils">
<colgroup>
<col width="55%" />
<col width="21%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>outgoing_interfaces</td>
<td>string</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<p>This controls which IP address outgoing TCP peer connections are bound
to, in addition to controlling whether such connections are also
bound to a specific network interface/adapter (<em>bind-to-device</em>).</p>
<p>This string is a comma-separated list of IP addresses and
interface names. An empty string will not bind TCP sockets to a
device, and let the network stack assign the local address.</p>
<p>A list of names will be used to bind outgoing TCP sockets in a
round-robin fashion. An IP address will simply be used to <cite>bind()</cite>
the socket. An interface name will attempt to bind the socket to
that interface. If that fails, or is unsupported, one of the IP
addresses configured for that interface is used to <cite>bind()</cite> the
socket to. If the interface or adapter doesn't exist, the
outgoing peer connection will fail with an error message suggesting
the device cannot be found. Adapter names on Unix systems are of
the form &quot;eth0&quot;, &quot;eth1&quot;, &quot;tun0&quot;, etc. This may be useful for
clients that are multi-homed. Binding an outgoing connection to a
local IP does not necessarily make the connection via the
associated NIC/Adapter.</p>
<p>When outgoing interfaces are specified, incoming connections or
packets sent to a local interface or IP that's <em>not</em> in this list
will be rejected with a <a class="reference external" href="reference-Alerts.html#peer_blocked_alert">peer_blocked_alert</a> with
<tt class="docutils literal">invalid_local_interface</tt> as the reason.</p>
<p>Note that these are just interface/adapter names or IP addresses.
There are no ports specified in this list. IPv6 addresses without
port should be specified without enclosing <tt class="docutils literal">[</tt>, <tt class="docutils literal">]</tt>.</p>
<a name="listen_interfaces"></a><table border="1" class="docutils">
<colgroup>
<col width="37%" />
<col width="16%" />
<col width="47%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>listen_interfaces</td>
<td>string</td>
<td>0.0.0.0:6881,[::]:6881</td>
</tr>
</tbody>
</table>
<p>a comma-separated list of (IP or device name, port) pairs. These are
the listen ports that will be opened for accepting incoming uTP and
TCP peer connections. These are also used for <em>outgoing</em> uTP and UDP
tracker connections and DHT nodes.</p>
<p>It is possible to listen on multiple interfaces and
multiple ports. Binding to port 0 will make the operating system
pick the port.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">There are reasons to stick to the same port across sessions,
which would mean only using port 0 on the first start, and
recording the port that was picked for subsequent startups.
Trackers, the DHT and other peers will remember the port they see
you use and hand that port out to other peers trying to connect
to you, as well as trying to connect to you themselves.</p>
</div>
<p>A port that has an &quot;s&quot; suffix will accept SSL peer connections. (note
that SSL sockets are only available in builds with SSL support)</p>
<p>A port that has an &quot;l&quot; suffix will be considered a local network.
i.e. it's assumed to only be able to reach hosts in the same local
network as the IP address (based on the netmask associated with the
IP, queried from the operating system).</p>
<p>if binding fails, the <a class="reference external" href="reference-Alerts.html#listen_failed_alert">listen_failed_alert</a> is posted. Once a
socket binding succeeds (if it does), the <a class="reference external" href="reference-Alerts.html#listen_succeeded_alert">listen_succeeded_alert</a>
is posted. There may be multiple failures before a success.</p>
<p>If a device name that does not exist is configured, no listen
socket will be opened for that interface. If this is the only
interface configured, it will be as if no listen ports are
configured.</p>
<p>If no listen ports are configured (e.g. listen_interfaces is an
empty string), networking will be disabled. No DHT will start, no
outgoing uTP or tracker connections will be made. No incoming TCP
or uTP connections will be accepted. (outgoing TCP connections
will still be possible, depending on
<a class="reference external" href="reference-Settings.html#outgoing_interfaces">settings_pack::outgoing_interfaces</a>).</p>
<p>For example:
<tt class="docutils literal"><span class="pre">[::1]:8888</span></tt> - will only accept connections on the IPv6 loopback
address on port 8888.</p>
<p><tt class="docutils literal">eth0:4444,eth1:4444</tt> - will accept connections on port 4444 on
any IP address bound to device <tt class="docutils literal">eth0</tt> or <tt class="docutils literal">eth1</tt>.</p>
<p><tt class="docutils literal"><span class="pre">[::]:0s</span></tt> - will accept SSL connections on a port chosen by the
OS. And not accept non-SSL connections at all.</p>
<p><tt class="docutils literal"><span class="pre">0.0.0.0:6881,[::]:6881</span></tt> - binds to all interfaces on port 6881.</p>
<p><tt class="docutils literal">10.0.1.13:6881l</tt> - binds to the local IP address, port 6881, but
only allow talking to peers on the same local network. The netmask
is queried from the operating system. Interfaces marked <tt class="docutils literal">l</tt> are
not announced to trackers, unless the tracker is also on the same
local network.</p>
<p>Windows OS network adapter device name must be specified with GUID.
It can be obtained from &quot;netsh lan show interfaces&quot; command output.
GUID must be uppercased string embraced in curly brackets.
<tt class="docutils literal"><span class="pre">{E4F0B674-0DFC-48BB-98A5-2AA730BDB6D6}:7777</span></tt> - will accept
connections on port 7777 on adapter with this GUID.</p>
<p>For more information, see the <a class="reference external" href="manual-ref.html#multi-homed-hosts">Multi-homed hosts</a> section.</p>
<a name="proxy_hostname"></a><table border="1" class="docutils">
<colgroup>
<col width="48%" />
<col width="24%" />
<col width="27%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>proxy_hostname</td>
<td>string</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<p>when using a proxy, this is the hostname where the proxy is running
see proxy_type. Note that when using a proxy, the
<a class="reference external" href="reference-Settings.html#listen_interfaces">settings_pack::listen_interfaces</a> setting is overridden and only a
single interface is created, just to contact the proxy. This
means a proxy cannot be combined with SSL torrents or multiple
listen interfaces. This proxy listen interface will not accept
incoming TCP connections, will not map ports with any gateway and
will not enable local service discovery. All traffic is supposed
to be channeled through the proxy.</p>
<a name="proxy_username"></a>
<a name="proxy_password"></a><table border="1" class="docutils">
<colgroup>
<col width="48%" />
<col width="24%" />
<col width="27%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>proxy_username</td>
<td>string</td>
<td>&nbsp;</td>
</tr>
<tr><td>proxy_password</td>
<td>string</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<p>when using a proxy, these are the credentials (if any) to use when
connecting to it. see proxy_type</p>
<a name="i2p_hostname"></a><table border="1" class="docutils">
<colgroup>
<col width="45%" />
<col width="26%" />
<col width="29%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>i2p_hostname</td>
<td>string</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<p>sets the <a class="reference external" href="http://www.i2p2.de">i2p</a> SAM bridge to connect to. set the port with the
<tt class="docutils literal">i2p_port</tt> setting. Unless this is set, i2p torrents are not
supported. This setting is separate from the other proxy settings
since i2p torrents and their peers are orthogonal. You can have
i2p peers as well as regular peers via a proxy.</p>
<a name="peer_fingerprint"></a><table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="22%" />
<col width="28%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>peer_fingerprint</td>
<td>string</td>
<td>-LT20B0-</td>
</tr>
</tbody>
</table>
<p>this is the fingerprint for the client. It will be used as the
prefix to the peer_id. If this is 20 bytes (or longer) it will be
truncated to 20 bytes and used as the entire peer-id</p>
<p>There is a utility function, <a class="reference external" href="reference-Settings.html#generate_fingerprint()">generate_fingerprint()</a> that can be used
to generate a standard client peer ID fingerprint prefix.</p>
<a name="dht_bootstrap_nodes"></a><table border="1" class="docutils">
<colgroup>
<col width="38%" />
<col width="15%" />
<col width="47%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>dht_bootstrap_nodes</td>
<td>string</td>
<td>dht.libtorrent.org:25401</td>
</tr>
</tbody>
</table>
<p>This is a comma-separated list of IP port-pairs. They will be added
to the DHT node (if it's enabled) as back-up nodes in case we don't
know of any.</p>
<p>Changing these after the DHT has been started may not have any
effect until the DHT is restarted.
Here are some other bootstrap nodes that may work:
<tt class="docutils literal">router.bittorrent.com:6881</tt>,
<tt class="docutils literal">dht.transmissionbt.com:6881</tt>
<tt class="docutils literal">router.bt.ouinet.work:6881</tt>,</p>
<a name="allow_multiple_connections_per_ip"></a><table border="1" class="docutils">
<colgroup>
<col width="70%" />
<col width="12%" />
<col width="18%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>allow_multiple_connections_per_ip</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>determines if connections from the same IP address as existing
connections should be rejected or not. Rejecting multiple connections
from the same IP address will prevent abusive
behavior by peers. The logic for determining whether connections are
to the same peer is more complicated with this enabled, and more
likely to fail in some edge cases. It is not recommended to enable
this feature.</p>
<a name="send_redundant_have"></a><table border="1" class="docutils">
<colgroup>
<col width="58%" />
<col width="17%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>send_redundant_have</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">send_redundant_have</tt> controls if have messages will be sent to
peers that already have the piece. This is typically not necessary,
but it might be necessary for collecting statistics in some cases.</p>
<a name="use_dht_as_fallback"></a><table border="1" class="docutils">
<colgroup>
<col width="58%" />
<col width="17%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>use_dht_as_fallback</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">use_dht_as_fallback</tt> determines how the DHT is used. If this is
true, the DHT will only be used for torrents where all trackers in
its tracker list has failed. Either by an explicit error message or
a time out. If this is false, the DHT is used regardless of if the
trackers fail or not.</p>
<a name="upnp_ignore_nonrouters"></a><table border="1" class="docutils">
<colgroup>
<col width="62%" />
<col width="15%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>upnp_ignore_nonrouters</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">upnp_ignore_nonrouters</tt> indicates whether or not the UPnP
implementation should ignore any broadcast response from a device
whose address is not on our subnet. i.e.
it's a way to not talk to other people's routers by mistake.</p>
<a name="use_parole_mode"></a><table border="1" class="docutils">
<colgroup>
<col width="53%" />
<col width="19%" />
<col width="28%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>use_parole_mode</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">use_parole_mode</tt> specifies if parole mode should be used. Parole
mode means that peers that participate in pieces that fail the hash
check are put in a mode where they are only allowed to download
whole pieces. If the whole piece a peer in parole mode fails the
hash check, it is banned. If a peer participates in a piece that
passes the hash check, it is taken out of parole mode.</p>
<a name="auto_manage_prefer_seeds"></a><table border="1" class="docutils">
<colgroup>
<col width="63%" />
<col width="15%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>auto_manage_prefer_seeds</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>if true, prefer seeding torrents when determining which torrents to give
active slots to. If false, give preference to downloading torrents</p>
<a name="dont_count_slow_torrents"></a><table border="1" class="docutils">
<colgroup>
<col width="63%" />
<col width="15%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>dont_count_slow_torrents</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>if <tt class="docutils literal">dont_count_slow_torrents</tt> is true, torrents without any
payload transfers are not subject to the <tt class="docutils literal">active_seeds</tt> and
<tt class="docutils literal">active_downloads</tt> limits. This is intended to make it more
likely to utilize all available bandwidth, and avoid having
torrents that don't transfer anything block the active slots.</p>
<a name="close_redundant_connections"></a><table border="1" class="docutils">
<colgroup>
<col width="66%" />
<col width="14%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>close_redundant_connections</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">close_redundant_connections</tt> specifies whether libtorrent should
close connections where both ends have no utility in keeping the
connection open. For instance if both ends have completed their
downloads, there's no point in keeping it open.</p>
<a name="prioritize_partial_pieces"></a><table border="1" class="docutils">
<colgroup>
<col width="64%" />
<col width="14%" />
<col width="21%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>prioritize_partial_pieces</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>If <tt class="docutils literal">prioritize_partial_pieces</tt> is true, partial pieces are picked
before pieces that are more rare. If false, rare pieces are always
prioritized, unless the number of partial pieces is growing out of
proportion.</p>
<a name="rate_limit_ip_overhead"></a><table border="1" class="docutils">
<colgroup>
<col width="62%" />
<col width="15%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>rate_limit_ip_overhead</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>if set to true, the estimated TCP/IP overhead is drained from the
rate limiters, to avoid exceeding the limits with the total traffic</p>
<a name="announce_to_all_tiers"></a>
<a name="announce_to_all_trackers"></a><table border="1" class="docutils">
<colgroup>
<col width="63%" />
<col width="15%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>announce_to_all_tiers</td>
<td>bool</td>
<td>false</td>
</tr>
<tr><td>announce_to_all_trackers</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">announce_to_all_trackers</tt> controls how multi tracker torrents
are treated. If this is set to true, all trackers in the same tier
are announced to in parallel. If all trackers in tier 0 fails, all
trackers in tier 1 are announced as well. If it's set to false, the
behavior is as defined by the multi tracker specification.</p>
<p><tt class="docutils literal">announce_to_all_tiers</tt> also controls how multi tracker torrents
are treated. When this is set to true, one tracker from each tier
is announced to. This is the uTorrent behavior. To be compliant
with the Multi-tracker specification, set it to false.</p>
<a name="prefer_udp_trackers"></a><table border="1" class="docutils">
<colgroup>
<col width="58%" />
<col width="17%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>prefer_udp_trackers</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">prefer_udp_trackers</tt>: true means that trackers
may be rearranged in a way that udp trackers are always tried
before http trackers for the same hostname. Setting this to false
means that the tracker's tier is respected and there's no
preference of one protocol over another.</p>
<a name="disable_hash_checks"></a><table border="1" class="docutils">
<colgroup>
<col width="58%" />
<col width="17%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>disable_hash_checks</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>when set to true, all data downloaded from peers will be assumed to
be correct, and not tested to match the hashes in the torrent this
is only useful for simulation and testing purposes (typically
combined with disabled_storage)</p>
<a name="allow_i2p_mixed"></a><table border="1" class="docutils">
<colgroup>
<col width="53%" />
<col width="19%" />
<col width="28%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>allow_i2p_mixed</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>if this is true, i2p torrents are allowed to also get peers from
other sources than the tracker, and connect to regular IPs, not
providing any anonymization. This may be useful if the user is not
interested in the anonymization of i2p, but still wants to be able
to connect to i2p peers.</p>
<a name="no_atime_storage"></a><table border="1" class="docutils">
<colgroup>
<col width="55%" />
<col width="18%" />
<col width="27%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>no_atime_storage</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">no_atime_storage</tt> this is a Linux-only option and passes in the
<tt class="docutils literal">O_NOATIME</tt> to <tt class="docutils literal">open()</tt> when opening files. This may lead to
some disk performance improvements.</p>
<a name="incoming_starts_queued_torrents"></a><table border="1" class="docutils">
<colgroup>
<col width="69%" />
<col width="13%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>incoming_starts_queued_torrents</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">incoming_starts_queued_torrents</tt>.  If a torrent
has been paused by the auto managed feature in libtorrent, i.e. the
torrent is paused and auto managed, this feature affects whether or
not it is automatically started on an incoming connection. The main
reason to queue torrents, is not to make them unavailable, but to
save on the overhead of announcing to the trackers, the DHT and to
avoid spreading one's unchoke slots too thin. If a peer managed to
find us, even though we're no in the torrent anymore, this setting
can make us start the torrent and serve it.</p>
<a name="report_true_downloaded"></a><table border="1" class="docutils">
<colgroup>
<col width="62%" />
<col width="15%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>report_true_downloaded</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>when set to true, the downloaded counter sent to trackers will
include the actual number of payload bytes downloaded including
redundant bytes. If set to false, it will not include any redundancy
bytes</p>
<a name="strict_end_game_mode"></a><table border="1" class="docutils">
<colgroup>
<col width="59%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>strict_end_game_mode</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">strict_end_game_mode</tt> controls when a
block may be requested twice. If this is <tt class="docutils literal">true</tt>, a block may only
be requested twice when there's at least one request to every piece
that's left to download in the torrent. This may slow down progress
on some pieces sometimes, but it may also avoid downloading a lot
of redundant bytes. If this is <tt class="docutils literal">false</tt>, libtorrent attempts to
use each peer connection to its max, by always requesting
something, even if it means requesting something that has been
requested from another peer already.</p>
<a name="enable_outgoing_utp"></a>
<a name="enable_incoming_utp"></a>
<a name="enable_outgoing_tcp"></a>
<a name="enable_incoming_tcp"></a><table border="1" class="docutils">
<colgroup>
<col width="58%" />
<col width="17%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>enable_outgoing_utp</td>
<td>bool</td>
<td>true</td>
</tr>
<tr><td>enable_incoming_utp</td>
<td>bool</td>
<td>true</td>
</tr>
<tr><td>enable_outgoing_tcp</td>
<td>bool</td>
<td>true</td>
</tr>
<tr><td>enable_incoming_tcp</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>Enables incoming and outgoing, TCP and uTP peer connections.
<tt class="docutils literal">false</tt> is disabled and <tt class="docutils literal">true</tt> is enabled. When outgoing
connections are disabled, libtorrent will simply not make
outgoing peer connections with the specific transport protocol.
Disabled incoming peer connections will simply be rejected.
These options only apply to peer connections, not tracker- or any
other kinds of connections.</p>
<a name="no_recheck_incomplete_resume"></a><table border="1" class="docutils">
<colgroup>
<col width="67%" />
<col width="13%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>no_recheck_incomplete_resume</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">no_recheck_incomplete_resume</tt> determines if the storage should
check the whole files when resume data is incomplete or missing or
whether it should simply assume we don't have any of the data. If
false, any existing files will be checked.
By setting this setting to true, the files won't be checked, but
will go straight to download mode.</p>
<a name="anonymous_mode"></a><table border="1" class="docutils">
<colgroup>
<col width="52%" />
<col width="19%" />
<col width="29%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>anonymous_mode</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">anonymous_mode</tt>: When set to true, the client tries to hide
its identity to a certain degree.</p>
<ul class="simple">
<li>A generic user-agent will be
used for trackers (except for private torrents).</li>
<li>Your local IPv4 and IPv6 address won't be sent as query string
parameters to private trackers.</li>
<li>If announce_ip is configured, it will not be sent to trackers</li>
<li>The client version will not be sent to peers in the extension
handshake.</li>
</ul>
<a name="report_web_seed_downloads"></a><table border="1" class="docutils">
<colgroup>
<col width="64%" />
<col width="14%" />
<col width="21%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>report_web_seed_downloads</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>specifies whether downloads from web seeds is reported to the
tracker or not. Turning it off also excludes web
seed traffic from other stats and download rate reporting via the
libtorrent API.</p>
<a name="seeding_outgoing_connections"></a><table border="1" class="docutils">
<colgroup>
<col width="67%" />
<col width="13%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>seeding_outgoing_connections</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">seeding_outgoing_connections</tt> determines if seeding (and
finished) torrents should attempt to make outgoing connections or
not. It may be set to false in very
specific applications where the cost of making outgoing connections
is high, and there are no or small benefits of doing so. For
instance, if no nodes are behind a firewall or a NAT, seeds don't
need to make outgoing connections.</p>
<a name="no_connect_privileged_ports"></a><table border="1" class="docutils">
<colgroup>
<col width="66%" />
<col width="14%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>no_connect_privileged_ports</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>when this is true, libtorrent will not attempt to make outgoing
connections to peers whose port is &lt; 1024. This is a safety
precaution to avoid being part of a DDoS attack</p>
<a name="smooth_connects"></a><table border="1" class="docutils">
<colgroup>
<col width="53%" />
<col width="19%" />
<col width="28%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>smooth_connects</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">smooth_connects</tt> means the number of
connection attempts per second may be limited to below the
<tt class="docutils literal">connection_speed</tt>, in case we're close to bump up against the
limit of number of connections. The intention of this setting is to
more evenly distribute our connection attempts over time, instead
of attempting to connect in batches, and timing them out in
batches.</p>
<a name="always_send_user_agent"></a><table border="1" class="docutils">
<colgroup>
<col width="62%" />
<col width="15%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>always_send_user_agent</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>always send user-agent in every web seed request. If false, only
the first request per http connection will include the user agent</p>
<a name="apply_ip_filter_to_trackers"></a><table border="1" class="docutils">
<colgroup>
<col width="66%" />
<col width="14%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>apply_ip_filter_to_trackers</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">apply_ip_filter_to_trackers</tt> determines
whether the IP filter applies to trackers as well as peers. If this
is set to false, trackers are exempt from the IP filter (if there
is one). If no IP filter is set, this setting is irrelevant.</p>
<a name="ban_web_seeds"></a><table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="20%" />
<col width="30%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>ban_web_seeds</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>when true, web seeds sending bad data will be banned</p>
<a name="support_share_mode"></a><table border="1" class="docutils">
<colgroup>
<col width="57%" />
<col width="17%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>support_share_mode</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>if false, prevents libtorrent to advertise share-mode support</p>
<a name="report_redundant_bytes"></a><table border="1" class="docutils">
<colgroup>
<col width="62%" />
<col width="15%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>report_redundant_bytes</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>if this is true, the number of redundant bytes is sent to the
tracker</p>
<a name="listen_system_port_fallback"></a><table border="1" class="docutils">
<colgroup>
<col width="66%" />
<col width="14%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>listen_system_port_fallback</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>if this is true, libtorrent will fall back to listening on a port
chosen by the operating system (i.e. binding to port 0). If a
failure is preferred, set this to false.</p>
<a name="announce_crypto_support"></a><table border="1" class="docutils">
<colgroup>
<col width="63%" />
<col width="15%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>announce_crypto_support</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>when this is true, and incoming encrypted connections are enabled,
&amp;supportcrypt=1 is included in http tracker announces</p>
<a name="enable_upnp"></a><table border="1" class="docutils">
<colgroup>
<col width="46%" />
<col width="21%" />
<col width="32%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>enable_upnp</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>Starts and stops the UPnP service. When started, the listen port
and the DHT port are attempted to be forwarded on local UPnP router
devices.</p>
<p>The upnp object returned by <tt class="docutils literal">start_upnp()</tt> can be used to add and
remove arbitrary port mappings. Mapping status is returned through
the <a class="reference external" href="reference-Alerts.html#portmap_alert">portmap_alert</a> and the <a class="reference external" href="reference-Alerts.html#portmap_error_alert">portmap_error_alert</a>. The object will be
valid until <tt class="docutils literal">stop_upnp()</tt> is called. See <a class="reference external" href="manual-ref.html#upnp-and-nat-pmp">upnp and nat pmp</a>.</p>
<a name="enable_natpmp"></a><table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="20%" />
<col width="30%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>enable_natpmp</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>Starts and stops the NAT-PMP service. When started, the listen port
and the DHT port are attempted to be forwarded on the router
through NAT-PMP.</p>
<p>The natpmp object returned by <tt class="docutils literal">start_natpmp()</tt> can be used to add
and remove arbitrary port mappings. Mapping status is returned
through the <a class="reference external" href="reference-Alerts.html#portmap_alert">portmap_alert</a> and the <a class="reference external" href="reference-Alerts.html#portmap_error_alert">portmap_error_alert</a>. The object
will be valid until <tt class="docutils literal">stop_natpmp()</tt> is called. See
<a class="reference external" href="manual-ref.html#upnp-and-nat-pmp">upnp and nat pmp</a>.</p>
<a name="enable_lsd"></a><table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="22%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>enable_lsd</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>Starts and stops Local Service Discovery. This service will
broadcast the info-hashes of all the non-private torrents on the
local network to look for peers on the same swarm within multicast
reach.</p>
<a name="enable_dht"></a><table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="22%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>enable_dht</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>starts the dht node and makes the trackerless service available to
torrents.</p>
<a name="prefer_rc4"></a><table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="22%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>prefer_rc4</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>if the allowed encryption level is both, setting this to true will
prefer RC4 if both methods are offered, plain text otherwise</p>
<a name="proxy_hostnames"></a><table border="1" class="docutils">
<colgroup>
<col width="53%" />
<col width="19%" />
<col width="28%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>proxy_hostnames</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>if true, hostname lookups are done via the configured proxy (if
any). This is only supported by SOCKS5 and HTTP.</p>
<a name="proxy_peer_connections"></a><table border="1" class="docutils">
<colgroup>
<col width="62%" />
<col width="15%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>proxy_peer_connections</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>if true, peer connections are made (and accepted) over the
configured proxy, if any. Web seeds as well as regular bittorrent
peer connections are considered &quot;peer connections&quot;. Anything
transporting actual torrent payload (trackers and DHT traffic are
not considered peer connections).</p>
<a name="auto_sequential"></a><table border="1" class="docutils">
<colgroup>
<col width="53%" />
<col width="19%" />
<col width="28%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>auto_sequential</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>if this setting is true, torrents with a very high availability of
pieces (and seeds) are downloaded sequentially. This is more
efficient for the disk I/O. With many seeds, the download order is
unlikely to matter anyway</p>
<a name="proxy_tracker_connections"></a><table border="1" class="docutils">
<colgroup>
<col width="64%" />
<col width="14%" />
<col width="21%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>proxy_tracker_connections</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>if true, tracker connections are made over the configured proxy, if
any.</p>
<a name="enable_ip_notifier"></a><table border="1" class="docutils">
<colgroup>
<col width="57%" />
<col width="17%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>enable_ip_notifier</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>Starts and stops the internal IP table route changes notifier.</p>
<p>The current implementation supports multiple platforms, and it is
recommended to have it enable, but you may want to disable it if
it's supported but unreliable, or if you have a better way to
detect the changes. In the later case, you should manually call
<tt class="docutils literal"><span class="pre">session_handle::reopen_network_sockets</span></tt> to ensure network
changes are taken in consideration.</p>
<a name="dht_prefer_verified_node_ids"></a><table border="1" class="docutils">
<colgroup>
<col width="67%" />
<col width="13%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>dht_prefer_verified_node_ids</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>when this is true, nodes whose IDs are derived from their source
IP according to <a class="reference external" href="https://www.bittorrent.org/beps/bep_0042.html">BEP 42</a> are preferred in the routing table.</p>
<a name="dht_restrict_routing_ips"></a><table border="1" class="docutils">
<colgroup>
<col width="63%" />
<col width="15%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>dht_restrict_routing_ips</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>determines if the routing table entries should restrict entries to one
per IP. This defaults to true, which helps mitigate some attacks on
the DHT. It prevents adding multiple nodes with IPs with a very close
CIDR distance.</p>
<p>when set, nodes whose IP address that's in the same /24 (or /64 for
IPv6) range in the same routing table bucket. This is an attempt to
mitigate node ID spoofing attacks also restrict any IP to only have a
single <a class="reference external" href="reference-Bencoding.html#entry">entry</a> in the whole routing table</p>
<a name="dht_restrict_search_ips"></a><table border="1" class="docutils">
<colgroup>
<col width="63%" />
<col width="15%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>dht_restrict_search_ips</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>determines if DHT searches should prevent adding nodes with IPs with
very close CIDR distance. This also defaults to true and helps
mitigate certain attacks on the DHT.</p>
<a name="dht_extended_routing_table"></a><table border="1" class="docutils">
<colgroup>
<col width="65%" />
<col width="14%" />
<col width="21%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>dht_extended_routing_table</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>makes the first buckets in the DHT routing table fit 128, 64, 32 and
16 nodes respectively, as opposed to the standard size of 8. All other
buckets have size 8 still.</p>
<a name="dht_aggressive_lookups"></a><table border="1" class="docutils">
<colgroup>
<col width="62%" />
<col width="15%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>dht_aggressive_lookups</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>slightly changes the lookup behavior in terms of how many outstanding
requests we keep. Instead of having branch factor be a hard limit, we
always keep <em>branch factor</em> outstanding requests to the closest nodes.
i.e. every time we get results back with closer nodes, we query them
right away. It lowers the lookup times at the cost of more outstanding
queries.</p>
<a name="dht_privacy_lookups"></a><table border="1" class="docutils">
<colgroup>
<col width="58%" />
<col width="17%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>dht_privacy_lookups</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>when set, perform lookups in a way that is slightly more expensive,
but which minimizes the amount of information leaked about you.</p>
<a name="dht_enforce_node_id"></a><table border="1" class="docutils">
<colgroup>
<col width="58%" />
<col width="17%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>dht_enforce_node_id</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>when set, node's whose IDs that are not correctly generated based on
its external IP are ignored. When a query arrives from such node, an
error message is returned with a message saying &quot;invalid node ID&quot;.</p>
<a name="dht_ignore_dark_internet"></a><table border="1" class="docutils">
<colgroup>
<col width="63%" />
<col width="15%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>dht_ignore_dark_internet</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>ignore DHT messages from parts of the internet we wouldn't expect to
see any traffic from</p>
<a name="dht_read_only"></a><table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="20%" />
<col width="30%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>dht_read_only</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>when set, the other nodes won't keep this node in their routing
tables, it's meant for low-power and/or ephemeral devices that
cannot support the DHT, it is also useful for mobile devices which
are sensitive to network traffic and battery life.
this node no longer responds to 'query' messages, and will place a
'ro' key (value = 1) in the top-level message dictionary of outgoing
query messages.</p>
<a name="piece_extent_affinity"></a><table border="1" class="docutils">
<colgroup>
<col width="61%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>piece_extent_affinity</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>when this is true, create an affinity for downloading 4 MiB extents
of adjacent pieces. This is an attempt to achieve better disk I/O
throughput by downloading larger extents of bytes, for torrents with
small piece sizes</p>
<a name="validate_https_trackers"></a><table border="1" class="docutils">
<colgroup>
<col width="63%" />
<col width="15%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>validate_https_trackers</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>when set to true, the certificate of HTTPS trackers and HTTPS web
seeds will be validated against the system's certificate store
(as defined by OpenSSL). If the system does not have a
certificate store, this option may have to be disabled in order
to get trackers and web seeds to work).</p>
<a name="ssrf_mitigation"></a><table border="1" class="docutils">
<colgroup>
<col width="53%" />
<col width="19%" />
<col width="28%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>ssrf_mitigation</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>when enabled, tracker and web seed requests are subject to
certain restrictions.</p>
<p>An HTTP(s) tracker requests to localhost (loopback)
must have the request path start with &quot;/announce&quot;. This is the
conventional bittorrent tracker request. Any other HTTP(S)
tracker request to loopback will be rejected. This applies to
trackers that redirect to loopback as well.</p>
<p>Web seeds that end up on the client's local network (i.e. in a
private IP address range) may not include query string arguments.
This applies to web seeds redirecting to the local network as
well.</p>
<p>Web seeds on global IPs (i.e. not local network) may not redirect
to a local network address</p>
<a name="allow_idna"></a><table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="22%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>allow_idna</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>when disabled, any tracker or web seed with an IDNA hostname
(internationalized domain name) is ignored. This is a security
precaution to avoid various unicode encoding attacks that might
happen at the application level.</p>
<a name="enable_set_file_valid_data"></a><table border="1" class="docutils">
<colgroup>
<col width="65%" />
<col width="14%" />
<col width="21%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>enable_set_file_valid_data</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>when set to true, enables the attempt to use SetFileValidData()
to pre-allocate disk space. This system call will only work when
running with Administrator privileges on Windows, and so this
setting is only relevant in that scenario. Using
SetFileValidData() poses a security risk, as it may reveal
previously deleted information from the disk.</p>
<a name="socks5_udp_send_local_ep"></a><table border="1" class="docutils">
<colgroup>
<col width="63%" />
<col width="15%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>socks5_udp_send_local_ep</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>When using a SOCKS5 proxy, UDP traffic is routed through the
proxy by sending a UDP ASSOCIATE command. If this option is true,
the UDP ASSOCIATE command will include the IP address and
listen port to the local UDP socket. This indicates to the proxy
which source endpoint to expect our packets from. The benefit is
that incoming packets can be forwarded correctly, before any
outgoing packets are sent. The risk is that if there's a NAT
between the client and the proxy, the IP address specified in the
protocol may not be valid from the proxy's point of view.</p>
<a name="tracker_completion_timeout"></a><table border="1" class="docutils">
<colgroup>
<col width="65%" />
<col width="14%" />
<col width="21%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>tracker_completion_timeout</td>
<td>int</td>
<td>30</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">tracker_completion_timeout</tt> is the number of seconds the tracker
connection will wait from when it sent the request until it
considers the tracker to have timed-out.</p>
<a name="tracker_receive_timeout"></a><table border="1" class="docutils">
<colgroup>
<col width="63%" />
<col width="15%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>tracker_receive_timeout</td>
<td>int</td>
<td>10</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">tracker_receive_timeout</tt> is the number of seconds to wait to
receive any data from the tracker. If no data is received for this
number of seconds, the tracker will be considered as having timed
out. If a tracker is down, this is the kind of timeout that will
occur.</p>
<a name="stop_tracker_timeout"></a><table border="1" class="docutils">
<colgroup>
<col width="59%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>stop_tracker_timeout</td>
<td>int</td>
<td>5</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">stop_tracker_timeout</tt> is the number of seconds to wait when
sending a stopped message before considering a tracker to have
timed out. This is usually shorter, to make the client quit faster.
If the value is set to 0, the connections to trackers with the
stopped event are suppressed.</p>
<a name="tracker_maximum_response_length"></a><table border="1" class="docutils">
<colgroup>
<col width="66%" />
<col width="12%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>tracker_maximum_response_length</td>
<td>int</td>
<td>1024*1024</td>
</tr>
</tbody>
</table>
<p>this is the maximum number of bytes in a tracker response. If a
response size passes this number of bytes it will be rejected and
the connection will be closed. On gzipped responses this size is
measured on the uncompressed data. So, if you get 20 bytes of gzip
response that'll expand to 2 megabytes, it will be interrupted
before the entire response has been uncompressed (assuming the
limit is lower than 2 MiB).</p>
<a name="piece_timeout"></a><table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="20%" />
<col width="30%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>piece_timeout</td>
<td>int</td>
<td>20</td>
</tr>
</tbody>
</table>
<p>the number of seconds from a request is sent until it times out if
no piece response is returned.</p>
<a name="request_timeout"></a><table border="1" class="docutils">
<colgroup>
<col width="53%" />
<col width="19%" />
<col width="28%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>request_timeout</td>
<td>int</td>
<td>60</td>
</tr>
</tbody>
</table>
<p>the number of seconds one block (16 kiB) is expected to be received
within. If it's not, the block is requested from a different peer</p>
<a name="request_queue_time"></a><table border="1" class="docutils">
<colgroup>
<col width="57%" />
<col width="17%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>request_queue_time</td>
<td>int</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>the length of the request queue given in the number of seconds it
should take for the other end to send all the pieces. i.e. the
actual number of requests depends on the download rate and this
number.</p>
<a name="max_allowed_in_request_queue"></a><table border="1" class="docutils">
<colgroup>
<col width="67%" />
<col width="13%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>max_allowed_in_request_queue</td>
<td>int</td>
<td>2000</td>
</tr>
</tbody>
</table>
<p>the number of outstanding block requests a peer is allowed to queue
up in the client. If a peer sends more requests than this (before
the first one has been sent) the last request will be dropped. the
higher this is, the faster upload speeds the client can get to a
single peer.</p>
<a name="max_out_request_queue"></a><table border="1" class="docutils">
<colgroup>
<col width="61%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>max_out_request_queue</td>
<td>int</td>
<td>500</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">max_out_request_queue</tt> is the maximum number of outstanding
requests to send to a peer. This limit takes precedence over
<tt class="docutils literal">request_queue_time</tt>. i.e. no matter the download speed, the
number of outstanding requests will never exceed this limit.</p>
<a name="whole_pieces_threshold"></a><table border="1" class="docutils">
<colgroup>
<col width="62%" />
<col width="15%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>whole_pieces_threshold</td>
<td>int</td>
<td>20</td>
</tr>
</tbody>
</table>
<p>if a whole piece can be downloaded in this number of seconds, or
less, the peer_connection will prefer to request whole pieces at a
time from this peer. The benefit of this is to better utilize disk
caches by doing localized accesses and also to make it easier to
identify bad peers if a piece fails the hash check.</p>
<a name="peer_timeout"></a><table border="1" class="docutils">
<colgroup>
<col width="48%" />
<col width="21%" />
<col width="31%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>peer_timeout</td>
<td>int</td>
<td>120</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">peer_timeout</tt> is the number of seconds the peer connection
should wait (for any activity on the peer connection) before
closing it due to time out. 120 seconds is
specified in the protocol specification. After half
the time out, a keep alive message is sent.</p>
<a name="urlseed_timeout"></a><table border="1" class="docutils">
<colgroup>
<col width="53%" />
<col width="19%" />
<col width="28%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>urlseed_timeout</td>
<td>int</td>
<td>20</td>
</tr>
</tbody>
</table>
<p>same as peer_timeout, but only applies to url-seeds. this is
usually set lower, because web servers are expected to be more
reliable.</p>
<a name="urlseed_pipeline_size"></a><table border="1" class="docutils">
<colgroup>
<col width="61%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>urlseed_pipeline_size</td>
<td>int</td>
<td>5</td>
</tr>
</tbody>
</table>
<p>controls the pipelining size of url and http seeds. i.e. the number of HTTP
request to keep outstanding before waiting for the first one to
complete. It's common for web servers to limit this to a relatively
low number, like 5</p>
<a name="urlseed_wait_retry"></a><table border="1" class="docutils">
<colgroup>
<col width="57%" />
<col width="17%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>urlseed_wait_retry</td>
<td>int</td>
<td>30</td>
</tr>
</tbody>
</table>
<p>number of seconds until a new retry of a url-seed takes place.
Default retry value for http-seeds that don't provide
a valid <tt class="docutils literal"><span class="pre">retry-after</span></tt> header.</p>
<a name="file_pool_size"></a><table border="1" class="docutils">
<colgroup>
<col width="52%" />
<col width="19%" />
<col width="29%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>file_pool_size</td>
<td>int</td>
<td>40</td>
</tr>
</tbody>
</table>
<p>sets the upper limit on the total number of files this <a class="reference external" href="reference-Session.html#session">session</a> will
keep open. The reason why files are left open at all is that some
anti virus software hooks on every file close, and scans the file
for viruses. deferring the closing of the files will be the
difference between a usable system and a completely hogged down
system. Most operating systems also has a limit on the total number
of file descriptors a process may have open.</p>
<a name="max_failcount"></a><table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="20%" />
<col width="30%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>max_failcount</td>
<td>int</td>
<td>3</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">max_failcount</tt> is the maximum times we try to
connect to a peer before stop connecting again. If a
peer succeeds, the failure counter is reset. If a
peer is retrieved from a peer source (other than DHT)
the failcount is decremented by one, allowing another
try.</p>
<a name="min_reconnect_time"></a><table border="1" class="docutils">
<colgroup>
<col width="57%" />
<col width="17%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>min_reconnect_time</td>
<td>int</td>
<td>60</td>
</tr>
</tbody>
</table>
<p>the number of seconds to wait to reconnect to a peer. this time is
multiplied with the failcount.</p>
<a name="peer_connect_timeout"></a><table border="1" class="docutils">
<colgroup>
<col width="59%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>peer_connect_timeout</td>
<td>int</td>
<td>15</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">peer_connect_timeout</tt> the number of seconds to wait after a
connection attempt is initiated to a peer until it is considered as
having timed out. This setting is especially important in case the
number of half-open connections are limited, since stale half-open
connection may delay the connection of other peers considerably.</p>
<a name="connection_speed"></a><table border="1" class="docutils">
<colgroup>
<col width="55%" />
<col width="18%" />
<col width="27%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>connection_speed</td>
<td>int</td>
<td>30</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">connection_speed</tt> is the number of connection attempts that are
made per second. If a number &lt; 0 is specified, it will default to
200 connections per second. If 0 is specified, it means don't make
outgoing connections at all.</p>
<a name="inactivity_timeout"></a><table border="1" class="docutils">
<colgroup>
<col width="57%" />
<col width="17%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>inactivity_timeout</td>
<td>int</td>
<td>600</td>
</tr>
</tbody>
</table>
<p>if a peer is uninteresting and uninterested for longer than this
number of seconds, it will be disconnected.</p>
<a name="unchoke_interval"></a><table border="1" class="docutils">
<colgroup>
<col width="55%" />
<col width="18%" />
<col width="27%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>unchoke_interval</td>
<td>int</td>
<td>15</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">unchoke_interval</tt> is the number of seconds between
chokes/unchokes. On this interval, peers are re-evaluated for being
choked/unchoked. This is defined as 30 seconds in the protocol, and
it should be significantly longer than what it takes for TCP to
ramp up to it's max rate.</p>
<a name="optimistic_unchoke_interval"></a><table border="1" class="docutils">
<colgroup>
<col width="66%" />
<col width="14%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>optimistic_unchoke_interval</td>
<td>int</td>
<td>30</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">optimistic_unchoke_interval</tt> is the number of seconds between
each <em>optimistic</em> unchoke. On this timer, the currently
optimistically unchoked peer will change.</p>
<a name="num_want"></a><table border="1" class="docutils">
<colgroup>
<col width="40%" />
<col width="24%" />
<col width="36%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>num_want</td>
<td>int</td>
<td>200</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">num_want</tt> is the number of peers we want from each tracker
request. It defines what is sent as the <tt class="docutils literal">&amp;num_want=</tt> parameter to
the tracker.</p>
<a name="initial_picker_threshold"></a><table border="1" class="docutils">
<colgroup>
<col width="63%" />
<col width="15%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>initial_picker_threshold</td>
<td>int</td>
<td>4</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">initial_picker_threshold</tt> specifies the number of pieces we need
before we switch to rarest first picking. The first
<tt class="docutils literal">initial_picker_threshold</tt> pieces in any torrent are picked at random
, the following pieces are picked in rarest first order.</p>
<a name="allowed_fast_set_size"></a><table border="1" class="docutils">
<colgroup>
<col width="61%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>allowed_fast_set_size</td>
<td>int</td>
<td>5</td>
</tr>
</tbody>
</table>
<p>the number of allowed pieces to send to peers that supports the
fast extensions</p>
<a name="suggest_mode"></a><table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="11%" />
<col width="65%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>suggest_mode</td>
<td>int</td>
<td>settings_pack::no_piece_suggestions</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">suggest_mode</tt> controls whether or not libtorrent will send out
suggest messages to create a bias of its peers to request certain
pieces. The modes are:</p>
<ul class="simple">
<li><tt class="docutils literal">no_piece_suggestions</tt> which will not send out suggest messages.</li>
<li><tt class="docutils literal">suggest_read_cache</tt> which will send out suggest messages for
the most recent pieces that are in the read cache.</li>
</ul>
<a name="max_queued_disk_bytes"></a><table border="1" class="docutils">
<colgroup>
<col width="55%" />
<col width="14%" />
<col width="31%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>max_queued_disk_bytes</td>
<td>int</td>
<td>1024 * 1024</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">max_queued_disk_bytes</tt> is the maximum number of bytes, to
be written to disk, that can wait in the disk I/O thread queue.
This queue is only for waiting for the disk I/O thread to receive
the job and either write it to disk or insert it in the write
cache. When this limit is reached, the peer connections will stop
reading data from their sockets, until the disk thread catches up.
Setting this too low will severely limit your download rate.</p>
<a name="handshake_timeout"></a><table border="1" class="docutils">
<colgroup>
<col width="56%" />
<col width="18%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>handshake_timeout</td>
<td>int</td>
<td>10</td>
</tr>
</tbody>
</table>
<p>the number of seconds to wait for a handshake response from a peer.
If no response is received within this time, the peer is
disconnected.</p>
<a name="send_buffer_low_watermark"></a>
<a name="send_buffer_watermark"></a>
<a name="send_buffer_watermark_factor"></a><table border="1" class="docutils">
<colgroup>
<col width="63%" />
<col width="13%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>send_buffer_low_watermark</td>
<td>int</td>
<td>10 * 1024</td>
</tr>
<tr><td>send_buffer_watermark</td>
<td>int</td>
<td>500 * 1024</td>
</tr>
<tr><td>send_buffer_watermark_factor</td>
<td>int</td>
<td>50</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">send_buffer_low_watermark</tt> the minimum send buffer target size
(send buffer includes bytes pending being read from disk). For good
and snappy seeding performance, set this fairly high, to at least
fit a few blocks. This is essentially the initial window size which
will determine how fast we can ramp up the send rate</p>
<p>if the send buffer has fewer bytes than <tt class="docutils literal">send_buffer_watermark</tt>,
we'll read another 16 kiB block onto it. If set too small, upload
rate capacity will suffer. If set too high, memory will be wasted.
The actual watermark may be lower than this in case the upload rate
is low, this is the upper limit.</p>
<p>the current upload rate to a peer is multiplied by this factor to
get the send buffer watermark. The factor is specified as a
percentage. i.e. 50 -&gt; 0.5 This product is clamped to the
<tt class="docutils literal">send_buffer_watermark</tt> setting to not exceed the max. For high
speed upload, this should be set to a greater value than 100. For
high capacity connections, setting this higher can improve upload
performance and disk throughput. Setting it too high may waste RAM
and create a bias towards read jobs over write jobs.</p>
<a name="choking_algorithm"></a>
<a name="seed_choking_algorithm"></a><table border="1" class="docutils">
<colgroup>
<col width="37%" />
<col width="9%" />
<col width="54%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>choking_algorithm</td>
<td>int</td>
<td>settings_pack::fixed_slots_choker</td>
</tr>
<tr><td>seed_choking_algorithm</td>
<td>int</td>
<td>settings_pack::round_robin</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">choking_algorithm</tt> specifies which algorithm to use to determine
how many peers to unchoke. The unchoking algorithm for
downloading torrents is always &quot;tit-for-tat&quot;, i.e. the peers we
download the fastest from are unchoked.</p>
<p>The options for choking algorithms are defined in the
<a class="reference external" href="reference-Settings.html#choking_algorithm_t">choking_algorithm_t</a> enum.</p>
<p><tt class="docutils literal">seed_choking_algorithm</tt> controls the seeding unchoke behavior.
i.e. How we select which peers to unchoke for seeding torrents.
Since a seeding torrent isn't downloading anything, the
tit-for-tat mechanism cannot be used. The available options are
defined in the <a class="reference external" href="reference-Settings.html#seed_choking_algorithm_t">seed_choking_algorithm_t</a> enum.</p>
<a name="disk_io_write_mode"></a>
<a name="disk_io_read_mode"></a><table border="1" class="docutils">
<colgroup>
<col width="34%" />
<col width="10%" />
<col width="55%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>disk_io_write_mode</td>
<td>int</td>
<td>DISK_WRITE_MODE</td>
</tr>
<tr><td>disk_io_read_mode</td>
<td>int</td>
<td>settings_pack::enable_os_cache</td>
</tr>
</tbody>
</table>
<p>determines how files are opened when they're in read only mode
versus read and write mode. The options are:</p>
<dl class="docutils">
<dt>enable_os_cache</dt>
<dd>Files are opened normally, with the OS caching reads and writes.</dd>
<dt>disable_os_cache</dt>
<dd>This opens all files in no-cache mode. This corresponds to the
OS not letting blocks for the files linger in the cache. This
makes sense in order to avoid the bittorrent client to
potentially evict all other processes' cache by simply handling
high throughput and large files. If libtorrent's read cache is
disabled, enabling this may reduce performance.</dd>
<dt>write_through</dt>
<dd>flush pieces to disk as they complete validation.</dd>
</dl>
<p>One reason to disable caching is that it may help the operating
system from growing its file cache indefinitely.</p>
<a name="outgoing_port"></a>
<a name="num_outgoing_ports"></a><table border="1" class="docutils">
<colgroup>
<col width="57%" />
<col width="17%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>outgoing_port</td>
<td>int</td>
<td>0</td>
</tr>
<tr><td>num_outgoing_ports</td>
<td>int</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>this is the first port to use for binding outgoing connections to.
This is useful for users that have routers that allow QoS settings
based on local port. when binding outgoing connections to specific
ports, <tt class="docutils literal">num_outgoing_ports</tt> is the size of the range. It should
be more than a few</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">setting outgoing ports will limit the ability to keep
multiple connections to the same client, even for different
torrents. It is not recommended to change this setting. Its main
purpose is to use as an escape hatch for cheap routers with QoS
capability but can only classify flows based on port numbers.</p>
</div>
<p>It is a range instead of a single port because of the problems with
failing to reconnect to peers if a previous socket to that peer and
port is in <tt class="docutils literal">TIME_WAIT</tt> state.</p>
<a name="peer_dscp"></a><table border="1" class="docutils">
<colgroup>
<col width="42%" />
<col width="23%" />
<col width="35%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>peer_dscp</td>
<td>int</td>
<td>0x04</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">peer_dscp</tt> determines the DSCP field in the IP header of every
packet sent to peers (including web seeds). <tt class="docutils literal">0x0</tt> means no marking,
<tt class="docutils literal">0x04</tt> represents Lower Effort. For more details see <a class="reference external" href="http://www.faqs.org/rfcs/rfc8622.html">RFC 8622</a>.</p>
<p><tt class="docutils literal">peer_tos</tt> is the backwards compatible name for this setting.</p>
<a name="active_downloads"></a>
<a name="active_seeds"></a>
<a name="active_checking"></a>
<a name="active_dht_limit"></a>
<a name="active_tracker_limit"></a>
<a name="active_lsd_limit"></a>
<a name="active_limit"></a><table border="1" class="docutils">
<colgroup>
<col width="59%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>active_downloads</td>
<td>int</td>
<td>3</td>
</tr>
<tr><td>active_seeds</td>
<td>int</td>
<td>5</td>
</tr>
<tr><td>active_checking</td>
<td>int</td>
<td>1</td>
</tr>
<tr><td>active_dht_limit</td>
<td>int</td>
<td>88</td>
</tr>
<tr><td>active_tracker_limit</td>
<td>int</td>
<td>1600</td>
</tr>
<tr><td>active_lsd_limit</td>
<td>int</td>
<td>60</td>
</tr>
<tr><td>active_limit</td>
<td>int</td>
<td>500</td>
</tr>
</tbody>
</table>
<p>for auto managed torrents, these are the limits they are subject
to. If there are too many torrents some of the auto managed ones
will be paused until some slots free up. <tt class="docutils literal">active_downloads</tt> and
<tt class="docutils literal">active_seeds</tt> controls how many active seeding and downloading
torrents the queuing mechanism allows. The target number of active
torrents is <tt class="docutils literal">min(active_downloads + active_seeds, active_limit)</tt>.
<tt class="docutils literal">active_downloads</tt> and <tt class="docutils literal">active_seeds</tt> are upper limits on the
number of downloading torrents and seeding torrents respectively.
Setting the value to -1 means unlimited.</p>
<p>For example if there are 10 seeding torrents and 10 downloading
torrents, and <tt class="docutils literal">active_downloads</tt> is 4 and <tt class="docutils literal">active_seeds</tt> is 4,
there will be 4 seeds active and 4 downloading torrents. If the
settings are <tt class="docutils literal">active_downloads</tt> = 2 and <tt class="docutils literal">active_seeds</tt> = 4,
then there will be 2 downloading torrents and 4 seeding torrents
active. Torrents that are not auto managed are not counted against
these limits.</p>
<p><tt class="docutils literal">active_checking</tt> is the limit of number of simultaneous checking
torrents.</p>
<p><tt class="docutils literal">active_limit</tt> is a hard limit on the number of active (auto
managed) torrents. This limit also applies to slow torrents.</p>
<p><tt class="docutils literal">active_dht_limit</tt> is the max number of torrents to announce to
the DHT.</p>
<p><tt class="docutils literal">active_tracker_limit</tt> is the max number of torrents to announce
to their trackers.</p>
<p><tt class="docutils literal">active_lsd_limit</tt> is the max number of torrents to announce to
the local network over the local service discovery protocol.</p>
<p>You can have more torrents <em>active</em>, even though they are not
announced to the DHT, lsd or their tracker. If some peer knows
about you for any reason and tries to connect, it will still be
accepted, unless the torrent is paused, which means it won't accept
any connections.</p>
<a name="auto_manage_interval"></a><table border="1" class="docutils">
<colgroup>
<col width="59%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>auto_manage_interval</td>
<td>int</td>
<td>30</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">auto_manage_interval</tt> is the number of seconds between the
torrent queue is updated, and rotated.</p>
<a name="seed_time_limit"></a><table border="1" class="docutils">
<colgroup>
<col width="46%" />
<col width="16%" />
<col width="38%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>seed_time_limit</td>
<td>int</td>
<td>24 * 60 * 60</td>
</tr>
</tbody>
</table>
<p>this is the limit on the time a torrent has been an active seed
(specified in seconds) before it is considered having met the seed
limit criteria. See <a class="reference external" href="manual-ref.html#queuing">queuing</a>.</p>
<a name="auto_scrape_interval"></a>
<a name="auto_scrape_min_interval"></a><table border="1" class="docutils">
<colgroup>
<col width="63%" />
<col width="15%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>auto_scrape_interval</td>
<td>int</td>
<td>1800</td>
</tr>
<tr><td>auto_scrape_min_interval</td>
<td>int</td>
<td>300</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">auto_scrape_interval</tt> is the number of seconds between scrapes
of queued torrents (auto managed and paused torrents). Auto managed
torrents that are paused, are scraped regularly in order to keep
track of their downloader/seed ratio. This ratio is used to
determine which torrents to seed and which to pause.</p>
<p><tt class="docutils literal">auto_scrape_min_interval</tt> is the minimum number of seconds
between any automatic scrape (regardless of torrent). In case there
are a large number of paused auto managed torrents, this puts a
limit on how often a scrape request is sent.</p>
<a name="max_peerlist_size"></a>
<a name="max_paused_peerlist_size"></a><table border="1" class="docutils">
<colgroup>
<col width="63%" />
<col width="15%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>max_peerlist_size</td>
<td>int</td>
<td>3000</td>
</tr>
<tr><td>max_paused_peerlist_size</td>
<td>int</td>
<td>1000</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">max_peerlist_size</tt> is the maximum number of peers in the list of
known peers. These peers are not necessarily connected, so this
number should be much greater than the maximum number of connected
peers. Peers are evicted from the cache when the list grows passed
90% of this limit, and once the size hits the limit, peers are no
longer added to the list. If this limit is set to 0, there is no
limit on how many peers we'll keep in the peer list.</p>
<p><tt class="docutils literal">max_paused_peerlist_size</tt> is the max peer list size used for
torrents that are paused. This can be used to save memory for paused
torrents, since it's not as important for them to keep a large peer
list.</p>
<a name="min_announce_interval"></a><table border="1" class="docutils">
<colgroup>
<col width="61%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>min_announce_interval</td>
<td>int</td>
<td>5 * 60</td>
</tr>
</tbody>
</table>
<p>this is the minimum allowed announce interval for a tracker. This
is specified in seconds and is used as a sanity check on what is
returned from a tracker. It mitigates hammering mis-configured
trackers.</p>
<a name="auto_manage_startup"></a><table border="1" class="docutils">
<colgroup>
<col width="58%" />
<col width="17%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>auto_manage_startup</td>
<td>int</td>
<td>60</td>
</tr>
</tbody>
</table>
<p>this is the number of seconds a torrent is considered active after
it was started, regardless of upload and download speed. This is so
that newly started torrents are not considered inactive until they
have a fair chance to start downloading.</p>
<a name="seeding_piece_quota"></a><table border="1" class="docutils">
<colgroup>
<col width="58%" />
<col width="17%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>seeding_piece_quota</td>
<td>int</td>
<td>20</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">seeding_piece_quota</tt> is the number of pieces to send to a peer,
when seeding, before rotating in another peer to the unchoke set.</p>
<a name="max_rejects"></a><table border="1" class="docutils">
<colgroup>
<col width="46%" />
<col width="21%" />
<col width="32%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>max_rejects</td>
<td>int</td>
<td>50</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">max_rejects</tt> is the number of piece requests we will reject in a
row while a peer is choked before the peer is considered abusive
and is disconnected.</p>
<a name="recv_socket_buffer_size"></a>
<a name="send_socket_buffer_size"></a><table border="1" class="docutils">
<colgroup>
<col width="63%" />
<col width="15%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>recv_socket_buffer_size</td>
<td>int</td>
<td>0</td>
</tr>
<tr><td>send_socket_buffer_size</td>
<td>int</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>specifies the buffer sizes set on peer sockets. 0 means the OS
default (i.e. don't change the buffer sizes).
The socket buffer sizes are changed using setsockopt() with
SOL_SOCKET/SO_RCVBUF and SO_SNDBUFFER.</p>
<p>Note that uTP peers share a single UDP socket buffer for each of the
<tt class="docutils literal">listen_interfaces</tt>, along with DHT and UDP tracker traffic.
If the buffer size is too small for the combined traffic through the
socket, packets may be dropped.</p>
<a name="max_peer_recv_buffer_size"></a><table border="1" class="docutils">
<colgroup>
<col width="54%" />
<col width="12%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>max_peer_recv_buffer_size</td>
<td>int</td>
<td>2 * 1024 * 1024</td>
</tr>
</tbody>
</table>
<p>the max number of bytes a single peer connection's receive buffer is
allowed to grow to.</p>
<a name="optimistic_disk_retry"></a><table border="1" class="docutils">
<colgroup>
<col width="61%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>optimistic_disk_retry</td>
<td>int</td>
<td>10 * 60</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">optimistic_disk_retry</tt> is the number of seconds from a disk
write errors occur on a torrent until libtorrent will take it out
of the upload mode, to test if the error condition has been fixed.</p>
<p>libtorrent will only do this automatically for auto managed
torrents.</p>
<p>You can explicitly take a torrent out of upload only mode using
set_upload_mode().</p>
<a name="max_suggest_pieces"></a><table border="1" class="docutils">
<colgroup>
<col width="57%" />
<col width="17%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>max_suggest_pieces</td>
<td>int</td>
<td>16</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">max_suggest_pieces</tt> is the max number of suggested piece indices
received from a peer that's remembered. If a peer floods suggest
messages, this limit prevents libtorrent from using too much RAM.</p>
<a name="local_service_announce_interval"></a><table border="1" class="docutils">
<colgroup>
<col width="69%" />
<col width="13%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>local_service_announce_interval</td>
<td>int</td>
<td>5 * 60</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">local_service_announce_interval</tt> is the time between local
network announces for a torrent.
This interval is specified in seconds.</p>
<a name="dht_announce_interval"></a><table border="1" class="docutils">
<colgroup>
<col width="61%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>dht_announce_interval</td>
<td>int</td>
<td>15 * 60</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">dht_announce_interval</tt> is the number of seconds between
announcing torrents to the distributed hash table (DHT).</p>
<a name="udp_tracker_token_expiry"></a><table border="1" class="docutils">
<colgroup>
<col width="63%" />
<col width="15%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>udp_tracker_token_expiry</td>
<td>int</td>
<td>60</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">udp_tracker_token_expiry</tt> is the number of seconds libtorrent
will keep UDP tracker connection tokens around for. This is
specified to be 60 seconds. The higher this
value is, the fewer packets have to be sent to the UDP tracker. In
order for higher values to work, the tracker needs to be configured
to match the expiration time for tokens.</p>
<a name="num_optimistic_unchoke_slots"></a><table border="1" class="docutils">
<colgroup>
<col width="67%" />
<col width="13%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>num_optimistic_unchoke_slots</td>
<td>int</td>
<td>0</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">num_optimistic_unchoke_slots</tt> is the number of optimistic
unchoke slots to use.
Having a higher number of optimistic unchoke slots mean you will
find the good peers faster but with the trade-off to use up more
bandwidth. 0 means automatic, where libtorrent opens up 20% of your
allowed upload slots as optimistic unchoke slots.</p>
<a name="max_pex_peers"></a><table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="20%" />
<col width="30%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>max_pex_peers</td>
<td>int</td>
<td>50</td>
</tr>
</tbody>
</table>
<p>the max number of peers we accept from pex messages from a single
peer. this limits the number of concurrent peers any of our peers
claims to be connected to. If they claim to be connected to more
than this, we'll ignore any peer that exceeds this limit</p>
<a name="tick_interval"></a><table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="20%" />
<col width="30%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>tick_interval</td>
<td>int</td>
<td>500</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">tick_interval</tt> specifies the number of milliseconds between
internal ticks. This is the frequency with which bandwidth quota is
distributed to peers. It should not be more than one second (i.e.
1000 ms). Setting this to a low value (around 100) means higher
resolution bandwidth quota distribution, setting it to a higher
value saves CPU cycles.</p>
<a name="share_mode_target"></a><table border="1" class="docutils">
<colgroup>
<col width="56%" />
<col width="18%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>share_mode_target</td>
<td>int</td>
<td>3</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">share_mode_target</tt> specifies the target share ratio for share
mode torrents. If set to 3, we'll try to upload 3
times as much as we download. Setting this very high, will make it
very conservative and you might end up not downloading anything
ever (and not affecting your share ratio). It does not make any
sense to set this any lower than 2. For instance, if only 3 peers
need to download the rarest piece, it's impossible to download a
single piece and upload it more than 3 times. If the
share_mode_target is set to more than 3, nothing is downloaded.</p>
<a name="upload_rate_limit"></a>
<a name="download_rate_limit"></a><table border="1" class="docutils">
<colgroup>
<col width="58%" />
<col width="17%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>upload_rate_limit</td>
<td>int</td>
<td>0</td>
</tr>
<tr><td>download_rate_limit</td>
<td>int</td>
<td>0</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">upload_rate_limit</tt> and <tt class="docutils literal">download_rate_limit</tt> sets
the session-global limits of upload and download rate limits, in
bytes per second. By default peers on the local network are not rate
limited.</p>
<p>A value of 0 means unlimited.</p>
<p>For fine grained control over rate limits, including making them apply
to local peers, see <a class="reference external" href="manual-ref.html#peer-classes">peer classes</a>.</p>
<a name="dht_upload_rate_limit"></a><table border="1" class="docutils">
<colgroup>
<col width="61%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>dht_upload_rate_limit</td>
<td>int</td>
<td>8000</td>
</tr>
</tbody>
</table>
<p>the number of bytes per second (on average) the DHT is allowed to send.
If the incoming requests causes to many bytes to be sent in responses,
incoming requests will be dropped until the quota has been replenished.</p>
<a name="unchoke_slots_limit"></a><table border="1" class="docutils">
<colgroup>
<col width="58%" />
<col width="17%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>unchoke_slots_limit</td>
<td>int</td>
<td>8</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">unchoke_slots_limit</tt> is the max number of unchoked peers in the
<a class="reference external" href="reference-Session.html#session">session</a>. The number of unchoke slots may be ignored depending on
what <tt class="docutils literal">choking_algorithm</tt> is set to. Setting this limit to -1
means unlimited, i.e. all peers will always be unchoked.</p>
<a name="connections_limit"></a><table border="1" class="docutils">
<colgroup>
<col width="56%" />
<col width="18%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>connections_limit</td>
<td>int</td>
<td>200</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">connections_limit</tt> sets a global limit on the number of
connections opened. The number of connections is set to a hard
minimum of at least two per torrent, so if you set a too low
connections limit, and open too many torrents, the limit will not
be met.</p>
<a name="connections_slack"></a><table border="1" class="docutils">
<colgroup>
<col width="56%" />
<col width="18%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>connections_slack</td>
<td>int</td>
<td>10</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">connections_slack</tt> is the number of incoming connections
exceeding the connection limit to accept in order to potentially
replace existing ones.</p>
<a name="utp_target_delay"></a>
<a name="utp_gain_factor"></a>
<a name="utp_min_timeout"></a>
<a name="utp_syn_resends"></a>
<a name="utp_fin_resends"></a>
<a name="utp_num_resends"></a>
<a name="utp_connect_timeout"></a>
<a name="utp_loss_multiplier"></a><table border="1" class="docutils">
<colgroup>
<col width="58%" />
<col width="17%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>utp_target_delay</td>
<td>int</td>
<td>100</td>
</tr>
<tr><td>utp_gain_factor</td>
<td>int</td>
<td>3000</td>
</tr>
<tr><td>utp_min_timeout</td>
<td>int</td>
<td>500</td>
</tr>
<tr><td>utp_syn_resends</td>
<td>int</td>
<td>2</td>
</tr>
<tr><td>utp_fin_resends</td>
<td>int</td>
<td>2</td>
</tr>
<tr><td>utp_num_resends</td>
<td>int</td>
<td>3</td>
</tr>
<tr><td>utp_connect_timeout</td>
<td>int</td>
<td>3000</td>
</tr>
<tr><td>utp_loss_multiplier</td>
<td>int</td>
<td>50</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">utp_target_delay</tt> is the target delay for uTP sockets in
milliseconds. A high value will make uTP connections more
aggressive and cause longer queues in the upload bottleneck. It
cannot be too low, since the noise in the measurements would cause
it to send too slow.
<tt class="docutils literal">utp_gain_factor</tt> is the number of bytes the uTP congestion
window can increase at the most in one RTT.
If this is set too high, the congestion controller reacts
too hard to noise and will not be stable, if it's set too low, it
will react slow to congestion and not back off as fast.</p>
<p><tt class="docutils literal">utp_min_timeout</tt> is the shortest allowed uTP socket timeout,
specified in milliseconds. The
timeout depends on the RTT of the connection, but is never smaller
than this value. A connection times out when every packet in a
window is lost, or when a packet is lost twice in a row (i.e. the
resent packet is lost as well).</p>
<p>The shorter the timeout is, the faster the connection will recover
from this situation, assuming the RTT is low enough.
<tt class="docutils literal">utp_syn_resends</tt> is the number of SYN packets that are sent (and
timed out) before giving up and closing the socket.
<tt class="docutils literal">utp_num_resends</tt> is the number of times a packet is sent (and
lost or timed out) before giving up and closing the connection.
<tt class="docutils literal">utp_connect_timeout</tt> is the number of milliseconds of timeout
for the initial SYN packet for uTP connections. For each timed out
packet (in a row), the timeout is doubled. <tt class="docutils literal">utp_loss_multiplier</tt>
controls how the congestion window is changed when a packet loss is
experienced. It's specified as a percentage multiplier for
<tt class="docutils literal">cwnd</tt>. Do not change this value unless you know what you're doing.
Never set it higher than 100.</p>
<a name="mixed_mode_algorithm"></a><table border="1" class="docutils">
<colgroup>
<col width="35%" />
<col width="10%" />
<col width="55%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>mixed_mode_algorithm</td>
<td>int</td>
<td>settings_pack::peer_proportional</td>
</tr>
</tbody>
</table>
<p>The <tt class="docutils literal">mixed_mode_algorithm</tt> determines how to treat TCP
connections when there are uTP connections. Since uTP is designed
to yield to TCP, there's an inherent problem when using swarms that
have both TCP and uTP connections. If nothing is done, uTP
connections would often be starved out for bandwidth by the TCP
connections. This mode is <tt class="docutils literal">prefer_tcp</tt>. The <tt class="docutils literal">peer_proportional</tt>
mode simply looks at the current throughput and rate limits all TCP
connections to their proportional share based on how many of the
connections are TCP. This works best if uTP connections are not
rate limited by the global rate limiter (which they aren't by
default).</p>
<a name="listen_queue_size"></a><table border="1" class="docutils">
<colgroup>
<col width="56%" />
<col width="18%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>listen_queue_size</td>
<td>int</td>
<td>5</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">listen_queue_size</tt> is the value passed in to listen() for the
listen socket. It is the number of outstanding incoming connections
to queue up while we're not actively waiting for a connection to be
accepted. 5 should be sufficient for any
normal client. If this is a high performance server which expects
to receive a lot of connections, or used in a simulator or test, it
might make sense to raise this number. It will not take affect
until the <tt class="docutils literal">listen_interfaces</tt> settings is updated.</p>
<a name="torrent_connect_boost"></a><table border="1" class="docutils">
<colgroup>
<col width="61%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>torrent_connect_boost</td>
<td>int</td>
<td>30</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">torrent_connect_boost</tt> is the number of peers to try to connect
to immediately when the first tracker response is received for a
torrent. This is a boost to given to new torrents to accelerate
them starting up. The normal connect scheduler is run once every
second, this allows peers to be connected immediately instead of
waiting for the <a class="reference external" href="reference-Session.html#session">session</a> tick to trigger connections.
This may not be set higher than 255.</p>
<a name="alert_queue_size"></a><table border="1" class="docutils">
<colgroup>
<col width="55%" />
<col width="18%" />
<col width="27%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>alert_queue_size</td>
<td>int</td>
<td>2000</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">alert_queue_size</tt> is the maximum number of alerts queued up
internally. If alerts are not popped, the queue will eventually
fill up to this level. Once the <a class="reference external" href="reference-Alerts.html#alert">alert</a> queue is full, additional
alerts will be dropped, and not delivered to the client. Once the
client drains the queue, new alerts may be delivered again. In order
to know that alerts have been dropped, see
session_handle::dropped_alerts().</p>
<a name="max_metadata_size"></a><table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="14%" />
<col width="42%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>max_metadata_size</td>
<td>int</td>
<td>3 * 1024 * 10240</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">max_metadata_size</tt> is the maximum allowed size (in bytes) to be
received by the metadata extension, i.e. magnet links.</p>
<a name="hashing_threads"></a><table border="1" class="docutils">
<colgroup>
<col width="53%" />
<col width="19%" />
<col width="28%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>hashing_threads</td>
<td>int</td>
<td>1</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">hashing_threads</tt> is the number of disk I/O threads to use for
piece hash verification. These threads are <em>in addition</em> to the
regular disk I/O threads specified by <a class="reference external" href="reference-Settings.html#aio_threads">settings_pack::aio_threads</a>.
These threads are only used for full checking of torrents. The
hash checking done while downloading are done by the regular disk
I/O threads.
The <a class="reference external" href="reference-Utility.html#hasher">hasher</a> threads do not only compute hashes, but also perform
the read from disk. On storage optimal for sequential access,
such as hard drives, this setting should be set to 1, which is
also the default.</p>
<a name="checking_mem_usage"></a><table border="1" class="docutils">
<colgroup>
<col width="57%" />
<col width="17%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>checking_mem_usage</td>
<td>int</td>
<td>256</td>
</tr>
</tbody>
</table>
<p>the number of blocks to keep outstanding at any given time when
checking torrents. Higher numbers give faster re-checks but uses
more memory. Specified in number of 16 kiB blocks</p>
<a name="predictive_piece_announce"></a><table border="1" class="docutils">
<colgroup>
<col width="64%" />
<col width="14%" />
<col width="21%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>predictive_piece_announce</td>
<td>int</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>if set to &gt; 0, pieces will be announced to other peers before they
are fully downloaded (and before they are hash checked). The
intention is to gain 1.5 potential round trip times per downloaded
piece. When non-zero, this indicates how many milliseconds in
advance pieces should be announced, before they are expected to be
completed.</p>
<a name="aio_threads"></a><table border="1" class="docutils">
<colgroup>
<col width="46%" />
<col width="21%" />
<col width="32%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>aio_threads</td>
<td>int</td>
<td>10</td>
</tr>
</tbody>
</table>
<p>for some aio back-ends, <tt class="docutils literal">aio_threads</tt> specifies the number of
io-threads to use.</p>
<a name="tracker_backoff"></a><table border="1" class="docutils">
<colgroup>
<col width="53%" />
<col width="19%" />
<col width="28%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>tracker_backoff</td>
<td>int</td>
<td>250</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">tracker_backoff</tt> determines how aggressively to back off from
retrying failing trackers. This value determines <em>x</em> in the
following formula, determining the number of seconds to wait until
the next retry:</p>
<blockquote>
delay = 5 + 5 * x / 100 * fails^2</blockquote>
<p>This setting may be useful to make libtorrent more or less
aggressive in hitting trackers.</p>
<a name="share_ratio_limit"></a>
<a name="seed_time_ratio_limit"></a><table border="1" class="docutils">
<colgroup>
<col width="61%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>share_ratio_limit</td>
<td>int</td>
<td>200</td>
</tr>
<tr><td>seed_time_ratio_limit</td>
<td>int</td>
<td>700</td>
</tr>
</tbody>
</table>
<p>when a seeding torrent reaches either the share ratio (bytes up /
bytes down) or the seed time ratio (seconds as seed / seconds as
downloader) or the seed time limit (seconds as seed) it is
considered done, and it will leave room for other torrents. These
are specified as percentages. Torrents that are considered done will
still be allowed to be seeded, they just won't have priority anymore.
For more, see <a class="reference external" href="manual-ref.html#queuing">queuing</a>.</p>
<a name="peer_turnover"></a>
<a name="peer_turnover_cutoff"></a>
<a name="peer_turnover_interval"></a><table border="1" class="docutils">
<colgroup>
<col width="62%" />
<col width="15%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>peer_turnover</td>
<td>int</td>
<td>4</td>
</tr>
<tr><td>peer_turnover_cutoff</td>
<td>int</td>
<td>90</td>
</tr>
<tr><td>peer_turnover_interval</td>
<td>int</td>
<td>300</td>
</tr>
</tbody>
</table>
<p>peer_turnover is the percentage of peers to disconnect every
turnover peer_turnover_interval (if we're at the peer limit), this
is specified in percent when we are connected to more than limit *
peer_turnover_cutoff peers disconnect peer_turnover fraction of the
peers. It is specified in percent peer_turnover_interval is the
interval (in seconds) between optimistic disconnects if the
disconnects happen and how many peers are disconnected is
controlled by peer_turnover and peer_turnover_cutoff</p>
<a name="connect_seed_every_n_download"></a><table border="1" class="docutils">
<colgroup>
<col width="67%" />
<col width="13%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>connect_seed_every_n_download</td>
<td>int</td>
<td>10</td>
</tr>
</tbody>
</table>
<p>this setting controls the priority of downloading torrents over
seeding or finished torrents when it comes to making peer
connections. Peer connections are throttled by the connection_speed
and the half-open connection limit. This makes peer connections a
limited resource. Torrents that still have pieces to download are
prioritized by default, to avoid having many seeding torrents use
most of the connection attempts and only give one peer every now
and then to the downloading torrent. libtorrent will loop over the
downloading torrents to connect a peer each, and every n:th
connection attempt, a finished torrent is picked to be allowed to
connect to a peer. This setting controls n.</p>
<a name="max_http_recv_buffer_size"></a><table border="1" class="docutils">
<colgroup>
<col width="60%" />
<col width="13%" />
<col width="27%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>max_http_recv_buffer_size</td>
<td>int</td>
<td>4*1024*204</td>
</tr>
</tbody>
</table>
<p>the max number of bytes to allow an HTTP response to be when
announcing to trackers or downloading .torrent files via the
<tt class="docutils literal">url</tt> provided in <tt class="docutils literal">add_torrent_params</tt>.</p>
<a name="max_retry_port_bind"></a><table border="1" class="docutils">
<colgroup>
<col width="58%" />
<col width="17%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>max_retry_port_bind</td>
<td>int</td>
<td>10</td>
</tr>
</tbody>
</table>
<p>if binding to a specific port fails, should the port be incremented
by one and tried again? This setting specifies how many times to
retry a failed port bind</p>
<a name="alert_mask"></a><table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="22%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>alert_mask</td>
<td>int</td>
<td>int</td>
</tr>
</tbody>
</table>
<p>a bitmask combining flags from <a class="reference external" href="reference-Alerts.html#alert_category_t">alert_category_t</a> defining which
kinds of alerts to receive</p>
<a name="out_enc_policy"></a>
<a name="in_enc_policy"></a><table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="12%" />
<col width="55%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>out_enc_policy</td>
<td>int</td>
<td>settings_pack::pe_enabled</td>
</tr>
<tr><td>in_enc_policy</td>
<td>int</td>
<td>settings_pack::pe_enabled</td>
</tr>
</tbody>
</table>
<p>control the settings for incoming and outgoing connections
respectively. see <a class="reference external" href="reference-Settings.html#enc_policy">enc_policy</a> enum for the available options.
Keep in mind that protocol encryption degrades performance in
several respects:</p>
<ol class="arabic simple">
<li>It prevents &quot;zero copy&quot; disk buffers being sent to peers, since
each peer needs to mutate the data (i.e. encrypt it) the data
must be copied per peer connection rather than sending the same
buffer to multiple peers.</li>
<li>The encryption itself requires more CPU than plain bittorrent
protocol. The highest cost is the Diffie Hellman exchange on
connection setup.</li>
<li>The encryption handshake adds several round-trips to the
connection setup, and delays transferring data.</li>
</ol>
<a name="allowed_enc_level"></a><table border="1" class="docutils">
<colgroup>
<col width="39%" />
<col width="12%" />
<col width="49%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>allowed_enc_level</td>
<td>int</td>
<td>settings_pack::pe_both</td>
</tr>
</tbody>
</table>
<p>determines the encryption level of the connections. This setting
will adjust which encryption scheme is offered to the other peer,
as well as which encryption scheme is selected by the client. See
<a class="reference external" href="reference-Settings.html#enc_level">enc_level</a> enum for options.</p>
<a name="inactive_down_rate"></a>
<a name="inactive_up_rate"></a><table border="1" class="docutils">
<colgroup>
<col width="57%" />
<col width="17%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>inactive_down_rate</td>
<td>int</td>
<td>2048</td>
</tr>
<tr><td>inactive_up_rate</td>
<td>int</td>
<td>2048</td>
</tr>
</tbody>
</table>
<p>the download and upload rate limits for a torrent to be considered
active by the queuing mechanism. A torrent whose download rate is
less than <tt class="docutils literal">inactive_down_rate</tt> and whose upload rate is less than
<tt class="docutils literal">inactive_up_rate</tt> for <tt class="docutils literal">auto_manage_startup</tt> seconds, is
considered inactive, and another queued torrent may be started.
This logic is disabled if <tt class="docutils literal">dont_count_slow_torrents</tt> is false.</p>
<a name="proxy_type"></a><table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="15%" />
<col width="54%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>proxy_type</td>
<td>int</td>
<td>settings_pack::none</td>
</tr>
</tbody>
</table>
<p>proxy to use. see <a class="reference external" href="reference-Settings.html#proxy_type_t">proxy_type_t</a>.</p>
<a name="proxy_port"></a><table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="22%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>proxy_port</td>
<td>int</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>the port of the proxy server</p>
<a name="i2p_port"></a><table border="1" class="docutils">
<colgroup>
<col width="40%" />
<col width="24%" />
<col width="36%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>i2p_port</td>
<td>int</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>sets the <a class="reference external" href="http://www.i2p2.de">i2p</a> SAM bridge port to connect to. set the hostname with
the <tt class="docutils literal">i2p_hostname</tt> setting.</p>
<a name="urlseed_max_request_bytes"></a><table border="1" class="docutils">
<colgroup>
<col width="53%" />
<col width="12%" />
<col width="35%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>urlseed_max_request_bytes</td>
<td>int</td>
<td>16 * 1024 * 1024</td>
</tr>
</tbody>
</table>
<p>The maximum request range of an url seed in bytes. This value
defines the largest possible sequential web seed request. Lower values
are possible but will be ignored if they are lower then piece size.
This value should be related to your download speed to prevent
libtorrent from creating too many expensive http requests per
second. You can select a value as high as you want but keep in mind
that libtorrent can't create parallel requests if the first request
did already select the whole file.
If you combine bittorrent seeds with web seeds and pick strategies
like rarest first you may find your web seed requests split into
smaller parts because we don't download already picked pieces
twice.</p>
<a name="web_seed_name_lookup_retry"></a><table border="1" class="docutils">
<colgroup>
<col width="65%" />
<col width="14%" />
<col width="21%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>web_seed_name_lookup_retry</td>
<td>int</td>
<td>1800</td>
</tr>
</tbody>
</table>
<p>time to wait until a new retry of a web seed name lookup</p>
<a name="close_file_interval"></a><table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="13%" />
<col width="44%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>close_file_interval</td>
<td>int</td>
<td>CLOSE_FILE_INTERVAL</td>
</tr>
</tbody>
</table>
<p>the number of seconds between closing the file opened the longest
ago. 0 means to disable the feature. The purpose of this is to
periodically close files to trigger the operating system flushing
disk cache. Specifically it has been observed to be required on
windows to not have the disk cache grow indefinitely.
This defaults to 240 seconds on windows, and disabled on other
systems.</p>
<a name="utp_cwnd_reduce_timer"></a><table border="1" class="docutils">
<colgroup>
<col width="61%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>utp_cwnd_reduce_timer</td>
<td>int</td>
<td>100</td>
</tr>
</tbody>
</table>
<p>When uTP experiences packet loss, it will reduce the congestion
window, and not reduce it again for this many milliseconds, even if
experiencing another lost packet.</p>
<a name="max_web_seed_connections"></a><table border="1" class="docutils">
<colgroup>
<col width="63%" />
<col width="15%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>max_web_seed_connections</td>
<td>int</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>the max number of web seeds to have connected per torrent at any
given time.</p>
<a name="resolver_cache_timeout"></a><table border="1" class="docutils">
<colgroup>
<col width="62%" />
<col width="15%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>resolver_cache_timeout</td>
<td>int</td>
<td>1200</td>
</tr>
</tbody>
</table>
<p>the number of seconds before the internal host name resolver
considers a cache value timed out, negative values are interpreted
as zero.</p>
<a name="send_not_sent_low_watermark"></a><table border="1" class="docutils">
<colgroup>
<col width="66%" />
<col width="14%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>send_not_sent_low_watermark</td>
<td>int</td>
<td>16384</td>
</tr>
</tbody>
</table>
<p>specify the not-sent low watermark for socket send buffers. This
corresponds to the, Linux-specific, <tt class="docutils literal">TCP_NOTSENT_LOWAT</tt> TCP socket
option.</p>
<a name="rate_choker_initial_threshold"></a><table border="1" class="docutils">
<colgroup>
<col width="67%" />
<col width="13%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>rate_choker_initial_threshold</td>
<td>int</td>
<td>1024</td>
</tr>
</tbody>
</table>
<p>the rate based choker compares the upload rate to peers against a
threshold that increases proportionally by its size for every
peer it visits, visiting peers in decreasing upload rate. The
number of upload slots is determined by the number of peers whose
upload rate exceeds the threshold. This option sets the start
value for this threshold. A higher value leads to fewer unchoke
slots, a lower value leads to more.</p>
<a name="upnp_lease_duration"></a><table border="1" class="docutils">
<colgroup>
<col width="58%" />
<col width="17%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>upnp_lease_duration</td>
<td>int</td>
<td>3600</td>
</tr>
</tbody>
</table>
<p>The expiration time of UPnP port-mappings, specified in seconds. 0
means permanent lease. Some routers do not support expiration times
on port-maps (nor correctly returning an error indicating lack of
support). In those cases, set this to 0. Otherwise, don't set it any
lower than 5 minutes.</p>
<a name="max_concurrent_http_announces"></a><table border="1" class="docutils">
<colgroup>
<col width="67%" />
<col width="13%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>max_concurrent_http_announces</td>
<td>int</td>
<td>50</td>
</tr>
</tbody>
</table>
<p>limits the number of concurrent HTTP tracker announces. Once the
limit is hit, tracker requests are queued and issued when an
outstanding announce completes.</p>
<a name="dht_max_peers_reply"></a><table border="1" class="docutils">
<colgroup>
<col width="58%" />
<col width="17%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>dht_max_peers_reply</td>
<td>int</td>
<td>100</td>
</tr>
</tbody>
</table>
<p>the maximum number of peers to send in a reply to <tt class="docutils literal">get_peers</tt></p>
<a name="dht_search_branching"></a><table border="1" class="docutils">
<colgroup>
<col width="59%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>dht_search_branching</td>
<td>int</td>
<td>5</td>
</tr>
</tbody>
</table>
<p>the number of concurrent search request the node will send when
announcing and refreshing the routing table. This parameter is called
alpha in the kademlia paper</p>
<a name="dht_max_fail_count"></a><table border="1" class="docutils">
<colgroup>
<col width="57%" />
<col width="17%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>dht_max_fail_count</td>
<td>int</td>
<td>20</td>
</tr>
</tbody>
</table>
<p>the maximum number of failed tries to contact a node before it is
removed from the routing table. If there are known working nodes that
are ready to replace a failing node, it will be replaced immediately,
this limit is only used to clear out nodes that don't have any node
that can replace them.</p>
<a name="dht_max_torrents"></a><table border="1" class="docutils">
<colgroup>
<col width="55%" />
<col width="18%" />
<col width="27%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>dht_max_torrents</td>
<td>int</td>
<td>2000</td>
</tr>
</tbody>
</table>
<p>the total number of torrents to track from the DHT. This is simply an
upper limit to make sure malicious DHT nodes cannot make us allocate
an unbounded amount of memory.</p>
<a name="dht_max_dht_items"></a><table border="1" class="docutils">
<colgroup>
<col width="56%" />
<col width="18%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>dht_max_dht_items</td>
<td>int</td>
<td>700</td>
</tr>
</tbody>
</table>
<p>max number of items the DHT will store</p>
<a name="dht_max_peers"></a><table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="20%" />
<col width="30%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>dht_max_peers</td>
<td>int</td>
<td>500</td>
</tr>
</tbody>
</table>
<p>the max number of peers to store per torrent (for the DHT)</p>
<a name="dht_max_torrent_search_reply"></a><table border="1" class="docutils">
<colgroup>
<col width="67%" />
<col width="13%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>dht_max_torrent_search_reply</td>
<td>int</td>
<td>20</td>
</tr>
</tbody>
</table>
<p>the max number of torrents to return in a torrent search query to the
DHT</p>
<a name="dht_block_timeout"></a><table border="1" class="docutils">
<colgroup>
<col width="56%" />
<col width="18%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>dht_block_timeout</td>
<td>int</td>
<td>5 * 60</td>
</tr>
</tbody>
</table>
<p>the number of seconds a DHT node is banned if it exceeds the rate
limit. The rate limit is averaged over 10 seconds to allow for bursts
above the limit.</p>
<a name="dht_block_ratelimit"></a><table border="1" class="docutils">
<colgroup>
<col width="58%" />
<col width="17%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>dht_block_ratelimit</td>
<td>int</td>
<td>5</td>
</tr>
</tbody>
</table>
<p>the max number of packets per second a DHT node is allowed to send
without getting banned.</p>
<a name="dht_item_lifetime"></a><table border="1" class="docutils">
<colgroup>
<col width="56%" />
<col width="18%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>dht_item_lifetime</td>
<td>int</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>the number of seconds a immutable/mutable item will be expired.
default is 0, means never expires.</p>
<a name="dht_sample_infohashes_interval"></a><table border="1" class="docutils">
<colgroup>
<col width="68%" />
<col width="13%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>dht_sample_infohashes_interval</td>
<td>int</td>
<td>21600</td>
</tr>
</tbody>
</table>
<p>the info-hashes sample recomputation interval (in seconds).
The node will precompute a subset of the tracked info-hashes and return
that instead of calculating it upon each request. The permissible range
is between 0 and 21600 seconds (inclusive).</p>
<a name="dht_max_infohashes_sample_count"></a><table border="1" class="docutils">
<colgroup>
<col width="69%" />
<col width="13%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>dht_max_infohashes_sample_count</td>
<td>int</td>
<td>20</td>
</tr>
</tbody>
</table>
<p>the maximum number of elements in the sampled subset of info-hashes.
If this number is too big, expect the DHT storage implementations
to clamp it in order to allow UDP packets go through</p>
<a name="max_piece_count"></a><table border="1" class="docutils">
<colgroup>
<col width="52%" />
<col width="18%" />
<col width="30%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>max_piece_count</td>
<td>int</td>
<td>0x200000</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">max_piece_count</tt> is the maximum allowed number of pieces in
metadata received via magnet links. Loading large torrents (with
more pieces than the default limit) may also require passing in
a higher limit to <a class="reference external" href="reference-Resume_Data.html#read_resume_data()">read_resume_data()</a> and
<a class="reference external" href="reference-Torrent_Info.html#parse_info_section()">torrent_info::parse_info_section()</a>, if those are used.</p>
<a name="metadata_token_limit"></a><table border="1" class="docutils">
<colgroup>
<col width="59%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>metadata_token_limit</td>
<td>int</td>
<td>2500000</td>
</tr>
</tbody>
</table>
<p>when receiving metadata (torrent file) from peers, this is the
max number of bencoded tokens we're willing to parse. This limit
is meant to prevent DoS attacks on peers. For very large
torrents, this limit may have to be raised.</p>
<a name="disk_write_mode"></a><table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="8%" />
<col width="69%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>disk_write_mode</td>
<td>int</td>
<td>settings_pack::mmap_write_mode_t::auto_mmap_write</td>
</tr>
</tbody>
</table>
<p>controls whether disk writes will be made through a memory mapped
file or via normal write calls. This only affects the
mmap_disk_io. When saving to a non-local drive (network share,
NFS or NAS) using memory mapped files is most likely inferior.
When writing to a local SSD (especially in DAX mode) using memory
mapped files likely gives the best performance.
The values for this setting are specified as <a class="reference external" href="reference-Settings.html#mmap_write_mode_t">mmap_write_mode_t</a>.</p>
<a name="mmap_file_size_cutoff"></a><table border="1" class="docutils">
<colgroup>
<col width="61%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>mmap_file_size_cutoff</td>
<td>int</td>
<td>40</td>
</tr>
</tbody>
</table>
<p>when using mmap_disk_io, files smaller than this number of blocks
will not be memory mapped, but will use normal pread/pwrite
operations. This file size limit is specified in 16 kiB blocks.</p>
<a name="i2p_inbound_quantity"></a>
<a name="i2p_outbound_quantity"></a>
<a name="i2p_inbound_length"></a>
<a name="i2p_outbound_length"></a><table border="1" class="docutils">
<colgroup>
<col width="61%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>i2p_inbound_quantity</td>
<td>int</td>
<td>3</td>
</tr>
<tr><td>i2p_outbound_quantity</td>
<td>int</td>
<td>3</td>
</tr>
<tr><td>i2p_inbound_length</td>
<td>int</td>
<td>3</td>
</tr>
<tr><td>i2p_outbound_length</td>
<td>int</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>Configures the SAM <a class="reference external" href="reference-Session.html#session">session</a>
quantity of I2P inbound and outbound tunnels [1..16].
number of hops for I2P inbound and outbound tunnels [0..7]
Changing these will not trigger a reconnect to the SAM bridge,
they will take effect the next time the SAM connection is
re-established (by restarting or changing i2p_hostname or
i2p_port).</p>
<a name="announce_port"></a><table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="20%" />
<col width="30%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>announce_port</td>
<td>int</td>
<td>0</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">announce_port</tt> is the port passed along as the <tt class="docutils literal">port</tt> parameter
to remote trackers such as HTTP or DHT. This setting does not affect
the effective listening port nor local service discovery announcements.
If left as zero (default), the listening port value is used.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This setting is only meant for very special cases where a
seed's listening port differs from the external port. As an
example, if a local proxy is used and that the proxy supports
reverse tunnels through NAT-PMP, the tracker must connect to
the external NAT-PMP port (configured using <tt class="docutils literal">announce_port</tt>)
instead of the actual local listening port.</p>
</div>
<pre class="literal-block">
struct settings_pack final : settings_interface
{
   friend  void <strong>apply_pack_impl</strong> (settings_pack const*
      , aux::session_settings_single_thread&amp;
      , std::vector&lt;void(aux::session_impl::*)()&gt;*);
   void <strong>set_str</strong> (int name, std::string val) override;
   void <strong>set_bool</strong> (int name, bool val) override;
   void <strong>set_int</strong> (int name, int val) override;
   void <strong>set_int</strong> (int name, flags::bitfield_flag&lt;Type, Tag&gt; const val);
   bool <strong>has_val</strong> (int name) const override;
   void <strong>clear</strong> ();
   void <strong>clear</strong> (int name);
   int <strong>get_int</strong> (int name) const override;
   bool <strong>get_bool</strong> (int name) const override;
   std::string const&amp; <strong>get_str</strong> (int name) const override;
   void <strong>for_each</strong> (Fun&amp;&amp; f) const;

   enum type_bases
   {
      string_type_base,
      int_type_base,
      bool_type_base,
      type_mask,
      index_mask,
   };

   enum mmap_write_mode_t
   {
      always_pwrite,
      always_mmap_write,
      auto_mmap_write,
   };

   enum suggest_mode_t
   {
      no_piece_suggestions,
      suggest_read_cache,
   };

   enum choking_algorithm_t
   {
      fixed_slots_choker,
      rate_based_choker,
      deprecated_bittyrant_choker,
   };

   enum seed_choking_algorithm_t
   {
      round_robin,
      fastest_upload,
      anti_leech,
   };

   enum io_buffer_mode_t
   {
      enable_os_cache,
      deprecated_disable_os_cache_for_aligned_files,
      disable_os_cache,
      write_through,
   };

   enum bandwidth_mixed_algo_t
   {
      prefer_tcp,
      peer_proportional,
   };

   enum enc_policy
   {
      pe_forced,
      pe_enabled,
      pe_disabled,
   };

   enum enc_level
   {
      pe_plaintext,
      pe_rc4,
      pe_both,
   };

   enum proxy_type_t
   {
      none,
      socks4,
      socks5,
      socks5_pw,
      http,
      http_pw,
   };
};
</pre>
<a name="set_str()"></a>
<a name="set_bool()"></a>
<a name="set_int()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:settings_pack%3A%3A%5Bset_str%28%29+set_bool%28%29+set_int%28%29%5D&labels=documentation&body=Documentation+under+heading+%22settings_pack%3A%3A%5Bset_str%28%29+set_bool%28%29+set_int%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="set-str-set-bool-set-int">
<h2>set_str() set_bool() set_int()</h2>
<pre class="literal-block">
void <strong>set_str</strong> (int name, std::string val) override;
void <strong>set_bool</strong> (int name, bool val) override;
void <strong>set_int</strong> (int name, int val) override;
void <strong>set_int</strong> (int name, flags::bitfield_flag&lt;Type, Tag&gt; const val);
</pre>
<p>set a configuration option in the <a class="reference external" href="reference-Settings.html#settings_pack">settings_pack</a>. <tt class="docutils literal">name</tt> is one of
the enum values from string_types, int_types or bool_types. They must
match the respective type of the set_* function.</p>
<a name="has_val()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:settings_pack%3A%3A%5Bhas_val%28%29%5D&labels=documentation&body=Documentation+under+heading+%22settings_pack%3A%3A%5Bhas_val%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="has-val">
<h2>has_val()</h2>
<pre class="literal-block">
bool <strong>has_val</strong> (int name) const override;
</pre>
<p>queries whether the specified configuration option has a value set in
this pack. <tt class="docutils literal">name</tt> can be any enumeration value from string_types,
int_types or bool_types.</p>
<a name="clear()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:settings_pack%3A%3A%5Bclear%28%29%5D&labels=documentation&body=Documentation+under+heading+%22settings_pack%3A%3A%5Bclear%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="clear-1">
<h2>clear()</h2>
<pre class="literal-block">
void <strong>clear</strong> ();
</pre>
<p>clear the settings pack from all settings</p>
<a name="clear()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:settings_pack%3A%3A%5Bclear%28%29%5D&labels=documentation&body=Documentation+under+heading+%22settings_pack%3A%3A%5Bclear%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="clear-2">
<h2>clear()</h2>
<pre class="literal-block">
void <strong>clear</strong> (int name);
</pre>
<p>clear a specific setting from the pack</p>
<a name="get_bool()"></a>
<a name="get_int()"></a>
<a name="get_str()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:settings_pack%3A%3A%5Bget_bool%28%29+get_int%28%29+get_str%28%29%5D&labels=documentation&body=Documentation+under+heading+%22settings_pack%3A%3A%5Bget_bool%28%29+get_int%28%29+get_str%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="get-bool-get-int-get-str">
<h2>get_bool() get_int() get_str()</h2>
<pre class="literal-block">
int <strong>get_int</strong> (int name) const override;
bool <strong>get_bool</strong> (int name) const override;
std::string const&amp; <strong>get_str</strong> (int name) const override;
</pre>
<p>queries the current configuration option from the <a class="reference external" href="reference-Settings.html#settings_pack">settings_pack</a>.
<tt class="docutils literal">name</tt> is one of the enumeration values from string_types, int_types
or bool_types. The enum value must match the type of the get_*
function. If the specified setting field has not been set, the default
value is returned.</p>
<a name="type_bases"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+type_bases&labels=documentation&body=Documentation+under+heading+%22enum+type_bases%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-type-bases">
<h2>enum type_bases</h2>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/settings_pack.hpp">libtorrent/settings_pack.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="47%" />
<col width="18%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>string_type_base</td>
<td>0</td>
<td>&nbsp;</td>
</tr>
<tr><td>int_type_base</td>
<td>16384</td>
<td>&nbsp;</td>
</tr>
<tr><td>bool_type_base</td>
<td>32768</td>
<td>&nbsp;</td>
</tr>
<tr><td>type_mask</td>
<td>49152</td>
<td>&nbsp;</td>
</tr>
<tr><td>index_mask</td>
<td>16383</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<a name="mmap_write_mode_t"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+mmap_write_mode_t&labels=documentation&body=Documentation+under+heading+%22enum+mmap_write_mode_t%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-mmap-write-mode-t">
<h2>enum mmap_write_mode_t</h2>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/settings_pack.hpp">libtorrent/settings_pack.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="8%" />
<col width="71%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>always_pwrite</td>
<td>0</td>
<td>disable writing to disk via mmap, always use normal write calls</td>
</tr>
<tr><td>always_mmap_write</td>
<td>1</td>
<td>prefer using memory mapped files for disk writes (at least for
large files where it might make sense)</td>
</tr>
<tr><td>auto_mmap_write</td>
<td>2</td>
<td>determine whether to use pwrite or memory mapped files for disk
writes depending on the kind of storage behind the save path</td>
</tr>
</tbody>
</table>
<a name="suggest_mode_t"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+suggest_mode_t&labels=documentation&body=Documentation+under+heading+%22enum+suggest_mode_t%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-suggest-mode-t">
<h2>enum suggest_mode_t</h2>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/settings_pack.hpp">libtorrent/settings_pack.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="52%" />
<col width="17%" />
<col width="31%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>no_piece_suggestions</td>
<td>0</td>
<td>&nbsp;</td>
</tr>
<tr><td>suggest_read_cache</td>
<td>1</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<a name="choking_algorithm_t"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+choking_algorithm_t&labels=documentation&body=Documentation+under+heading+%22enum+choking_algorithm_t%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-choking-algorithm-t">
<h2>enum choking_algorithm_t</h2>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/settings_pack.hpp">libtorrent/settings_pack.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="7%" />
<col width="65%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>fixed_slots_choker</td>
<td>0</td>
<td>This is the traditional choker with a fixed number of unchoke
slots (as specified by <a class="reference external" href="reference-Settings.html#unchoke_slots_limit">settings_pack::unchoke_slots_limit</a>).</td>
</tr>
<tr><td>rate_based_choker</td>
<td>2</td>
<td><p class="first">This opens up unchoke slots based on the upload rate achieved to
peers. The more slots that are opened, the marginal upload rate
required to open up another slot increases. Configure the initial
threshold with <a class="reference external" href="reference-Settings.html#rate_choker_initial_threshold">settings_pack::rate_choker_initial_threshold</a>.</p>
<p class="last">For more information, see <a class="reference external" href="manual-ref.html#rate-based-choking">rate based choking</a>.</p>
</td>
</tr>
<tr><td>deprecated_bittyrant_choker</td>
<td>3</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<a name="seed_choking_algorithm_t"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+seed_choking_algorithm_t&labels=documentation&body=Documentation+under+heading+%22enum+seed_choking_algorithm_t%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-seed-choking-algorithm-t">
<h2>enum seed_choking_algorithm_t</h2>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/settings_pack.hpp">libtorrent/settings_pack.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="18%" />
<col width="8%" />
<col width="75%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>round_robin</td>
<td>0</td>
<td>which round-robins the peers that are unchoked
when seeding. This distributes the upload bandwidth uniformly and
fairly. It minimizes the ability for a peer to download everything
without redistributing it.</td>
</tr>
<tr><td>fastest_upload</td>
<td>1</td>
<td>unchokes the peers we can send to the fastest. This might be a
bit more reliable in utilizing all available capacity.</td>
</tr>
<tr><td>anti_leech</td>
<td>2</td>
<td>prioritizes peers who have just started or are
just about to finish the download. The intention is to force
peers in the middle of the download to trade with each other.
This does not just take into account the pieces a peer is
reporting having downloaded, but also the pieces we have sent
to it.</td>
</tr>
</tbody>
</table>
<a name="io_buffer_mode_t"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+io_buffer_mode_t&labels=documentation&body=Documentation+under+heading+%22enum+io_buffer_mode_t%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-io-buffer-mode-t">
<h2>enum io_buffer_mode_t</h2>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/settings_pack.hpp">libtorrent/settings_pack.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="70%" />
<col width="10%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>enable_os_cache</td>
<td>0</td>
<td>&nbsp;</td>
</tr>
<tr><td>deprecated_disable_os_cache_for_aligned_files</td>
<td>1</td>
<td>&nbsp;</td>
</tr>
<tr><td>disable_os_cache</td>
<td>2</td>
<td>&nbsp;</td>
</tr>
<tr><td>write_through</td>
<td>3</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<a name="bandwidth_mixed_algo_t"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+bandwidth_mixed_algo_t&labels=documentation&body=Documentation+under+heading+%22enum+bandwidth_mixed_algo_t%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-bandwidth-mixed-algo-t">
<h2>enum bandwidth_mixed_algo_t</h2>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/settings_pack.hpp">libtorrent/settings_pack.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="8%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>prefer_tcp</td>
<td>0</td>
<td>disables the mixed mode bandwidth balancing</td>
</tr>
<tr><td>peer_proportional</td>
<td>1</td>
<td>does not throttle uTP, throttles TCP to the same proportion
of throughput as there are TCP connections</td>
</tr>
</tbody>
</table>
<a name="enc_policy"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+enc_policy&labels=documentation&body=Documentation+under+heading+%22enum+enc_policy%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-enc-policy">
<h2>enum enc_policy</h2>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/settings_pack.hpp">libtorrent/settings_pack.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="15%" />
<col width="8%" />
<col width="78%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>pe_forced</td>
<td>0</td>
<td>Only encrypted connections are allowed. Incoming connections that
are not encrypted are closed and if the encrypted outgoing
connection fails, a non-encrypted retry will not be made.</td>
</tr>
<tr><td>pe_enabled</td>
<td>1</td>
<td>encrypted connections are enabled, but non-encrypted connections
are allowed. An incoming non-encrypted connection will be accepted,
and if an outgoing encrypted connection fails, a non- encrypted
connection will be tried.</td>
</tr>
<tr><td>pe_disabled</td>
<td>2</td>
<td>only non-encrypted connections are allowed.</td>
</tr>
</tbody>
</table>
<a name="enc_level"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+enc_level&labels=documentation&body=Documentation+under+heading+%22enum+enc_level%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-enc-level">
<h2>enum enc_level</h2>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/settings_pack.hpp">libtorrent/settings_pack.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="26%" />
<col width="13%" />
<col width="60%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>pe_plaintext</td>
<td>1</td>
<td>use only plain text encryption</td>
</tr>
<tr><td>pe_rc4</td>
<td>2</td>
<td>use only RC4 encryption</td>
</tr>
<tr><td>pe_both</td>
<td>3</td>
<td>allow both</td>
</tr>
</tbody>
</table>
<a name="proxy_type_t"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+proxy_type_t&labels=documentation&body=Documentation+under+heading+%22enum+proxy_type_t%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-proxy-type-t">
<h2>enum proxy_type_t</h2>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/settings_pack.hpp">libtorrent/settings_pack.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="7%" />
<col width="81%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>none</td>
<td>0</td>
<td>No proxy server is used and all other fields are ignored.</td>
</tr>
<tr><td>socks4</td>
<td>1</td>
<td>The server is assumed to be a <a class="reference external" href="http://www.ufasoft.com/doc/socks4_protocol.htm">SOCKS4 server</a> that requires a
username.</td>
</tr>
<tr><td>socks5</td>
<td>2</td>
<td>The server is assumed to be a SOCKS5 server (<a class="reference external" href="http://www.faqs.org/rfcs/rfc1928.html">RFC 1928</a>) that does
not require any authentication. The username and password are
ignored.</td>
</tr>
<tr><td>socks5_pw</td>
<td>3</td>
<td>The server is assumed to be a SOCKS5 server that supports plain
text username and password authentication (<a class="reference external" href="http://www.faqs.org/rfcs/rfc1929.html">RFC 1929</a>). The
username and password specified may be sent to the proxy if it
requires.</td>
</tr>
<tr><td>http</td>
<td>4</td>
<td>The server is assumed to be an HTTP proxy. If the transport used
for the connection is non-HTTP, the server is assumed to support
the <a class="reference external" href="http://tools.ietf.org/html/draft-luotonen-web-proxy-tunneling-01">CONNECT</a> method. i.e. for web seeds and HTTP trackers, a plain
proxy will suffice. The proxy is assumed to not require
authorization. The username and password will not be used.</td>
</tr>
<tr><td>http_pw</td>
<td>5</td>
<td>The server is assumed to be an HTTP proxy that requires user
authorization. The username and password will be sent to the proxy.</td>
</tr>
</tbody>
</table>
<a name="min_memory_usage()"></a>
<a name="high_performance_seed()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:min_memory_usage%28%29+high_performance_seed%28%29&labels=documentation&body=Documentation+under+heading+%22min_memory_usage%28%29+high_performance_seed%28%29%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="min-memory-usage-high-performance-seed">
<h1>min_memory_usage() high_performance_seed()</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/session.hpp">libtorrent/session.hpp</a>&quot;</p>
<pre class="literal-block">
settings_pack <strong>min_memory_usage</strong> ();
settings_pack <strong>high_performance_seed</strong> ();
</pre>
<p>The default values of the <a class="reference external" href="reference-Session.html#session">session</a> settings are set for a regular
bittorrent client running on a desktop system. There are functions that
can set the <a class="reference external" href="reference-Session.html#session">session</a> settings to pre set settings for other environments.
These can be used for the basis, and should be tweaked to fit your needs
better.</p>
<p><tt class="docutils literal">min_memory_usage</tt> returns settings that will use the minimal amount of
RAM, at the potential expense of upload and download performance. It
adjusts the socket buffer sizes, disables the disk cache, lowers the send
buffer watermarks so that each connection only has at most one block in
use at any one time. It lowers the outstanding blocks send to the disk
I/O thread so that connections only have one block waiting to be flushed
to disk at any given time. It lowers the max number of peers in the peer
list for torrents. It performs multiple smaller reads when it hashes
pieces, instead of reading it all into memory before hashing.</p>
<p>This configuration is intended to be the starting point for embedded
devices. It will significantly reduce memory usage.</p>
<p><tt class="docutils literal">high_performance_seed</tt> returns settings optimized for a seed box,
serving many peers and that doesn't do any downloading. It has a 128 MB
disk cache and has a limit of 400 files in its file pool. It support fast
upload rates by allowing large send buffers.</p>
<a name="setting_by_name()"></a>
<a name="name_for_setting()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:setting_by_name%28%29+name_for_setting%28%29&labels=documentation&body=Documentation+under+heading+%22setting_by_name%28%29+name_for_setting%28%29%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="setting-by-name-name-for-setting">
<h1>setting_by_name() name_for_setting()</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/settings_pack.hpp">libtorrent/settings_pack.hpp</a>&quot;</p>
<pre class="literal-block">
char const* <strong>name_for_setting</strong> (int s);
int <strong>setting_by_name</strong> (string_view name);
</pre>
<p>converts a setting integer (from the enums string_types, int_types or
bool_types) to a string, and vice versa.</p>
<a name="default_settings()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:default_settings%28%29&labels=documentation&body=Documentation+under+heading+%22default_settings%28%29%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="default-settings">
<h1>default_settings()</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/settings_pack.hpp">libtorrent/settings_pack.hpp</a>&quot;</p>
<pre class="literal-block">
settings_pack <strong>default_settings</strong> ();
</pre>
<p>returns a <a class="reference external" href="reference-Settings.html#settings_pack">settings_pack</a> with every setting set to its default value</p>
<a name="generate_fingerprint()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:generate_fingerprint%28%29&labels=documentation&body=Documentation+under+heading+%22generate_fingerprint%28%29%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="generate-fingerprint">
<h1>generate_fingerprint()</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/fingerprint.hpp">libtorrent/fingerprint.hpp</a>&quot;</p>
<pre class="literal-block">
std::string <strong>generate_fingerprint</strong> (std::string name
   , int major, int minor = 0, int revision = 0, int tag = 0);
</pre>
<p>This is a utility function to produce a client ID fingerprint formatted to
the most common convention. The fingerprint can be set via the
<tt class="docutils literal">peer_fingerprint</tt> setting, in <a class="reference external" href="reference-Settings.html#settings_pack">settings_pack</a>.</p>
<p>The name string should contain exactly two characters. These are the
characters unique to your client, used to identify it. Make sure not to
clash with anybody else. Here are some taken id's:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">id chars</th>
<th class="head">client</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>LT</td>
<td>libtorrent (default)</td>
</tr>
<tr><td>UT</td>
<td>uTorrent</td>
</tr>
<tr><td>UM</td>
<td>uTorrent Mac</td>
</tr>
<tr><td>qB</td>
<td>qBittorrent</td>
</tr>
<tr><td>BP</td>
<td>BitTorrent Pro</td>
</tr>
<tr><td>BT</td>
<td>BitTorrent</td>
</tr>
<tr><td>DE</td>
<td>Deluge</td>
</tr>
<tr><td>AZ</td>
<td>Azureus</td>
</tr>
<tr><td>TL</td>
<td>Tribler</td>
</tr>
</tbody>
</table>
<p>There's an informal directory of client id's <a class="reference external" href="http://wiki.theory.org/BitTorrentSpecification#peer_id">here</a>.</p>
<p>The <tt class="docutils literal">major</tt>, <tt class="docutils literal">minor</tt>, <tt class="docutils literal">revision</tt> and <tt class="docutils literal">tag</tt> parameters are used to
identify the version of your client.</p>
<a name="torrent_status"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+torrent_status&labels=documentation&body=Documentation+under+heading+%22class+torrent_status%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="torrent-status">
<h1>torrent_status</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/torrent_status.hpp">libtorrent/torrent_status.hpp</a>&quot;</p>
<p>holds a snapshot of the status of a torrent, as queried by
<a class="reference external" href="reference-Torrent_Handle.html#status()">torrent_handle::status()</a>.</p>
<pre class="literal-block">
struct torrent_status
{
   bool <strong>operator==</strong> (torrent_status const&amp; st) const;

   enum state_t
   {
      checking_files,
      downloading_metadata,
      downloading,
      finished,
      seeding,
      unused_enum_for_backwards_compatibility_allocating,
      checking_resume_data,
   };

   torrent_handle handle;
   error_code errc;
   file_index_t <strong>error_file</strong>  = torrent_status::error_file_none;
   static constexpr file_index_t <strong>error_file_none</strong> {-1};
   static constexpr file_index_t <strong>error_file_ssl_ctx</strong> {-3};
   static constexpr file_index_t <strong>error_file_metadata</strong> {-4};
   static constexpr file_index_t <strong>error_file_exception</strong> {-5};
   static constexpr file_index_t <strong>error_file_partfile</strong> {-6};
   std::string save_path;
   std::string name;
   std::weak_ptr&lt;const torrent_info&gt; torrent_file;
   time_duration <strong>next_announce</strong>  = seconds{0};
   std::string current_tracker;
   std::int64_t <strong>total_download</strong>  = 0;
   std::int64_t <strong>total_upload</strong>  = 0;
   std::int64_t <strong>total_payload_download</strong>  = 0;
   std::int64_t <strong>total_payload_upload</strong>  = 0;
   std::int64_t <strong>total_failed_bytes</strong>  = 0;
   std::int64_t <strong>total_redundant_bytes</strong>  = 0;
   typed_bitfield&lt;piece_index_t&gt; pieces;
   typed_bitfield&lt;piece_index_t&gt; verified_pieces;
   std::int64_t <strong>total_done</strong>  = 0;
   std::int64_t <strong>total</strong>  = 0;
   std::int64_t <strong>total_wanted_done</strong>  = 0;
   std::int64_t <strong>total_wanted</strong>  = 0;
   std::int64_t <strong>all_time_upload</strong>  = 0;
   std::int64_t <strong>all_time_download</strong>  = 0;
   std::time_t <strong>added_time</strong>  = 0;
   std::time_t <strong>completed_time</strong>  = 0;
   std::time_t <strong>last_seen_complete</strong>  = 0;
   storage_mode_t <strong>storage_mode</strong>  = storage_mode_sparse;
   float <strong>progress</strong>  = 0.f;
   int <strong>progress_ppm</strong>  = 0;
   queue_position_t <strong>queue_position</strong> {};
   int <strong>download_rate</strong>  = 0;
   int <strong>upload_rate</strong>  = 0;
   int <strong>download_payload_rate</strong>  = 0;
   int <strong>upload_payload_rate</strong>  = 0;
   int <strong>num_seeds</strong>  = 0;
   int <strong>num_peers</strong>  = 0;
   int <strong>num_complete</strong>  = -1;
   int <strong>num_incomplete</strong>  = -1;
   int <strong>list_seeds</strong>  = 0;
   int <strong>list_peers</strong>  = 0;
   int <strong>connect_candidates</strong>  = 0;
   int <strong>num_pieces</strong>  = 0;
   int <strong>distributed_full_copies</strong>  = 0;
   int <strong>distributed_fraction</strong>  = 0;
   float <strong>distributed_copies</strong>  = 0.f;
   int <strong>block_size</strong>  = 0;
   int <strong>num_uploads</strong>  = 0;
   int <strong>num_connections</strong>  = 0;
   int <strong>uploads_limit</strong>  = 0;
   int <strong>connections_limit</strong>  = 0;
   int <strong>up_bandwidth_queue</strong>  = 0;
   int <strong>down_bandwidth_queue</strong>  = 0;
   int <strong>seed_rank</strong>  = 0;
   state_t <strong>state</strong>  = checking_resume_data;
   bool <strong>need_save_resume</strong>  = false;
   bool <strong>is_seeding</strong>  = false;
   bool <strong>is_finished</strong>  = false;
   bool <strong>has_metadata</strong>  = false;
   bool <strong>has_incoming</strong>  = false;
   bool <strong>moving_storage</strong>  = false;
   bool <strong>announcing_to_trackers</strong>  = false;
   bool <strong>announcing_to_lsd</strong>  = false;
   bool <strong>announcing_to_dht</strong>  = false;
   info_hash_t info_hashes;
   time_point last_upload;
   time_point last_download;
   seconds active_duration;
   seconds finished_duration;
   seconds seeding_duration;
   torrent_flags_t <strong>flags</strong> {};
};
</pre>
<a name="operator==()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Boperator%3D%3D%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Boperator%3D%3D%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="operator-4">
<h2>operator==()</h2>
<pre class="literal-block">
bool <strong>operator==</strong> (torrent_status const&amp; st) const;
</pre>
<p>compares if the torrent status objects come from the same torrent. i.e.
only the <a class="reference external" href="reference-Torrent_Handle.html#torrent_handle">torrent_handle</a> field is compared.</p>
<a name="state_t"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+state_t&labels=documentation&body=Documentation+under+heading+%22enum+state_t%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-state-t">
<h2>enum state_t</h2>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/torrent_status.hpp">libtorrent/torrent_status.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="6%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>checking_files</td>
<td>1</td>
<td>The torrent has not started its download yet, and is
currently checking existing files.</td>
</tr>
<tr><td>downloading_metadata</td>
<td>2</td>
<td>The torrent is trying to download metadata from peers.
This implies the ut_metadata extension is in use.</td>
</tr>
<tr><td>downloading</td>
<td>3</td>
<td>The torrent is being downloaded. This is the state
most torrents will be in most of the time. The progress
meter will tell how much of the files that has been
downloaded.</td>
</tr>
<tr><td>finished</td>
<td>4</td>
<td>In this state the torrent has finished downloading but
still doesn't have the entire torrent. i.e. some pieces
are filtered and won't get downloaded.</td>
</tr>
<tr><td>seeding</td>
<td>5</td>
<td>In this state the torrent has finished downloading and
is a pure seeder.</td>
</tr>
<tr><td>unused_enum_for_backwards_compatibility_allocating</td>
<td>6</td>
<td>If the torrent was started in full allocation mode, this
indicates that the (disk) storage for the torrent is
allocated.</td>
</tr>
<tr><td>checking_resume_data</td>
<td>7</td>
<td>The torrent is currently checking the fast resume data and
comparing it to the files on disk. This is typically
completed in a fraction of a second, but if you add a
large number of torrents at once, they will queue up.</td>
</tr>
</tbody>
</table>
<a name="handle"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bhandle%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bhandle%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>handle</dt>
<dd>a handle to the torrent whose status the object represents.</dd>
</dl>
<a name="errc"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Berrc%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Berrc%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>errc</dt>
<dd>may be set to an error code describing why the torrent was paused, in
case it was paused by an error. If the torrent is not paused or if it's
paused but not because of an error, this error_code is not set.
if the error is attributed specifically to a file, error_file is set to
the index of that file in the .torrent file.</dd>
</dl>
<a name="error_file"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Berror_file%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Berror_file%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>error_file</dt>
<dd>if the torrent is stopped because of an disk I/O error, this field
contains the index of the file in the torrent that encountered the
error. If the error did not originate in a file in the torrent, there
are a few special values this can be set to: error_file_none,
error_file_ssl_ctx, error_file_exception, error_file_partfile or
error_file_metadata;</dd>
</dl>
<a name="error_file_none"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Berror_file_none%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Berror_file_none%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>error_file_none</dt>
<dd>special values for error_file to describe which file or component
encountered the error (<tt class="docutils literal">errc</tt>).
the error did not occur on a file</dd>
</dl>
<a name="error_file_ssl_ctx"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Berror_file_ssl_ctx%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Berror_file_ssl_ctx%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>error_file_ssl_ctx</dt>
<dd>the error occurred setting up the SSL context</dd>
</dl>
<a name="error_file_metadata"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Berror_file_metadata%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Berror_file_metadata%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>error_file_metadata</dt>
<dd>the error occurred while loading the metadata for the torrent</dd>
</dl>
<a name="error_file_exception"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Berror_file_exception%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Berror_file_exception%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>error_file_exception</dt>
<dd>there was a serious error reported in this torrent. The error code
or a torrent log <a class="reference external" href="reference-Alerts.html#alert">alert</a> may provide more information.</dd>
</dl>
<a name="error_file_partfile"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Berror_file_partfile%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Berror_file_partfile%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>error_file_partfile</dt>
<dd>the error occurred with the partfile</dd>
</dl>
<a name="save_path"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bsave_path%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bsave_path%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>save_path</dt>
<dd>the path to the directory where this torrent's files are stored.
It's typically the path as was given to <a class="reference external" href="reference-Session.html#async_add_torrent()">async_add_torrent()</a> or
<a class="reference external" href="reference-Session.html#add_torrent()">add_torrent()</a> when this torrent was started. This field is only
included if the torrent status is queried with
<tt class="docutils literal"><span class="pre">torrent_handle::query_save_path</span></tt>.</dd>
</dl>
<a name="name"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bname%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bname%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>name</dt>
<dd>the name of the torrent. Typically this is derived from the
.torrent file. In case the torrent was started without metadata,
and hasn't completely received it yet, it returns the name given
to it when added to the <a class="reference external" href="reference-Session.html#session">session</a>. See <tt class="docutils literal"><span class="pre">session::add_torrent</span></tt>.
This field is only included if the torrent status is queried
with <tt class="docutils literal"><span class="pre">torrent_handle::query_name</span></tt>.</dd>
</dl>
<a name="torrent_file"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Btorrent_file%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Btorrent_file%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>torrent_file</dt>
<dd>set to point to the <tt class="docutils literal">torrent_info</tt> object for this torrent. It's
only included if the torrent status is queried with
<tt class="docutils literal"><span class="pre">torrent_handle::query_torrent_file</span></tt>.</dd>
</dl>
<a name="next_announce"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bnext_announce%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bnext_announce%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>next_announce</dt>
<dd>the time until the torrent will announce itself to the tracker.</dd>
</dl>
<a name="current_tracker"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bcurrent_tracker%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bcurrent_tracker%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>current_tracker</dt>
<dd>the URL of the last working tracker. If no tracker request has
been successful yet, it's set to an empty string.</dd>
</dl>
<a name="total_download"></a>
<a name="total_upload"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Btotal_download+total_upload%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Btotal_download+total_upload%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>total_download total_upload</dt>
<dd>the number of bytes downloaded and uploaded to all peers, accumulated,
<em>this session</em> only. The <a class="reference external" href="reference-Session.html#session">session</a> is considered to restart when a
torrent is paused and restarted again. When a torrent is paused, these
<a class="reference external" href="reference-Stats.html#counters">counters</a> are reset to 0. If you want complete, persistent, stats, see
<tt class="docutils literal">all_time_upload</tt> and <tt class="docutils literal">all_time_download</tt>.</dd>
</dl>
<a name="total_payload_download"></a>
<a name="total_payload_upload"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Btotal_payload_download+total_payload_upload%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Btotal_payload_download+total_payload_upload%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>total_payload_download total_payload_upload</dt>
<dd>counts the amount of bytes send and received this <a class="reference external" href="reference-Session.html#session">session</a>, but only
the actual payload data (i.e the interesting data), these <a class="reference external" href="reference-Stats.html#counters">counters</a>
ignore any protocol overhead. The <a class="reference external" href="reference-Session.html#session">session</a> is considered to restart
when a torrent is paused and restarted again. When a torrent is
paused, these <a class="reference external" href="reference-Stats.html#counters">counters</a> are reset to 0.</dd>
</dl>
<a name="total_failed_bytes"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Btotal_failed_bytes%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Btotal_failed_bytes%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>total_failed_bytes</dt>
<dd>the number of bytes that has been downloaded and that has failed the
piece hash test. In other words, this is just how much crap that has
been downloaded since the torrent was last started. If a torrent is
paused and then restarted again, this counter will be reset.</dd>
</dl>
<a name="total_redundant_bytes"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Btotal_redundant_bytes%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Btotal_redundant_bytes%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>total_redundant_bytes</dt>
<dd>the number of bytes that has been downloaded even though that data
already was downloaded. The reason for this is that in some situations
the same data can be downloaded by mistake. When libtorrent sends
requests to a peer, and the peer doesn't send a response within a
certain timeout, libtorrent will re-request that block. Another
situation when libtorrent may re-request blocks is when the requests
it sends out are not replied in FIFO-order (it will re-request blocks
that are skipped by an out of order block). This is supposed to be as
low as possible. This only counts bytes since the torrent was last
started. If a torrent is paused and then restarted again, this counter
will be reset.</dd>
</dl>
<a name="pieces"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bpieces%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bpieces%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>pieces</dt>
<dd>a bitmask that represents which pieces we have (set to true) and the
pieces we don't have. It's a pointer and may be set to 0 if the
torrent isn't downloading or seeding.</dd>
</dl>
<a name="verified_pieces"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bverified_pieces%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bverified_pieces%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>verified_pieces</dt>
<dd>a bitmask representing which pieces has had their hash checked. This
only applies to torrents in <em>seed mode</em>. If the torrent is not in seed
mode, this bitmask may be empty.</dd>
</dl>
<a name="total_done"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Btotal_done%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Btotal_done%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>total_done</dt>
<dd>the total number of bytes of the file(s) that we have. All this does
not necessarily has to be downloaded during this <a class="reference external" href="reference-Session.html#session">session</a> (that's
<tt class="docutils literal">total_payload_download</tt>).</dd>
</dl>
<a name="total"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Btotal%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Btotal%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>total</dt>
<dd>the total number of bytes to download for this torrent. This
may be less than the size of the torrent in case there are
pad files. This number only counts bytes that will actually
be requested from peers.</dd>
</dl>
<a name="total_wanted_done"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Btotal_wanted_done%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Btotal_wanted_done%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>total_wanted_done</dt>
<dd>the number of bytes we have downloaded, only counting the pieces that
we actually want to download. i.e. excluding any pieces that we have
but have priority 0 (i.e. not wanted).
Once a torrent becomes seed, any piece- and file priorities are
forgotten and all bytes are considered &quot;wanted&quot;.</dd>
</dl>
<a name="total_wanted"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Btotal_wanted%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Btotal_wanted%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>total_wanted</dt>
<dd>The total number of bytes we want to download. This may be smaller
than the total torrent size in case any pieces are prioritized to 0,
i.e.  not wanted.
Once a torrent becomes seed, any piece- and file priorities are
forgotten and all bytes are considered &quot;wanted&quot;.</dd>
</dl>
<a name="all_time_upload"></a>
<a name="all_time_download"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Ball_time_upload+all_time_download%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Ball_time_upload+all_time_download%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>all_time_upload all_time_download</dt>
<dd>are accumulated upload and download payload byte <a class="reference external" href="reference-Stats.html#counters">counters</a>. They are
saved in and restored from resume data to keep totals across sessions.</dd>
</dl>
<a name="added_time"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Badded_time%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Badded_time%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>added_time</dt>
<dd>the posix-time when this torrent was added. i.e. what <tt class="docutils literal">time(nullptr)</tt>
returned at the time.</dd>
</dl>
<a name="completed_time"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bcompleted_time%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bcompleted_time%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>completed_time</dt>
<dd>the posix-time when this torrent was finished. If the torrent is not
yet finished, this is 0.</dd>
</dl>
<a name="last_seen_complete"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Blast_seen_complete%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Blast_seen_complete%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>last_seen_complete</dt>
<dd>the time when we, or one of our peers, last saw a complete copy of
this torrent.</dd>
</dl>
<a name="storage_mode"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bstorage_mode%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bstorage_mode%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>storage_mode</dt>
<dd>The allocation mode for the torrent. See <a class="reference external" href="reference-Storage.html#storage_mode_t">storage_mode_t</a> for the
options. For more information, see <a class="reference external" href="manual-ref.html#storage-allocation">storage allocation</a>.</dd>
</dl>
<a name="progress"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bprogress%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bprogress%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>progress</dt>
<dd>a value in the range [0, 1], that represents the progress of the
torrent's current task. It may be checking files or downloading.</dd>
</dl>
<a name="progress_ppm"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bprogress_ppm%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bprogress_ppm%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>progress_ppm</dt>
<dd><p class="first">progress parts per million (progress * 1000000) when disabling
floating point operations, this is the only option to query progress</p>
<p class="last">reflects the same value as <tt class="docutils literal">progress</tt>, but instead in a range [0,
1000000] (ppm = parts per million). When floating point operations are
disabled, this is the only alternative to the floating point value in
progress.</p>
</dd>
</dl>
<a name="queue_position"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bqueue_position%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bqueue_position%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>queue_position</dt>
<dd>the position this torrent has in the download
queue. If the torrent is a seed or finished, this is -1.</dd>
</dl>
<a name="download_rate"></a>
<a name="upload_rate"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bdownload_rate+upload_rate%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bdownload_rate+upload_rate%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>download_rate upload_rate</dt>
<dd>the total rates for all peers for this torrent. These will usually
have better precision than summing the rates from all peers. The rates
are given as the number of bytes per second.</dd>
</dl>
<a name="download_payload_rate"></a>
<a name="upload_payload_rate"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bdownload_payload_rate+upload_payload_rate%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bdownload_payload_rate+upload_payload_rate%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>download_payload_rate upload_payload_rate</dt>
<dd>the total transfer rate of payload only, not counting protocol
chatter. This might be slightly smaller than the other rates, but if
projected over a long time (e.g. when calculating ETA:s) the
difference may be noticeable.</dd>
</dl>
<a name="num_seeds"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bnum_seeds%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bnum_seeds%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>num_seeds</dt>
<dd>the number of peers that are seeding that this client is
currently connected to.</dd>
</dl>
<a name="num_peers"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bnum_peers%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bnum_peers%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>num_peers</dt>
<dd>the number of peers this torrent currently is connected to. Peer
connections that are in the half-open state (is attempting to connect)
or are queued for later connection attempt do not count. Although they
are visible in the peer list when you call <a class="reference external" href="reference-Torrent_Handle.html#get_peer_info()">get_peer_info()</a>.</dd>
</dl>
<a name="num_complete"></a>
<a name="num_incomplete"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bnum_complete+num_incomplete%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bnum_complete+num_incomplete%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>num_complete num_incomplete</dt>
<dd>if the tracker sends scrape info in its announce reply, these fields
will be set to the total number of peers that have the whole file and
the total number of peers that are still downloading. set to -1 if the
tracker did not send any scrape data in its announce reply.</dd>
</dl>
<a name="list_seeds"></a>
<a name="list_peers"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Blist_seeds+list_peers%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Blist_seeds+list_peers%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>list_seeds list_peers</dt>
<dd>the number of seeds in our peer list and the total number of peers
(including seeds). We are not necessarily connected to all the peers
in our peer list. This is the number of peers we know of in total,
including banned peers and peers that we have failed to connect to.</dd>
</dl>
<a name="connect_candidates"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bconnect_candidates%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bconnect_candidates%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>connect_candidates</dt>
<dd>the number of peers in this torrent's peer list that is a candidate to
be connected to. i.e. It has fewer connect attempts than the max fail
count, it is not a seed if we are a seed, it is not banned etc. If
this is 0, it means we don't know of any more peers that we can try.</dd>
</dl>
<a name="num_pieces"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bnum_pieces%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bnum_pieces%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>num_pieces</dt>
<dd>the number of pieces that has been downloaded. It is equivalent to:
<tt class="docutils literal"><span class="pre">std::accumulate(pieces-&gt;begin(),</span> <span class="pre">pieces-&gt;end())</span></tt>. So you don't have
to count yourself. This can be used to see if anything has updated
since last time if you want to keep a graph of the pieces up to date.
Note that these pieces have not necessarily been written to disk yet,
and there is a risk the write to disk will fail.</dd>
</dl>
<a name="distributed_full_copies"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bdistributed_full_copies%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bdistributed_full_copies%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>distributed_full_copies</dt>
<dd>the number of distributed copies of the torrent. Note that one copy
may be spread out among many peers. It tells how many copies there are
currently of the rarest piece(s) among the peers this client is
connected to.</dd>
</dl>
<a name="distributed_fraction"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bdistributed_fraction%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bdistributed_fraction%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>distributed_fraction</dt>
<dd><p class="first">tells the share of pieces that have more copies than the rarest
piece(s). Divide this number by 1000 to get the fraction.</p>
<p>For example, if <tt class="docutils literal">distributed_full_copies</tt> is 2 and
<tt class="docutils literal">distributed_fraction</tt> is 500, it means that the rarest pieces have
only 2 copies among the peers this torrent is connected to, and that
50% of all the pieces have more than two copies.</p>
<p class="last">If we are a seed, the piece picker is deallocated as an optimization,
and piece availability is no longer tracked. In this case the
distributed copies members are set to -1.</p>
</dd>
</dl>
<a name="distributed_copies"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bdistributed_copies%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bdistributed_copies%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>distributed_copies</dt>
<dd><p class="first">the number of distributed copies of the file. note that one copy may
be spread out among many peers. This is a floating point
representation of the distributed copies.</p>
<dl class="last docutils">
<dt>the integer part tells how many copies</dt>
<dd>there are of the rarest piece(s)</dd>
<dt>the fractional part tells the fraction of pieces that</dt>
<dd>have more copies than the rarest piece(s).</dd>
</dl>
</dd>
</dl>
<a name="block_size"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bblock_size%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bblock_size%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>block_size</dt>
<dd>the size of a block, in bytes. A block is a sub piece, it is the
number of bytes that each piece request asks for and the number of
bytes that each bit in the <tt class="docutils literal">partial_piece_info</tt>'s bitset represents,
see <a class="reference external" href="reference-Torrent_Handle.html#get_download_queue()">get_download_queue()</a>. This is typically 16 kB, but it may be
smaller, if the pieces are smaller.</dd>
</dl>
<a name="num_uploads"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bnum_uploads%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bnum_uploads%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>num_uploads</dt>
<dd>the number of unchoked peers in this torrent.</dd>
</dl>
<a name="num_connections"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bnum_connections%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bnum_connections%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>num_connections</dt>
<dd>the number of peer connections this torrent has, including half-open
connections that hasn't completed the bittorrent handshake yet. This
is always &gt;= <tt class="docutils literal">num_peers</tt>.</dd>
</dl>
<a name="uploads_limit"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Buploads_limit%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Buploads_limit%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>uploads_limit</dt>
<dd>the set limit of upload slots (unchoked peers) for this torrent.</dd>
</dl>
<a name="connections_limit"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bconnections_limit%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bconnections_limit%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>connections_limit</dt>
<dd>the set limit of number of connections for this torrent.</dd>
</dl>
<a name="up_bandwidth_queue"></a>
<a name="down_bandwidth_queue"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bup_bandwidth_queue+down_bandwidth_queue%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bup_bandwidth_queue+down_bandwidth_queue%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>up_bandwidth_queue down_bandwidth_queue</dt>
<dd>the number of peers in this torrent that are waiting for more
bandwidth quota from the torrent rate limiter. This can determine if
the rate you get from this torrent is bound by the torrents limit or
not. If there is no limit set on this torrent, the peers might still
be waiting for bandwidth quota from the global limiter, but then they
are counted in the <tt class="docutils literal">session_status</tt> object.</dd>
</dl>
<a name="seed_rank"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bseed_rank%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bseed_rank%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>seed_rank</dt>
<dd>A rank of how important it is to seed the torrent, it is used to
determine which torrents to seed and which to queue. It is based on
the peer to seed ratio from the tracker scrape. For more information,
see <a class="reference external" href="manual-ref.html#queuing">queuing</a>. Higher value means more important to seed</dd>
</dl>
<a name="state"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bstate%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bstate%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>state</dt>
<dd>the main state the torrent is in. See <a class="reference external" href="reference-Torrent_Status.html#state_t">torrent_status::state_t</a>.</dd>
</dl>
<a name="need_save_resume"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bneed_save_resume%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bneed_save_resume%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>need_save_resume</dt>
<dd>true if this torrent has unsaved changes
to its download state and statistics since the last resume data
was saved.</dd>
</dl>
<a name="is_seeding"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bis_seeding%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bis_seeding%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>is_seeding</dt>
<dd>true if all pieces have been downloaded.</dd>
</dl>
<a name="is_finished"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bis_finished%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bis_finished%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>is_finished</dt>
<dd>true if all pieces that have a priority &gt; 0 are downloaded. There is
only a distinction between finished and seeding if some pieces or
files have been set to priority 0, i.e. are not downloaded.</dd>
</dl>
<a name="has_metadata"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bhas_metadata%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bhas_metadata%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>has_metadata</dt>
<dd>true if this torrent has metadata (either it was started from a
.torrent file or the metadata has been downloaded). The only scenario
where this can be false is when the torrent was started torrent-less
(i.e. with just an info-hash and tracker ip, a magnet link for
instance).</dd>
</dl>
<a name="has_incoming"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bhas_incoming%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bhas_incoming%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>has_incoming</dt>
<dd>true if there has ever been an incoming connection attempt to this
torrent.</dd>
</dl>
<a name="moving_storage"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bmoving_storage%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bmoving_storage%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>moving_storage</dt>
<dd>this is true if this torrent's storage is currently being moved from
one location to another. This may potentially be a long operation
if a large file ends up being copied from one drive to another.</dd>
</dl>
<a name="announcing_to_trackers"></a>
<a name="announcing_to_lsd"></a>
<a name="announcing_to_dht"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bannouncing_to_trackers+announcing_to_lsd+announcing_to_dht%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bannouncing_to_trackers+announcing_to_lsd+announcing_to_dht%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>announcing_to_trackers announcing_to_lsd announcing_to_dht</dt>
<dd>these are set to true if this torrent is allowed to announce to the
respective peer source. Whether they are true or false is determined by
the queue logic/auto manager. Torrents that are not auto managed will
always be allowed to announce to all peer sources.</dd>
</dl>
<a name="info_hashes"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Binfo_hashes%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Binfo_hashes%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>info_hashes</dt>
<dd>the info-hash for this torrent</dd>
</dl>
<a name="last_upload"></a>
<a name="last_download"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Blast_upload+last_download%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Blast_upload+last_download%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>last_upload last_download</dt>
<dd>the timestamps of the last time this torrent uploaded or downloaded
payload to any peer.</dd>
</dl>
<a name="active_duration"></a>
<a name="finished_duration"></a>
<a name="seeding_duration"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bactive_duration+finished_duration+seeding_duration%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bactive_duration+finished_duration+seeding_duration%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>active_duration finished_duration seeding_duration</dt>
<dd>these are cumulative <a class="reference external" href="reference-Stats.html#counters">counters</a> of for how long the torrent has been in
different states. active means not paused and added to <a class="reference external" href="reference-Session.html#session">session</a>. Whether
it has found any peers or not is not relevant.
finished means all selected files/pieces were downloaded and available
to other peers (this is always a subset of active time).
seeding means all files/pieces were downloaded and available to
peers. Being available to peers does not imply there are other peers
asking for the payload.</dd>
</dl>
<a name="flags"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bflags%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bflags%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>flags</dt>
<dd>reflects several of the torrent's flags. For more
information, see <tt class="docutils literal"><span class="pre">torrent_handle::flags()</span></tt>.</dd>
</dl>
<a name="announce_infohash"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+announce_infohash&labels=documentation&body=Documentation+under+heading+%22class+announce_infohash%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="announce-infohash">
<h1>announce_infohash</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/announce_entry.hpp">libtorrent/announce_entry.hpp</a>&quot;</p>
<pre class="literal-block">
struct announce_infohash
{
   std::string message;
   error_code last_error;
   int <strong>scrape_incomplete</strong>  = -1;
   int <strong>scrape_complete</strong>  = -1;
   int <strong>scrape_downloaded</strong>  = -1;
   std::uint8_t fails : 7;
   bool updating : 1;
   bool start_sent : 1;
   bool complete_sent : 1;
};
</pre>
<a name="message"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:announce_infohash%3A%3A%5Bmessage%5D&labels=documentation&body=Documentation+under+heading+%22announce_infohash%3A%3A%5Bmessage%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>message</dt>
<dd>if this tracker has returned an error or warning message
that message is stored here</dd>
</dl>
<a name="last_error"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:announce_infohash%3A%3A%5Blast_error%5D&labels=documentation&body=Documentation+under+heading+%22announce_infohash%3A%3A%5Blast_error%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>last_error</dt>
<dd>if this tracker failed the last time it was contacted
this error code specifies what error occurred</dd>
</dl>
<a name="scrape_incomplete"></a>
<a name="scrape_complete"></a>
<a name="scrape_downloaded"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:announce_infohash%3A%3A%5Bscrape_incomplete+scrape_complete+scrape_downloaded%5D&labels=documentation&body=Documentation+under+heading+%22announce_infohash%3A%3A%5Bscrape_incomplete+scrape_complete+scrape_downloaded%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>scrape_incomplete scrape_complete scrape_downloaded</dt>
<dd>if this tracker has returned scrape data, these fields are filled in
with valid numbers. Otherwise they are set to -1. <tt class="docutils literal">incomplete</tt> counts
the number of current downloaders. <tt class="docutils literal">complete</tt> counts the number of
current peers completed the download, or &quot;seeds&quot;. <tt class="docutils literal">downloaded</tt> is the
cumulative number of completed downloads.</dd>
</dl>
<a name="fails"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:announce_infohash%3A%3A%5Bfails%5D&labels=documentation&body=Documentation+under+heading+%22announce_infohash%3A%3A%5Bfails%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>fails</dt>
<dd>the number of times in a row we have failed to announce to this
tracker.</dd>
</dl>
<a name="updating"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:announce_infohash%3A%3A%5Bupdating%5D&labels=documentation&body=Documentation+under+heading+%22announce_infohash%3A%3A%5Bupdating%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>updating</dt>
<dd>true while we're waiting for a response from the tracker.</dd>
</dl>
<a name="start_sent"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:announce_infohash%3A%3A%5Bstart_sent%5D&labels=documentation&body=Documentation+under+heading+%22announce_infohash%3A%3A%5Bstart_sent%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>start_sent</dt>
<dd>set to true when we get a valid response from an announce
with event=started. If it is set, we won't send start in the subsequent
announces.</dd>
</dl>
<a name="complete_sent"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:announce_infohash%3A%3A%5Bcomplete_sent%5D&labels=documentation&body=Documentation+under+heading+%22announce_infohash%3A%3A%5Bcomplete_sent%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>complete_sent</dt>
<dd>set to true when we send a event=completed.</dd>
</dl>
<a name="announce_endpoint"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+announce_endpoint&labels=documentation&body=Documentation+under+heading+%22class+announce_endpoint%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="announce-endpoint">
<h1>announce_endpoint</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/announce_entry.hpp">libtorrent/announce_entry.hpp</a>&quot;</p>
<p>announces are sent to each tracker using every listen socket
this class holds information about one listen socket for one tracker</p>
<pre class="literal-block">
struct announce_endpoint
{
   <strong>announce_endpoint</strong> ();

   <a class="reference external" href="tcp::endpoint">tcp::endpoint</a> local_endpoint;
   aux::array&lt;announce_infohash, num_protocols, protocol_version&gt; info_hashes;
   bool <strong>enabled</strong>  = true;
};
</pre>
<a name="local_endpoint"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:announce_endpoint%3A%3A%5Blocal_endpoint%5D&labels=documentation&body=Documentation+under+heading+%22announce_endpoint%3A%3A%5Blocal_endpoint%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>local_endpoint</dt>
<dd>the local endpoint of the listen interface associated with this endpoint</dd>
</dl>
<a name="info_hashes"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:announce_endpoint%3A%3A%5Binfo_hashes%5D&labels=documentation&body=Documentation+under+heading+%22announce_endpoint%3A%3A%5Binfo_hashes%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>info_hashes</dt>
<dd>info_hashes[0] is the v1 info hash (SHA1)
info_hashes[1] is the v2 info hash (truncated SHA-256)</dd>
</dl>
<a name="enabled"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:announce_endpoint%3A%3A%5Benabled%5D&labels=documentation&body=Documentation+under+heading+%22announce_endpoint%3A%3A%5Benabled%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>enabled</dt>
<dd>set to false to not announce from this endpoint</dd>
</dl>
<a name="announce_entry"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+announce_entry&labels=documentation&body=Documentation+under+heading+%22class+announce_entry%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="announce-entry">
<h1>announce_entry</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/announce_entry.hpp">libtorrent/announce_entry.hpp</a>&quot;</p>
<p>this class holds information about one bittorrent tracker, as it
relates to a specific torrent.</p>
<pre class="literal-block">
struct announce_entry
{
   <strong>announce_entry</strong> (announce_entry const&amp;);
   <strong>~announce_entry</strong> ();
   explicit <strong>announce_entry</strong> (string_view u);
   <strong>announce_entry</strong> ();
   announce_entry&amp; <strong>operator=</strong> (announce_entry const&amp;) &amp;;

   enum tracker_source
   {
      source_torrent,
      source_client,
      source_magnet_link,
      source_tex,
   };

   std::string url;
   std::string trackerid;
   std::vector&lt;announce_endpoint&gt; endpoints;
   std::uint8_t <strong>tier</strong>  = 0;
   std::uint8_t <strong>fail_limit</strong>  = 0;
   std::uint8_t source:4;
   bool verified:1;
};
</pre>
<a name="~announce_entry()"></a>
<a name="announce_entry()"></a>
<a name="operator=()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:announce_entry%3A%3A%5B~announce_entry%28%29+announce_entry%28%29+operator%3D%28%29%5D&labels=documentation&body=Documentation+under+heading+%22announce_entry%3A%3A%5B~announce_entry%28%29+announce_entry%28%29+operator%3D%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="announce-entry-announce-entry-operator">
<h2>~announce_entry() announce_entry() operator=()</h2>
<pre class="literal-block">
<strong>announce_entry</strong> (announce_entry const&amp;);
<strong>~announce_entry</strong> ();
explicit <strong>announce_entry</strong> (string_view u);
<strong>announce_entry</strong> ();
announce_entry&amp; <strong>operator=</strong> (announce_entry const&amp;) &amp;;
</pre>
<p>constructs a tracker announce <a class="reference external" href="reference-Bencoding.html#entry">entry</a> with <tt class="docutils literal">u</tt> as the URL.</p>
<a name="tracker_source"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+tracker_source&labels=documentation&body=Documentation+under+heading+%22enum+tracker_source%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-tracker-source">
<h2>enum tracker_source</h2>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/announce_entry.hpp">libtorrent/announce_entry.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="7%" />
<col width="74%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>source_torrent</td>
<td>1</td>
<td>the tracker was part of the .torrent file</td>
</tr>
<tr><td>source_client</td>
<td>2</td>
<td>the tracker was added programmatically via the <a class="reference external" href="reference-Torrent_Info.html#add_tracker()">add_tracker()</a> function</td>
</tr>
<tr><td>source_magnet_link</td>
<td>4</td>
<td>the tracker was part of a magnet link</td>
</tr>
<tr><td>source_tex</td>
<td>8</td>
<td>the tracker was received from the swarm via tracker exchange</td>
</tr>
</tbody>
</table>
<a name="url"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:announce_entry%3A%3A%5Burl%5D&labels=documentation&body=Documentation+under+heading+%22announce_entry%3A%3A%5Burl%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>url</dt>
<dd>tracker URL as it appeared in the torrent file</dd>
</dl>
<a name="trackerid"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:announce_entry%3A%3A%5Btrackerid%5D&labels=documentation&body=Documentation+under+heading+%22announce_entry%3A%3A%5Btrackerid%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>trackerid</dt>
<dd>the current <tt class="docutils literal">&amp;trackerid=</tt> argument passed to the tracker.
this is optional and is normally empty (in which case no
trackerid is sent).</dd>
</dl>
<a name="endpoints"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:announce_entry%3A%3A%5Bendpoints%5D&labels=documentation&body=Documentation+under+heading+%22announce_entry%3A%3A%5Bendpoints%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>endpoints</dt>
<dd>each local listen socket (endpoint) will announce to the tracker. This
list contains state per endpoint.</dd>
</dl>
<a name="tier"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:announce_entry%3A%3A%5Btier%5D&labels=documentation&body=Documentation+under+heading+%22announce_entry%3A%3A%5Btier%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>tier</dt>
<dd>the tier this tracker belongs to</dd>
</dl>
<a name="fail_limit"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:announce_entry%3A%3A%5Bfail_limit%5D&labels=documentation&body=Documentation+under+heading+%22announce_entry%3A%3A%5Bfail_limit%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>fail_limit</dt>
<dd>the max number of failures to announce to this tracker in
a row, before this tracker is not used anymore. 0 means unlimited</dd>
</dl>
<a name="source"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:announce_entry%3A%3A%5Bsource%5D&labels=documentation&body=Documentation+under+heading+%22announce_entry%3A%3A%5Bsource%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>source</dt>
<dd>a bitmask specifying which sources we got this tracker from.</dd>
</dl>
<a name="verified"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:announce_entry%3A%3A%5Bverified%5D&labels=documentation&body=Documentation+under+heading+%22announce_entry%3A%3A%5Bverified%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>verified</dt>
<dd>set to true the first time we receive a valid response
from this tracker.</dd>
</dl>
<a name="web_seed_entry"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+web_seed_entry&labels=documentation&body=Documentation+under+heading+%22class+web_seed_entry%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="web-seed-entry">
<h1>web_seed_entry</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/torrent_info.hpp">libtorrent/torrent_info.hpp</a>&quot;</p>
<p>the <a class="reference external" href="reference-Torrent_Info.html#web_seed_entry">web_seed_entry</a> holds information about a web seed (also known
as URL seed or HTTP seed). It is essentially a URL with some state
associated with it. For more information, see <a class="reference external" href="https://www.bittorrent.org/beps/bep_0017.html">BEP 17</a> and <a class="reference external" href="https://www.bittorrent.org/beps/bep_0019.html">BEP 19</a>.</p>
<pre class="literal-block">
struct web_seed_entry
{
   bool <strong>operator==</strong> (web_seed_entry const&amp; e) const;
   bool <strong>operator&lt;</strong> (web_seed_entry const&amp; e) const;

   enum type_t
   {
      url_seed,
      http_seed,
   };

   std::string url;
   std::string auth;
   headers_t extra_headers;
   std::uint8_t type;
};
</pre>
<a name="operator==()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:web_seed_entry%3A%3A%5Boperator%3D%3D%28%29%5D&labels=documentation&body=Documentation+under+heading+%22web_seed_entry%3A%3A%5Boperator%3D%3D%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="operator-5">
<h2>operator==()</h2>
<pre class="literal-block">
bool <strong>operator==</strong> (web_seed_entry const&amp; e) const;
</pre>
<p>URL and type comparison</p>
<a name="operator<()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:web_seed_entry%3A%3A%5Boperator%3C%28%29%5D&labels=documentation&body=Documentation+under+heading+%22web_seed_entry%3A%3A%5Boperator%3C%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="operator-6">
<h2>operator&lt;()</h2>
<pre class="literal-block">
bool <strong>operator&lt;</strong> (web_seed_entry const&amp; e) const;
</pre>
<p>URL and type less-than comparison</p>
<a name="type_t"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+type_t&labels=documentation&body=Documentation+under+heading+%22enum+type_t%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-type-t-1">
<h2>enum type_t</h2>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/torrent_info.hpp">libtorrent/torrent_info.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="35%" />
<col width="23%" />
<col width="42%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>url_seed</td>
<td>0</td>
<td>&nbsp;</td>
</tr>
<tr><td>http_seed</td>
<td>1</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<a name="url"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:web_seed_entry%3A%3A%5Burl%5D&labels=documentation&body=Documentation+under+heading+%22web_seed_entry%3A%3A%5Burl%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>url</dt>
<dd>The URL of the web seed</dd>
</dl>
<a name="auth"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:web_seed_entry%3A%3A%5Bauth%5D&labels=documentation&body=Documentation+under+heading+%22web_seed_entry%3A%3A%5Bauth%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>auth</dt>
<dd>Optional authentication. If this is set, it's passed
in as HTTP basic auth to the web seed. The format is:
username:password.</dd>
</dl>
<a name="extra_headers"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:web_seed_entry%3A%3A%5Bextra_headers%5D&labels=documentation&body=Documentation+under+heading+%22web_seed_entry%3A%3A%5Bextra_headers%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>extra_headers</dt>
<dd>Any extra HTTP headers that need to be passed to the web seed</dd>
</dl>
<a name="type"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:web_seed_entry%3A%3A%5Btype%5D&labels=documentation&body=Documentation+under+heading+%22web_seed_entry%3A%3A%5Btype%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>type</dt>
<dd>The type of web seed (see <a class="reference external" href="reference-Torrent_Info.html#type_t">type_t</a>)</dd>
</dl>
<a name="load_torrent_limits"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+load_torrent_limits&labels=documentation&body=Documentation+under+heading+%22class+load_torrent_limits%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="load-torrent-limits">
<h1>load_torrent_limits</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/torrent_info.hpp">libtorrent/torrent_info.hpp</a>&quot;</p>
<p>this object holds configuration options for limits to use when loading
torrents. They are meant to prevent loading potentially malicious torrents
that cause excessive memory allocations.</p>
<pre class="literal-block">
struct load_torrent_limits
{
   int <strong>max_buffer_size</strong>  = 10000000;
   int <strong>max_pieces</strong>  = 0x200000;
   int <strong>max_decode_depth</strong>  = 100;
   int <strong>max_decode_tokens</strong>  = 3000000;
};
</pre>
<a name="max_buffer_size"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:load_torrent_limits%3A%3A%5Bmax_buffer_size%5D&labels=documentation&body=Documentation+under+heading+%22load_torrent_limits%3A%3A%5Bmax_buffer_size%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>max_buffer_size</dt>
<dd>the max size of a .torrent file to load into RAM</dd>
</dl>
<a name="max_pieces"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:load_torrent_limits%3A%3A%5Bmax_pieces%5D&labels=documentation&body=Documentation+under+heading+%22load_torrent_limits%3A%3A%5Bmax_pieces%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>max_pieces</dt>
<dd>the max number of pieces allowed in the torrent</dd>
</dl>
<a name="max_decode_depth"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:load_torrent_limits%3A%3A%5Bmax_decode_depth%5D&labels=documentation&body=Documentation+under+heading+%22load_torrent_limits%3A%3A%5Bmax_decode_depth%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>max_decode_depth</dt>
<dd>the max recursion depth in the bdecoded structure</dd>
</dl>
<a name="max_decode_tokens"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:load_torrent_limits%3A%3A%5Bmax_decode_tokens%5D&labels=documentation&body=Documentation+under+heading+%22load_torrent_limits%3A%3A%5Bmax_decode_tokens%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>max_decode_tokens</dt>
<dd>the max number of bdecode tokens</dd>
</dl>
<a name="torrent_info"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+torrent_info&labels=documentation&body=Documentation+under+heading+%22class+torrent_info%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="torrent-info">
<h1>torrent_info</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/torrent_info.hpp">libtorrent/torrent_info.hpp</a>&quot;</p>
<p>the <a class="reference external" href="reference-Torrent_Info.html#torrent_info">torrent_info</a> class holds the information found in a .torrent file.</p>
<pre class="literal-block">
class torrent_info
{
   explicit <strong>torrent_info</strong> (span&lt;char const&gt; buffer, from_span_t);
   explicit <strong>torrent_info</strong> (info_hash_t const&amp; info_hash);
   <strong>torrent_info</strong> (span&lt;char const&gt; buffer, load_torrent_limits const&amp; cfg, from_span_t);
   <strong>torrent_info</strong> (std::string const&amp; filename, error_code&amp; ec);
   <strong>torrent_info</strong> (torrent_info const&amp; t);
   <strong>torrent_info</strong> (span&lt;char const&gt; buffer, error_code&amp; ec, from_span_t);
   explicit <strong>torrent_info</strong> (bdecode_node const&amp; torrent_file);
   <strong>torrent_info</strong> (bdecode_node const&amp; torrent_file, load_torrent_limits const&amp; cfg);
   <strong>torrent_info</strong> (char const* buffer, int size, error_code&amp; ec);
   <strong>torrent_info</strong> (bdecode_node const&amp; torrent_file, error_code&amp; ec);
   <strong>torrent_info</strong> (char const* buffer, int size);
   explicit <strong>torrent_info</strong> (std::string const&amp; filename);
   <strong>torrent_info</strong> (std::string const&amp; filename, load_torrent_limits const&amp; cfg);
   <strong>~torrent_info</strong> ();
   file_storage const&amp; <strong>files</strong> () const;
   file_storage const&amp; <strong>orig_files</strong> () const;
   void <strong>rename_file</strong> (file_index_t index, std::string const&amp; new_filename);
   void <strong>remap_files</strong> (file_storage const&amp; f);
   std::vector&lt;announce_entry&gt; const&amp; <strong>trackers</strong> () const;
   void <strong>clear_trackers</strong> ();
   void <strong>add_tracker</strong> (std::string const&amp; url, int tier = 0);
   void <strong>add_tracker</strong> (std::string const&amp; url, int tier
      , announce_entry::tracker_source source);
   std::vector&lt;std::string&gt; <strong>collections</strong> () const;
   std::vector&lt;sha1_hash&gt; <strong>similar_torrents</strong> () const;
   std::vector&lt;web_seed_entry&gt; const&amp; <strong>web_seeds</strong> () const;
   void <strong>add_url_seed</strong> (std::string const&amp; url
      , std::string const&amp; ext_auth = std::string()
      , web_seed_entry::headers_t const&amp; ext_headers = web_seed_entry::headers_t());
   void <strong>set_web_seeds</strong> (std::vector&lt;web_seed_entry&gt; seeds);
   void <strong>add_http_seed</strong> (std::string const&amp; url
      , std::string const&amp; extern_auth = std::string()
      , web_seed_entry::headers_t const&amp; extra_headers = web_seed_entry::headers_t());
   std::int64_t <strong>total_size</strong> () const;
   int <strong>piece_length</strong> () const;
   int <strong>num_pieces</strong> () const;
   int <strong>blocks_per_piece</strong> () const;
   index_range&lt;piece_index_t&gt; <strong>piece_range</strong> () const;
   piece_index_t <strong>last_piece</strong> () const;
   piece_index_t <strong>end_piece</strong> () const;
   info_hash_t const&amp; <strong>info_hashes</strong> () const;
   sha1_hash <strong>info_hash</strong> () const noexcept;
   bool <strong>v2</strong> () const;
   bool <strong>v1</strong> () const;
   int <strong>num_files</strong> () const;
   std::vector&lt;file_slice&gt; <strong>map_block</strong> (piece_index_t const piece
      , std::int64_t offset, int size) const;
   peer_request <strong>map_file</strong> (file_index_t const file, std::int64_t offset, int size) const;
   string_view <strong>ssl_cert</strong> () const;
   bool <strong>is_valid</strong> () const;
   bool <strong>priv</strong> () const;
   bool <strong>is_i2p</strong> () const;
   int <strong>piece_size</strong> (piece_index_t index) const;
   char const* <strong>hash_for_piece_ptr</strong> (piece_index_t const index) const;
   sha1_hash <strong>hash_for_piece</strong> (piece_index_t index) const;
   bool <strong>is_loaded</strong> () const;
   const std::string&amp; <strong>name</strong> () const;
   std::time_t <strong>creation_date</strong> () const;
   const std::string&amp; <strong>creator</strong> () const;
   const std::string&amp; <strong>comment</strong> () const;
   std::vector&lt;std::pair&lt;std::string, int&gt;&gt; const&amp; <strong>nodes</strong> () const;
   void <strong>add_node</strong> (std::pair&lt;std::string, int&gt; const&amp; node);
   bool <strong>parse_info_section</strong> (bdecode_node const&amp; info, error_code&amp; ec, int max_pieces);
   bdecode_node <strong>info</strong> (char const* key) const;
   span&lt;char const&gt; <strong>info_section</strong> () const;
   span&lt;char const&gt; <strong>piece_layer</strong> (file_index_t) const;
   void <strong>free_piece_layers</strong> ();
};
</pre>
<a name="torrent_info()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Btorrent_info%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Btorrent_info%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="torrent-info-1">
<h2>torrent_info()</h2>
<pre class="literal-block">
explicit <strong>torrent_info</strong> (span&lt;char const&gt; buffer, from_span_t);
explicit <strong>torrent_info</strong> (info_hash_t const&amp; info_hash);
<strong>torrent_info</strong> (span&lt;char const&gt; buffer, load_torrent_limits const&amp; cfg, from_span_t);
<strong>torrent_info</strong> (std::string const&amp; filename, error_code&amp; ec);
<strong>torrent_info</strong> (torrent_info const&amp; t);
<strong>torrent_info</strong> (span&lt;char const&gt; buffer, error_code&amp; ec, from_span_t);
explicit <strong>torrent_info</strong> (bdecode_node const&amp; torrent_file);
<strong>torrent_info</strong> (bdecode_node const&amp; torrent_file, load_torrent_limits const&amp; cfg);
<strong>torrent_info</strong> (char const* buffer, int size, error_code&amp; ec);
<strong>torrent_info</strong> (bdecode_node const&amp; torrent_file, error_code&amp; ec);
<strong>torrent_info</strong> (char const* buffer, int size);
explicit <strong>torrent_info</strong> (std::string const&amp; filename);
<strong>torrent_info</strong> (std::string const&amp; filename, load_torrent_limits const&amp; cfg);
</pre>
<p>The constructor that takes an info-hash will initialize the info-hash
to the given value, but leave all other fields empty. This is used
internally when downloading torrents without the metadata. The
metadata will be created by libtorrent as soon as it has been
downloaded from the swarm.</p>
<p>The constructor that takes a <a class="reference external" href="reference-Bdecoding.html#bdecode_node">bdecode_node</a> will create a <a class="reference external" href="reference-Torrent_Info.html#torrent_info">torrent_info</a>
object from the information found in the given torrent_file. The
<a class="reference external" href="reference-Bdecoding.html#bdecode_node">bdecode_node</a> represents a tree node in an bencoded file. To load an
ordinary .torrent file into a <a class="reference external" href="reference-Bdecoding.html#bdecode_node">bdecode_node</a>, use <a class="reference external" href="reference-Bdecoding.html#bdecode()">bdecode()</a>.</p>
<p>The version that takes a buffer pointer and a size will decode it as a
.torrent file and initialize the <a class="reference external" href="reference-Torrent_Info.html#torrent_info">torrent_info</a> object for you.</p>
<p>The version that takes a filename will simply load the torrent file
and decode it inside the constructor, for convenience. This might not
be the most suitable for applications that want to be able to report
detailed errors on what might go wrong.</p>
<p>There is an upper limit on the size of the torrent file that will be
loaded by the overload taking a filename. If it's important that even
very large torrent files are loaded, use one of the other overloads.</p>
<p>The overloads that takes an <tt class="docutils literal">error_code const&amp;</tt> never throws if an
error occur, they will simply set the error code to describe what went
wrong and not fully initialize the <a class="reference external" href="reference-Torrent_Info.html#torrent_info">torrent_info</a> object. The overloads
that do not take the extra error_code parameter will always throw if
an error occurs. These overloads are not available when building
without exception support.</p>
<p>The overload that takes a <tt class="docutils literal">span</tt> also needs an extra parameter of
type <tt class="docutils literal">from_span_t</tt> to disambiguate the <tt class="docutils literal"><span class="pre">std::string</span></tt> overload for
string literals. There is an object in the libtorrent namespace of this
type called <tt class="docutils literal">from_span</tt>.</p>
<a name="~torrent_info()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5B~torrent_info%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5B~torrent_info%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="torrent-info-2">
<h2>~torrent_info()</h2>
<pre class="literal-block">
<strong>~torrent_info</strong> ();
</pre>
<p>frees all storage associated with this <a class="reference external" href="reference-Torrent_Info.html#torrent_info">torrent_info</a> object</p>
<a name="orig_files()"></a>
<a name="files()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Borig_files%28%29+files%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Borig_files%28%29+files%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="orig-files-files">
<h2>orig_files() files()</h2>
<pre class="literal-block">
file_storage const&amp; <strong>files</strong> () const;
file_storage const&amp; <strong>orig_files</strong> () const;
</pre>
<p>The <a class="reference external" href="reference-Storage.html#file_storage">file_storage</a> object contains the information on how to map the
pieces to files. It is separated from the <a class="reference external" href="reference-Torrent_Info.html#torrent_info">torrent_info</a> object because
when creating torrents a storage object needs to be created without
having a torrent file. When renaming files in a storage, the storage
needs to make its own copy of the <a class="reference external" href="reference-Storage.html#file_storage">file_storage</a> in order to make its
mapping differ from the one in the torrent file.</p>
<p><tt class="docutils literal">orig_files()</tt> returns the original (unmodified) file storage for
this torrent. This is used by the web server connection, which needs
to request files with the original names. Filename may be changed using
<tt class="docutils literal"><span class="pre">torrent_info::rename_file()</span></tt>.</p>
<p>For more information on the <a class="reference external" href="reference-Storage.html#file_storage">file_storage</a> object, see the separate
document on how to create torrents.</p>
<a name="rename_file()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Brename_file%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Brename_file%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="rename-file-2">
<h2>rename_file()</h2>
<pre class="literal-block">
void <strong>rename_file</strong> (file_index_t index, std::string const&amp; new_filename);
</pre>
<p>Renames the file with the specified index to the new name. The new
filename is reflected by the <tt class="docutils literal">file_storage</tt> returned by <tt class="docutils literal">files()</tt>
but not by the one returned by <tt class="docutils literal">orig_files()</tt>.</p>
<p>If you want to rename the base name of the torrent (for a multi file
torrent), you can copy the <tt class="docutils literal">file_storage</tt> (see <a class="reference external" href="reference-Torrent_Info.html#files()">files()</a> and
<a class="reference external" href="reference-Torrent_Info.html#orig_files()">orig_files()</a> ), change the name, and then use <a class="reference internal" href="#remap-files">remap_files()</a>.</p>
<p>The <tt class="docutils literal">new_filename</tt> can both be a relative path, in which case the
file name is relative to the <tt class="docutils literal">save_path</tt> of the torrent. If the
<tt class="docutils literal">new_filename</tt> is an absolute path (i.e. <tt class="docutils literal">is_complete(new_filename)
== true</tt>), then the file is detached from the <tt class="docutils literal">save_path</tt> of the
torrent. In this case the file is not moved when <a class="reference external" href="reference-Torrent_Handle.html#move_storage()">move_storage()</a> is
invoked.</p>
<a name="remap_files()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Bremap_files%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Bremap_files%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="remap-files">
<h2>remap_files()</h2>
<pre class="literal-block">
void <strong>remap_files</strong> (file_storage const&amp; f);
</pre>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Using <cite>remap_files()</cite> is discouraged as it's incompatible with v2
torrents. This is because the piece boundaries and piece hashes in
v2 torrents are intimately tied to the file boundaries. Instead,
just rename individual files, or implement a custom <a class="reference external" href="reference-Custom_Storage.html#disk_interface">disk_interface</a>
to customize how to store files.</p>
</div>
<p>Remaps the file storage to a new file layout. This can be used to, for
instance, download all data in a torrent to a single file, or to a
number of fixed size sector aligned files, regardless of the number
and sizes of the files in the torrent.</p>
<p>The new specified <tt class="docutils literal">file_storage</tt> must have the exact same size as
the current one.</p>
<a name="trackers()"></a>
<a name="clear_trackers()"></a>
<a name="add_tracker()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Btrackers%28%29+clear_trackers%28%29+add_tracker%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Btrackers%28%29+clear_trackers%28%29+add_tracker%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="trackers-clear-trackers-add-tracker">
<h2>trackers() clear_trackers() add_tracker()</h2>
<pre class="literal-block">
std::vector&lt;announce_entry&gt; const&amp; <strong>trackers</strong> () const;
void <strong>clear_trackers</strong> ();
void <strong>add_tracker</strong> (std::string const&amp; url, int tier = 0);
void <strong>add_tracker</strong> (std::string const&amp; url, int tier
      , announce_entry::tracker_source source);
</pre>
<p><tt class="docutils literal">add_tracker()</tt> adds a tracker to the announce-list. The <tt class="docutils literal">tier</tt>
determines the order in which the trackers are to be tried.
The <tt class="docutils literal">trackers()</tt> function will return a sorted vector of
<a class="reference external" href="reference-Trackers.html#announce_entry">announce_entry</a>. Each announce <a class="reference external" href="reference-Bencoding.html#entry">entry</a> contains a string, which is
the tracker url, and a tier index. The tier index is the high-level
priority. No matter which trackers that works or not, the ones with
lower tier will always be tried before the one with higher tier
number. For more information, see <a class="reference external" href="reference-Trackers.html#announce_entry">announce_entry</a>.</p>
<p><tt class="docutils literal">trackers()</tt> returns all entries from announce-list.</p>
<p><tt class="docutils literal">clear_trackers()</tt> removes all trackers from announce-list.</p>
<a name="similar_torrents()"></a>
<a name="collections()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Bsimilar_torrents%28%29+collections%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Bsimilar_torrents%28%29+collections%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="similar-torrents-collections">
<h2>similar_torrents() collections()</h2>
<pre class="literal-block">
std::vector&lt;std::string&gt; <strong>collections</strong> () const;
std::vector&lt;sha1_hash&gt; <strong>similar_torrents</strong> () const;
</pre>
<p>These two functions are related to <a class="reference external" href="https://www.bittorrent.org/beps/bep_0038.html">BEP 38</a> (mutable torrents). The
vectors returned from these correspond to the &quot;similar&quot; and
&quot;collections&quot; keys in the .torrent file. Both info-hashes and
collections from within the info-dict and from outside of it are
included.</p>
<a name="set_web_seeds()"></a>
<a name="add_url_seed()"></a>
<a name="web_seeds()"></a>
<a name="add_http_seed()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Bset_web_seeds%28%29+add_url_seed%28%29+web_seeds%28%29+add_http_seed%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Bset_web_seeds%28%29+add_url_seed%28%29+web_seeds%28%29+add_http_seed%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="set-web-seeds-add-url-seed-web-seeds-add-http-seed">
<h2>set_web_seeds() add_url_seed() web_seeds() add_http_seed()</h2>
<pre class="literal-block">
std::vector&lt;web_seed_entry&gt; const&amp; <strong>web_seeds</strong> () const;
void <strong>add_url_seed</strong> (std::string const&amp; url
      , std::string const&amp; ext_auth = std::string()
      , web_seed_entry::headers_t const&amp; ext_headers = web_seed_entry::headers_t());
void <strong>set_web_seeds</strong> (std::vector&lt;web_seed_entry&gt; seeds);
void <strong>add_http_seed</strong> (std::string const&amp; url
      , std::string const&amp; extern_auth = std::string()
      , web_seed_entry::headers_t const&amp; extra_headers = web_seed_entry::headers_t());
</pre>
<p><tt class="docutils literal">web_seeds()</tt> returns all url seeds and http seeds in the torrent.
Each <a class="reference external" href="reference-Bencoding.html#entry">entry</a> is a <tt class="docutils literal">web_seed_entry</tt> and may refer to either a url seed
or http seed.</p>
<p><tt class="docutils literal">add_url_seed()</tt> and <tt class="docutils literal">add_http_seed()</tt> adds one url to the list of
url/http seeds.</p>
<p><tt class="docutils literal">set_web_seeds()</tt> replaces all web seeds with the ones specified in
the <tt class="docutils literal">seeds</tt> vector.</p>
<p>The <tt class="docutils literal">extern_auth</tt> argument can be used for other authorization
schemes than basic HTTP authorization. If set, it will override any
username and password found in the URL itself. The string will be sent
as the HTTP authorization header's value (without specifying &quot;Basic&quot;).</p>
<p>The <tt class="docutils literal">extra_headers</tt> argument defaults to an empty list, but can be
used to insert custom HTTP headers in the requests to a specific web
seed.</p>
<p>See <a class="reference external" href="manual-ref.html#http-seeding">http seeding</a> for more information.</p>
<a name="total_size()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Btotal_size%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Btotal_size%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="total-size-2">
<h2>total_size()</h2>
<pre class="literal-block">
std::int64_t <strong>total_size</strong> () const;
</pre>
<p><tt class="docutils literal">total_size()</tt> returns the total number of bytes the torrent-file
represents. Note that this is the number of pieces times the piece
size (modulo the last piece possibly being smaller). With pad files,
the total size will be larger than the sum of all (regular) file
sizes.</p>
<a name="piece_length()"></a>
<a name="num_pieces()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Bpiece_length%28%29+num_pieces%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Bpiece_length%28%29+num_pieces%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="piece-length-num-pieces">
<h2>piece_length() num_pieces()</h2>
<pre class="literal-block">
int <strong>piece_length</strong> () const;
int <strong>num_pieces</strong> () const;
</pre>
<p><tt class="docutils literal">piece_length()</tt> and <tt class="docutils literal">num_pieces()</tt> returns the number of byte
for each piece and the total number of pieces, respectively. The
difference between <tt class="docutils literal">piece_size()</tt> and <tt class="docutils literal">piece_length()</tt> is that
<tt class="docutils literal">piece_size()</tt> takes the piece index as argument and gives you the
exact size of that piece. It will always be the same as
<tt class="docutils literal">piece_length()</tt> except in the case of the last piece, which may be
smaller.</p>
<a name="blocks_per_piece()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Bblocks_per_piece%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Bblocks_per_piece%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="blocks-per-piece-1">
<h2>blocks_per_piece()</h2>
<pre class="literal-block">
int <strong>blocks_per_piece</strong> () const;
</pre>
<p>returns the number of blocks there are in the typical piece. There
may be fewer in the last piece)</p>
<a name="last_piece()"></a>
<a name="end_piece()"></a>
<a name="piece_range()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Blast_piece%28%29+end_piece%28%29+piece_range%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Blast_piece%28%29+end_piece%28%29+piece_range%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="last-piece-end-piece-piece-range">
<h2>last_piece() end_piece() piece_range()</h2>
<pre class="literal-block">
index_range&lt;piece_index_t&gt; <strong>piece_range</strong> () const;
piece_index_t <strong>last_piece</strong> () const;
piece_index_t <strong>end_piece</strong> () const;
</pre>
<p><tt class="docutils literal">last_piece()</tt> returns the index to the last piece in the torrent and
<tt class="docutils literal">end_piece()</tt> returns the index to the one-past-end piece in the
torrent
<tt class="docutils literal">piece_range()</tt> returns an implementation-defined type that can be
used as the container in a range-for loop. Where the values are the
indices of all pieces in the <a class="reference external" href="reference-Storage.html#file_storage">file_storage</a>.</p>
<a name="info_hash()"></a>
<a name="info_hashes()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Binfo_hash%28%29+info_hashes%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Binfo_hash%28%29+info_hashes%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="info-hash-info-hashes-1">
<h2>info_hash() info_hashes()</h2>
<pre class="literal-block">
info_hash_t const&amp; <strong>info_hashes</strong> () const;
sha1_hash <strong>info_hash</strong> () const noexcept;
</pre>
<p>returns the info-hash of the torrent. For BitTorrent v2 support, use
<tt class="docutils literal">info_hashes()</tt> to get an object that may hold both a v1 and v2
info-hash</p>
<a name="v2()"></a>
<a name="v1()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Bv2%28%29+v1%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Bv2%28%29+v1%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="v2-v1">
<h2>v2() v1()</h2>
<pre class="literal-block">
bool <strong>v2</strong> () const;
bool <strong>v1</strong> () const;
</pre>
<p>returns whether this torrent has v1 and/or v2 metadata, respectively.
Hybrid torrents have both. These are shortcuts for
info_hashes().has_v1() and info_hashes().has_v2() calls.</p>
<a name="num_files()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Bnum_files%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Bnum_files%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="num-files-1">
<h2>num_files()</h2>
<pre class="literal-block">
int <strong>num_files</strong> () const;
</pre>
<p>If you need index-access to files you can use the <tt class="docutils literal">num_files()</tt> along
with the <tt class="docutils literal">file_path()</tt>, <tt class="docutils literal">file_size()</tt>-family of functions to access
files using indices.</p>
<a name="map_block()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Bmap_block%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Bmap_block%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="map-block-1">
<h2>map_block()</h2>
<pre class="literal-block">
std::vector&lt;file_slice&gt; <strong>map_block</strong> (piece_index_t const piece
      , std::int64_t offset, int size) const;
</pre>
<p>This function will map a piece index, a byte offset within that piece
and a size (in bytes) into the corresponding files with offsets where
that data for that piece is supposed to be stored. See <a class="reference external" href="reference-Storage.html#file_slice">file_slice</a>.</p>
<a name="map_file()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Bmap_file%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Bmap_file%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="map-file-1">
<h2>map_file()</h2>
<pre class="literal-block">
peer_request <strong>map_file</strong> (file_index_t const file, std::int64_t offset, int size) const;
</pre>
<p>This function will map a range in a specific file into a range in the
torrent. The <tt class="docutils literal">file_offset</tt> parameter is the offset in the file,
given in bytes, where 0 is the start of the file. See <a class="reference external" href="reference-Core.html#peer_request">peer_request</a>.</p>
<p>The input range is assumed to be valid within the torrent.
<tt class="docutils literal">file_offset</tt> + <tt class="docutils literal">size</tt> is not allowed to be greater than the file
size. <tt class="docutils literal">file_index</tt> must refer to a valid file, i.e. it cannot be &gt;=
<tt class="docutils literal">num_files()</tt>.</p>
<a name="ssl_cert()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Bssl_cert%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Bssl_cert%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="ssl-cert">
<h2>ssl_cert()</h2>
<pre class="literal-block">
string_view <strong>ssl_cert</strong> () const;
</pre>
<p>Returns the SSL root certificate for the torrent, if it is an SSL
torrent. Otherwise returns an empty string. The certificate is
the public certificate in x509 format.</p>
<a name="is_valid()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Bis_valid%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Bis_valid%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="is-valid-3">
<h2>is_valid()</h2>
<pre class="literal-block">
bool <strong>is_valid</strong> () const;
</pre>
<p>returns true if this <a class="reference external" href="reference-Torrent_Info.html#torrent_info">torrent_info</a> object has a torrent loaded.
This is primarily used to determine if a magnet link has had its
metadata resolved yet or not.</p>
<a name="priv()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Bpriv%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Bpriv%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="priv">
<h2>priv()</h2>
<pre class="literal-block">
bool <strong>priv</strong> () const;
</pre>
<p>returns true if this torrent is private. i.e., the client should not
advertise itself on the trackerless network (the Kademlia DHT) for this torrent.</p>
<a name="is_i2p()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Bis_i2p%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Bis_i2p%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="is-i2p">
<h2>is_i2p()</h2>
<pre class="literal-block">
bool <strong>is_i2p</strong> () const;
</pre>
<p>returns true if this is an i2p torrent. This is determined by whether
or not it has a tracker whose URL domain name ends with &quot;.i2p&quot;. i2p
torrents disable the DHT and local peer discovery as well as talking
to peers over anything other than the i2p network.</p>
<a name="piece_size()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Bpiece_size%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Bpiece_size%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="piece-size-1">
<h2>piece_size()</h2>
<pre class="literal-block">
int <strong>piece_size</strong> (piece_index_t index) const;
</pre>
<p>returns the piece size of file with <tt class="docutils literal">index</tt>. This will be the same as <a class="reference external" href="reference-Torrent_Info.html#piece_length()">piece_length()</a>,
except for the last piece, which may be shorter.</p>
<a name="hash_for_piece_ptr()"></a>
<a name="hash_for_piece()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Bhash_for_piece_ptr%28%29+hash_for_piece%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Bhash_for_piece_ptr%28%29+hash_for_piece%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="hash-for-piece-ptr-hash-for-piece">
<h2>hash_for_piece_ptr() hash_for_piece()</h2>
<pre class="literal-block">
char const* <strong>hash_for_piece_ptr</strong> (piece_index_t const index) const;
sha1_hash <strong>hash_for_piece</strong> (piece_index_t index) const;
</pre>
<p><tt class="docutils literal">hash_for_piece()</tt> takes a piece-index and returns the 20-bytes
sha1-hash for that piece and <tt class="docutils literal">info_hash()</tt> returns the 20-bytes
sha1-hash for the info-section of the torrent file.
<tt class="docutils literal">hash_for_piece_ptr()</tt> returns a pointer to the 20 byte sha1 digest
for the piece. Note that the string is not 0-terminated.</p>
<a name="name()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Bname%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Bname%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="name">
<h2>name()</h2>
<pre class="literal-block">
const std::string&amp; <strong>name</strong> () const;
</pre>
<p><tt class="docutils literal">name()</tt> returns the name of the torrent.
name contains UTF-8 encoded string.</p>
<a name="creation_date()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Bcreation_date%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Bcreation_date%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="creation-date">
<h2>creation_date()</h2>
<pre class="literal-block">
std::time_t <strong>creation_date</strong> () const;
</pre>
<p><tt class="docutils literal">creation_date()</tt> returns the creation date of the torrent as time_t
(<a class="reference internal" href="#posix-time">posix time</a>). If there's no time stamp in the torrent file, 0 is
returned.
.. <span class="target" id="posix-time">posix time</span>: <a class="reference external" href="http://www.opengroup.org/onlinepubs/009695399/functions/time.html">http://www.opengroup.org/onlinepubs/009695399/functions/time.html</a></p>
<a name="creator()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Bcreator%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Bcreator%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="creator">
<h2>creator()</h2>
<pre class="literal-block">
const std::string&amp; <strong>creator</strong> () const;
</pre>
<p><tt class="docutils literal">creator()</tt> returns the creator string in the torrent. If there is
no creator string it will return an empty string.</p>
<a name="comment()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Bcomment%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Bcomment%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="comment">
<h2>comment()</h2>
<pre class="literal-block">
const std::string&amp; <strong>comment</strong> () const;
</pre>
<p><tt class="docutils literal">comment()</tt> returns the comment associated with the torrent. If
there's no comment, it will return an empty string.
comment contains UTF-8 encoded string.</p>
<a name="nodes()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Bnodes%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Bnodes%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="nodes-1">
<h2>nodes()</h2>
<pre class="literal-block">
std::vector&lt;std::pair&lt;std::string, int&gt;&gt; const&amp; <strong>nodes</strong> () const;
</pre>
<p>If this torrent contains any DHT nodes, they are put in this vector in
their original form (host name and port number).</p>
<a name="add_node()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Badd_node%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Badd_node%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="add-node-1">
<h2>add_node()</h2>
<pre class="literal-block">
void <strong>add_node</strong> (std::pair&lt;std::string, int&gt; const&amp; node);
</pre>
<p>This is used when creating torrent. Use this to add a known DHT node.
It may be used, by the client, to bootstrap into the DHT network.</p>
<a name="parse_info_section()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Bparse_info_section%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Bparse_info_section%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="parse-info-section">
<h2>parse_info_section()</h2>
<pre class="literal-block">
bool <strong>parse_info_section</strong> (bdecode_node const&amp; info, error_code&amp; ec, int max_pieces);
</pre>
<p>populates the <a class="reference external" href="reference-Torrent_Info.html#torrent_info">torrent_info</a> by providing just the info-dict buffer.
This is used when loading a torrent from a magnet link for instance,
where we only have the info-dict. The <a class="reference external" href="reference-Bdecoding.html#bdecode_node">bdecode_node</a> <tt class="docutils literal">e</tt> points to a
parsed info-dictionary. <tt class="docutils literal">ec</tt> returns an error code if something
fails (typically if the info dictionary is malformed).
The <cite>max_pieces</cite> parameter allows limiting the amount of memory
dedicated to loading the torrent, and fails for torrents that exceed
the limit. To load large torrents, this limit may also need to be
raised in <a class="reference external" href="reference-Settings.html#max_piece_count">settings_pack::max_piece_count</a> and in calls to
<a class="reference external" href="reference-Resume_Data.html#read_resume_data()">read_resume_data()</a>.</p>
<a name="info()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Binfo%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Binfo%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="info">
<h2>info()</h2>
<pre class="literal-block">
bdecode_node <strong>info</strong> (char const* key) const;
</pre>
<p>This function looks up keys from the info-dictionary of the loaded
torrent file. It can be used to access extension values put in the
.torrent file. If the specified key cannot be found, it returns nullptr.</p>
<a name="info_section()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Binfo_section%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Binfo_section%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="info-section">
<h2>info_section()</h2>
<pre class="literal-block">
span&lt;char const&gt; <strong>info_section</strong> () const;
</pre>
<p>returns a the raw info section of the torrent file.
The underlying buffer is still owned by the <a class="reference external" href="reference-Torrent_Info.html#torrent_info">torrent_info</a> object</p>
<a name="piece_layer()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Bpiece_layer%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Bpiece_layer%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="piece-layer">
<h2>piece_layer()</h2>
<pre class="literal-block">
span&lt;char const&gt; <strong>piece_layer</strong> (file_index_t) const;
</pre>
<p>return the bytes of the piece layer hashes for the specified file. If
the file doesn't have a piece layer, an empty span is returned.
The span size is divisible by 32, the size of a SHA-256 hash.
If the size of the file is smaller than or equal to the piece size,
the files &quot;root hash&quot; is the hash of the file and is not saved
separately in the &quot;piece layers&quot; field, but this function still
returns the root hash of the file in that case.</p>
<a name="free_piece_layers()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Bfree_piece_layers%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Bfree_piece_layers%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="free-piece-layers">
<h2>free_piece_layers()</h2>
<pre class="literal-block">
void <strong>free_piece_layers</strong> ();
</pre>
<p>clears the piece layers from the <a class="reference external" href="reference-Torrent_Info.html#torrent_info">torrent_info</a>. This is done by the
<a class="reference external" href="reference-Session.html#session">session</a> when a torrent is added, to avoid storing it twice. The piece
layer (or other hashes part of the merkle tree) are stored in the
internal torrent object.</p>
<a name="dht_state"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+dht_state&labels=documentation&body=Documentation+under+heading+%22class+dht_state%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="dht-state">
<h1>dht_state</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/kademlia/dht_state.hpp">libtorrent/kademlia/dht_state.hpp</a>&quot;</p>
<p>This structure helps to store and load the state
of the <tt class="docutils literal">dht_tracker</tt>.
At this moment the library is only a dual stack
implementation of the DHT. See <a class="reference external" href="https://www.bittorrent.org/beps/bep_0032.html">BEP 32</a></p>
<pre class="literal-block">
struct dht_state
{
   void <strong>clear</strong> ();

   node_ids_t nids;
   std::vector&lt;udp::endpoint&gt; nodes;
   std::vector&lt;udp::endpoint&gt; nodes6;
};
</pre>
<a name="nodes"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_state%3A%3A%5Bnodes%5D&labels=documentation&body=Documentation+under+heading+%22dht_state%3A%3A%5Bnodes%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>nodes</dt>
<dd>the bootstrap nodes saved from the buckets node</dd>
</dl>
<a name="nodes6"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_state%3A%3A%5Bnodes6%5D&labels=documentation&body=Documentation+under+heading+%22dht_state%3A%3A%5Bnodes6%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>nodes6</dt>
<dd>the bootstrap nodes saved from the IPv6 buckets node</dd>
</dl>
<a name="dht_storage_counters"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+dht_storage_counters&labels=documentation&body=Documentation+under+heading+%22class+dht_storage_counters%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="dht-storage-counters">
<h1>dht_storage_counters</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/kademlia/dht_storage.hpp">libtorrent/kademlia/dht_storage.hpp</a>&quot;</p>
<p>This structure hold the relevant <a class="reference external" href="reference-Stats.html#counters">counters</a> for the storage</p>
<pre class="literal-block">
struct dht_storage_counters
{
   void <strong>reset</strong> ();

   std::int32_t <strong>torrents</strong>  = 0;
   std::int32_t <strong>peers</strong>  = 0;
   std::int32_t <strong>immutable_data</strong>  = 0;
   std::int32_t <strong>mutable_data</strong>  = 0;
};
</pre>
<a name="reset()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_storage_counters%3A%3A%5Breset%28%29%5D&labels=documentation&body=Documentation+under+heading+%22dht_storage_counters%3A%3A%5Breset%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="reset-3">
<h2>reset()</h2>
<pre class="literal-block">
void <strong>reset</strong> ();
</pre>
<p>This member function set the <a class="reference external" href="reference-Stats.html#counters">counters</a> to zero.</p>
<a name="dht_storage_interface"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+dht_storage_interface&labels=documentation&body=Documentation+under+heading+%22class+dht_storage_interface%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="dht-storage-interface">
<h1>dht_storage_interface</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/kademlia/dht_storage.hpp">libtorrent/kademlia/dht_storage.hpp</a>&quot;</p>
<p>The DHT storage interface is a pure virtual class that can
be implemented to customize how the data for the DHT is stored.</p>
<p>The default storage implementation uses three maps in RAM to save
the peers, mutable and immutable items and it's designed to
provide a fast and fully compliant behavior of the BEPs.</p>
<p>libtorrent comes with one built-in storage implementation:
<tt class="docutils literal">dht_default_storage</tt> (private non-accessible class). Its
constructor function is called <a class="reference external" href="reference-DHT.html#dht_default_storage_constructor()">dht_default_storage_constructor()</a>.
You should know that if this storage becomes full of DHT items,
the current implementation could degrade in performance.</p>
<pre class="literal-block">
struct dht_storage_interface
{
   virtual void <strong>update_node_ids</strong> (std::vector&lt;node_id&gt; const&amp; ids) = 0;
   virtual bool <strong>get_peers</strong> (sha1_hash const&amp; info_hash
      , bool noseed, bool scrape, address const&amp; requester
      , entry&amp; peers) const = 0;
   virtual void <strong>announce_peer</strong> (sha1_hash const&amp; info_hash
      , tcp::endpoint const&amp; endp
      , string_view name, bool seed) = 0;
   virtual bool <strong>get_immutable_item</strong> (sha1_hash const&amp; target
      , entry&amp; item) const = 0;
   virtual void <strong>put_immutable_item</strong> (sha1_hash const&amp; target
      , span&lt;char const&gt; buf
      , address const&amp; addr) = 0;
   virtual bool <strong>get_mutable_item_seq</strong> (sha1_hash const&amp; target
      , sequence_number&amp; seq) const = 0;
   virtual bool <strong>get_mutable_item</strong> (sha1_hash const&amp; target
      , sequence_number seq, bool force_fill
      , entry&amp; item) const = 0;
   virtual void <strong>put_mutable_item</strong> (sha1_hash const&amp; target
      , span&lt;char const&gt; buf
      , signature const&amp; sig
      , sequence_number seq
      , public_key const&amp; pk
      , span&lt;char const&gt; salt
      , address const&amp; addr) = 0;
   virtual int <strong>get_infohashes_sample</strong> (entry&amp; item) = 0;
   virtual void <strong>tick</strong> () = 0;
   virtual dht_storage_counters <strong>counters</strong> () const = 0;
};
</pre>
<a name="update_node_ids()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_storage_interface%3A%3A%5Bupdate_node_ids%28%29%5D&labels=documentation&body=Documentation+under+heading+%22dht_storage_interface%3A%3A%5Bupdate_node_ids%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="update-node-ids">
<h2>update_node_ids()</h2>
<pre class="literal-block">
virtual void <strong>update_node_ids</strong> (std::vector&lt;node_id&gt; const&amp; ids) = 0;
</pre>
<p>This member function notifies the list of all node's ids
of each DHT running inside libtorrent. It's advisable
that the concrete implementation keeps a copy of this list
for an eventual prioritization when deleting an element
to make room for a new one.</p>
<a name="get_peers()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_storage_interface%3A%3A%5Bget_peers%28%29%5D&labels=documentation&body=Documentation+under+heading+%22dht_storage_interface%3A%3A%5Bget_peers%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="get-peers">
<h2>get_peers()</h2>
<pre class="literal-block">
virtual bool <strong>get_peers</strong> (sha1_hash const&amp; info_hash
      , bool noseed, bool scrape, address const&amp; requester
      , entry&amp; peers) const = 0;
</pre>
<p>This function retrieve the peers tracked by the DHT
corresponding to the given info_hash. You can specify if
you want only seeds and/or you are scraping the data.</p>
<p>For future implementers:
If the torrent tracked contains a name, such a name
must be stored as a string in peers[&quot;n&quot;]</p>
<p>If the scrape parameter is true, you should fill these keys:</p>
<blockquote>
<dl class="docutils">
<dt>peers[&quot;BFpe&quot;]</dt>
<dd>with the standard bit representation of a
256 bloom filter containing the downloaders</dd>
<dt>peers[&quot;BFsd&quot;]</dt>
<dd>with the standard bit representation of a
256 bloom filter containing the seeders</dd>
</dl>
</blockquote>
<p>If the scrape parameter is false, you should fill the
key peers[&quot;values&quot;] with a list containing a subset of
peers tracked by the given info_hash. Such a list should
consider the value of <a class="reference external" href="reference-Settings.html#dht_max_peers_reply">settings_pack::dht_max_peers_reply</a>.
If noseed is true only peers marked as no seed should be included.</p>
<p>returns true if the maximum number of peers are stored
for this info_hash.</p>
<a name="announce_peer()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_storage_interface%3A%3A%5Bannounce_peer%28%29%5D&labels=documentation&body=Documentation+under+heading+%22dht_storage_interface%3A%3A%5Bannounce_peer%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="announce-peer">
<h2>announce_peer()</h2>
<pre class="literal-block">
virtual void <strong>announce_peer</strong> (sha1_hash const&amp; info_hash
      , tcp::endpoint const&amp; endp
      , string_view name, bool seed) = 0;
</pre>
<p>This function is named announce_peer for consistency with the
upper layers, but has nothing to do with networking. Its only
responsibility is store the peer in such a way that it's returned
in the <a class="reference external" href="reference-Bencoding.html#entry">entry</a> with the lookup_peers.</p>
<p>The <tt class="docutils literal">name</tt> parameter is the name of the torrent if provided in
the announce_peer DHT message. The length of this value should
have a maximum length in the final storage. The default
implementation truncate the value for a maximum of 50 characters.</p>
<a name="get_immutable_item()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_storage_interface%3A%3A%5Bget_immutable_item%28%29%5D&labels=documentation&body=Documentation+under+heading+%22dht_storage_interface%3A%3A%5Bget_immutable_item%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="get-immutable-item">
<h2>get_immutable_item()</h2>
<pre class="literal-block">
virtual bool <strong>get_immutable_item</strong> (sha1_hash const&amp; target
      , entry&amp; item) const = 0;
</pre>
<p>This function retrieves the immutable item given its target hash.</p>
<p>For future implementers:
The value should be returned as an <a class="reference external" href="reference-Bencoding.html#entry">entry</a> in the key item[&quot;v&quot;].</p>
<p>returns true if the item is found and the data is returned
inside the (<a class="reference external" href="reference-Bencoding.html#entry">entry</a>) out parameter item.</p>
<a name="put_immutable_item()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_storage_interface%3A%3A%5Bput_immutable_item%28%29%5D&labels=documentation&body=Documentation+under+heading+%22dht_storage_interface%3A%3A%5Bput_immutable_item%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="put-immutable-item">
<h2>put_immutable_item()</h2>
<pre class="literal-block">
virtual void <strong>put_immutable_item</strong> (sha1_hash const&amp; target
      , span&lt;char const&gt; buf
      , address const&amp; addr) = 0;
</pre>
<p>Store the item's data. This layer is only for storage.
The authentication of the item is performed by the upper layer.</p>
<p>For implementers:
This data can be stored only if the target is not already
present. The implementation should consider the value of
<a class="reference external" href="reference-Settings.html#dht_max_dht_items">settings_pack::dht_max_dht_items</a>.</p>
<a name="get_mutable_item_seq()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_storage_interface%3A%3A%5Bget_mutable_item_seq%28%29%5D&labels=documentation&body=Documentation+under+heading+%22dht_storage_interface%3A%3A%5Bget_mutable_item_seq%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="get-mutable-item-seq">
<h2>get_mutable_item_seq()</h2>
<pre class="literal-block">
virtual bool <strong>get_mutable_item_seq</strong> (sha1_hash const&amp; target
      , sequence_number&amp; seq) const = 0;
</pre>
<p>This function retrieves the sequence number of a mutable item.</p>
<p>returns true if the item is found and the data is returned
inside the out parameter seq.</p>
<a name="get_mutable_item()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_storage_interface%3A%3A%5Bget_mutable_item%28%29%5D&labels=documentation&body=Documentation+under+heading+%22dht_storage_interface%3A%3A%5Bget_mutable_item%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="get-mutable-item">
<h2>get_mutable_item()</h2>
<pre class="literal-block">
virtual bool <strong>get_mutable_item</strong> (sha1_hash const&amp; target
      , sequence_number seq, bool force_fill
      , entry&amp; item) const = 0;
</pre>
<p>This function retrieves the mutable stored in the DHT.</p>
<p>For implementers:
The item sequence should be stored in the key item[&quot;seq&quot;].
if force_fill is true or (0 &lt;= seq and seq &lt; item[&quot;seq&quot;])
the following keys should be filled
item[&quot;v&quot;] - with the value no encoded.
item[&quot;sig&quot;] - with a string representation of the signature.
item[&quot;k&quot;] - with a string representation of the public key.</p>
<p>returns true if the item is found and the data is returned
inside the (<a class="reference external" href="reference-Bencoding.html#entry">entry</a>) out parameter item.</p>
<a name="put_mutable_item()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_storage_interface%3A%3A%5Bput_mutable_item%28%29%5D&labels=documentation&body=Documentation+under+heading+%22dht_storage_interface%3A%3A%5Bput_mutable_item%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="put-mutable-item">
<h2>put_mutable_item()</h2>
<pre class="literal-block">
virtual void <strong>put_mutable_item</strong> (sha1_hash const&amp; target
      , span&lt;char const&gt; buf
      , signature const&amp; sig
      , sequence_number seq
      , public_key const&amp; pk
      , span&lt;char const&gt; salt
      , address const&amp; addr) = 0;
</pre>
<p>Store the item's data. This layer is only for storage.
The authentication of the item is performed by the upper layer.</p>
<p>For implementers:
The sequence number should be checked if the item is already
present. The implementation should consider the value of
<a class="reference external" href="reference-Settings.html#dht_max_dht_items">settings_pack::dht_max_dht_items</a>.</p>
<a name="get_infohashes_sample()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_storage_interface%3A%3A%5Bget_infohashes_sample%28%29%5D&labels=documentation&body=Documentation+under+heading+%22dht_storage_interface%3A%3A%5Bget_infohashes_sample%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="get-infohashes-sample">
<h2>get_infohashes_sample()</h2>
<pre class="literal-block">
virtual int <strong>get_infohashes_sample</strong> (entry&amp; item) = 0;
</pre>
<p>This function retrieves a sample info-hashes</p>
<p>For implementers:
The info-hashes should be stored in [&quot;samples&quot;] (N x 20 bytes).
the following keys should be filled
item[&quot;interval&quot;] - the subset refresh interval in seconds.
item[&quot;num&quot;] - number of info-hashes in storage.</p>
<p>Internally, this function is allowed to lazily evaluate, cache
and modify the actual sample to put in <tt class="docutils literal">item</tt></p>
<p>returns the number of info-hashes in the sample.</p>
<a name="tick()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_storage_interface%3A%3A%5Btick%28%29%5D&labels=documentation&body=Documentation+under+heading+%22dht_storage_interface%3A%3A%5Btick%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="tick-2">
<h2>tick()</h2>
<pre class="literal-block">
virtual void <strong>tick</strong> () = 0;
</pre>
<p>This function is called periodically (non-constant frequency).</p>
<p>For implementers:
Use this functions for expire peers or items or any other
storage cleanup.</p>
<a name="counters()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_storage_interface%3A%3A%5Bcounters%28%29%5D&labels=documentation&body=Documentation+under+heading+%22dht_storage_interface%3A%3A%5Bcounters%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="counters-2">
<h2>counters()</h2>
<pre class="literal-block">
virtual dht_storage_counters <strong>counters</strong> () const = 0;
</pre>
<p>return stats <a class="reference external" href="reference-Stats.html#counters">counters</a> for the store</p>
<a name="dht_default_storage_constructor()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:dht_default_storage_constructor%28%29&labels=documentation&body=Documentation+under+heading+%22dht_default_storage_constructor%28%29%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="dht-default-storage-constructor">
<h1>dht_default_storage_constructor()</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/kademlia/dht_storage.hpp">libtorrent/kademlia/dht_storage.hpp</a>&quot;</p>
<pre class="literal-block">
std::unique_ptr&lt;dht_storage_interface&gt; <strong>dht_default_storage_constructor</strong> (
   settings_interface const&amp; settings);
</pre>
<p>constructor for the default DHT storage. The DHT storage is responsible
for maintaining peers and mutable and immutable items announced and
stored/put to the DHT node.</p>
<a name="sign_mutable_item()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:sign_mutable_item%28%29&labels=documentation&body=Documentation+under+heading+%22sign_mutable_item%28%29%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="sign-mutable-item">
<h1>sign_mutable_item()</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/kademlia/item.hpp">libtorrent/kademlia/item.hpp</a>&quot;</p>
<pre class="literal-block">
signature <strong>sign_mutable_item</strong> (
   span&lt;char const&gt; v
   , span&lt;char const&gt; salt
   , sequence_number seq
   , public_key const&amp; pk
   , secret_key const&amp; sk);
</pre>
<p>given a byte range <tt class="docutils literal">v</tt> and an optional byte range <tt class="docutils literal">salt</tt>, a
sequence number, public key <tt class="docutils literal">pk</tt> (must be 32 bytes) and a secret key
<tt class="docutils literal">sk</tt> (must be 64 bytes), this function produces a signature which
is written into a 64 byte buffer pointed to by <tt class="docutils literal">sig</tt>. The caller
is responsible for allocating the destination buffer that's passed in
as the <tt class="docutils literal">sig</tt> argument. Typically it would be allocated on the stack.</p>
<a name="announce_flags_t"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:announce_flags_t&labels=documentation&body=Documentation+under+heading+%22announce_flags_t%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="announce-flags-t">
<h1>announce_flags_t</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/kademlia/announce_flags.hpp">libtorrent/kademlia/announce_flags.hpp</a>&quot;</p>
<a name="announce_flags_t::seed"></a><dl class="docutils">
<dt>seed</dt>
<dd>announce to DHT as a seed</dd>
</dl>
<a name="announce_flags_t::implied_port"></a><dl class="docutils">
<dt>implied_port</dt>
<dd>announce to DHT with the implied-port flag set. This tells the network to use
your source UDP port as your listen port, rather than the one specified in
the message. This may improve the chances of traversing NATs when using uTP.</dd>
</dl>
<a name="announce_flags_t::ssl_torrent"></a><dl class="docutils">
<dt>ssl_torrent</dt>
<dd>Specify the port number for the SSL listen socket in the DHT announce.</dd>
</dl>
<a name="read_resume_data()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:read_resume_data%28%29&labels=documentation&body=Documentation+under+heading+%22read_resume_data%28%29%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="read-resume-data">
<h1>read_resume_data()</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/read_resume_data.hpp">libtorrent/read_resume_data.hpp</a>&quot;</p>
<pre class="literal-block">
add_torrent_params <strong>read_resume_data</strong> (span&lt;char const&gt; buffer
   , error_code&amp; ec, load_torrent_limits const&amp; cfg = {});
add_torrent_params <strong>read_resume_data</strong> (bdecode_node const&amp; rd
   , error_code&amp; ec, int piece_limit = 0x200000);
add_torrent_params <strong>read_resume_data</strong> (span&lt;char const&gt; buffer
   , load_torrent_limits const&amp; cfg = {});
add_torrent_params <strong>read_resume_data</strong> (bdecode_node const&amp; rd
   , int piece_limit = 0x200000);
</pre>
<p>these functions are used to parse resume data and populate the appropriate
fields in an <a class="reference external" href="reference-Add_Torrent.html#add_torrent_params">add_torrent_params</a> object. This object can then be used to add
the actual <a class="reference external" href="reference-Torrent_Info.html#torrent_info">torrent_info</a> object to and pass to session::add_torrent() or
session::async_add_torrent().</p>
<p>If the client wants to override any field that was loaded from the resume
data, e.g. save_path, those fields must be changed after loading resume
data but before adding the torrent.</p>
<p>The <tt class="docutils literal">piece_limit</tt> parameter determines the largest number of pieces
allowed in the torrent that may be loaded as part of the resume data, if
it contains an <tt class="docutils literal">info</tt> field. The overloads that take a flat buffer are
instead configured with limits on torrent sizes via load_torrent limits.</p>
<p>In order to support large torrents, it may also be necessary to raise the
<a class="reference external" href="reference-Settings.html#max_piece_count">settings_pack::max_piece_count</a> setting and pass a higher limit to calls
to <a class="reference external" href="reference-Torrent_Info.html#parse_info_section()">torrent_info::parse_info_section()</a>.</p>
<a name="write_resume_data()"></a>
<a name="write_resume_data_buf()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:write_resume_data%28%29+write_resume_data_buf%28%29&labels=documentation&body=Documentation+under+heading+%22write_resume_data%28%29+write_resume_data_buf%28%29%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="write-resume-data-write-resume-data-buf">
<h1>write_resume_data() write_resume_data_buf()</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/write_resume_data.hpp">libtorrent/write_resume_data.hpp</a>&quot;</p>
<pre class="literal-block">
std::vector&lt;char&gt; <strong>write_resume_data_buf</strong> (add_torrent_params const&amp; atp);
entry <strong>write_resume_data</strong> (add_torrent_params const&amp; atp);
</pre>
<p>this function turns the resume data in an <tt class="docutils literal">add_torrent_params</tt> object
into a bencoded structure</p>
<a name="write_torrent_file()"></a>
<a name="write_torrent_file_buf()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:write_torrent_file%28%29+write_torrent_file_buf%28%29&labels=documentation&body=Documentation+under+heading+%22write_torrent_file%28%29+write_torrent_file_buf%28%29%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="write-torrent-file-write-torrent-file-buf">
<h1>write_torrent_file() write_torrent_file_buf()</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/write_resume_data.hpp">libtorrent/write_resume_data.hpp</a>&quot;</p>
<pre class="literal-block">
entry <strong>write_torrent_file</strong> (add_torrent_params const&amp; atp, write_torrent_flags_t flags);
std::vector&lt;char&gt; <strong>write_torrent_file_buf</strong> (add_torrent_params const&amp; atp
   , write_torrent_flags_t flags);
entry <strong>write_torrent_file</strong> (add_torrent_params const&amp; atp);
</pre>
<p>writes only the fields to create a .torrent file. This function may fail
with a <tt class="docutils literal"><span class="pre">std::system_error</span></tt> exception if:</p>
<ul class="simple">
<li>The <a class="reference external" href="reference-Add_Torrent.html#add_torrent_params">add_torrent_params</a> object passed to this function does not contain the
info dictionary (the <tt class="docutils literal">ti</tt> field)</li>
<li>The piece layers are not complete for all files that need them</li>
</ul>
<p>The <tt class="docutils literal">write_torrent_file_buf()</tt> overload returns the torrent file in
bencoded buffer form. This overload may be faster at the expense of lost
flexibility to add custom fields.</p>
<a name="write_torrent_flags_t"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:write_torrent_flags_t&labels=documentation&body=Documentation+under+heading+%22write_torrent_flags_t%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="write-torrent-flags-t">
<h1>write_torrent_flags_t</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/write_resume_data.hpp">libtorrent/write_resume_data.hpp</a>&quot;</p>
<a name="write_torrent_flags_t::allow_missing_piece_layer"></a><dl class="docutils">
<dt>allow_missing_piece_layer</dt>
<dd>this makes <a class="reference external" href="reference-Resume_Data.html#write_torrent_file()">write_torrent_file()</a> not fail when attempting to write a
v2 torrent file that does not have all the piece layers</dd>
</dl>
<a name="write_torrent_flags_t::no_http_seeds"></a><dl class="docutils">
<dt>no_http_seeds</dt>
<dd>don't include http seeds in the torrent file, even if some are
present in the <a class="reference external" href="reference-Add_Torrent.html#add_torrent_params">add_torrent_params</a> object</dd>
</dl>
<a name="write_torrent_flags_t::include_dht_nodes"></a><dl class="docutils">
<dt>include_dht_nodes</dt>
<dd>When set, DHT nodes from the <a class="reference external" href="reference-Add_Torrent.html#add_torrent_params">add_torrent_params</a> objects are included
in the resulting .torrent file</dd>
</dl>
<a name="ed25519_create_seed()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:ed25519_create_seed%28%29&labels=documentation&body=Documentation+under+heading+%22ed25519_create_seed%28%29%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="ed25519-create-seed">
<h1>ed25519_create_seed()</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/kademlia/ed25519.hpp">libtorrent/kademlia/ed25519.hpp</a>&quot;</p>
<pre class="literal-block">
std::array&lt;char, 32&gt; <strong>ed25519_create_seed</strong> ();
</pre>
<p>See documentation of internal random_bytes</p>
<a name="ed25519_create_keypair()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:ed25519_create_keypair%28%29&labels=documentation&body=Documentation+under+heading+%22ed25519_create_keypair%28%29%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="ed25519-create-keypair">
<h1>ed25519_create_keypair()</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/kademlia/ed25519.hpp">libtorrent/kademlia/ed25519.hpp</a>&quot;</p>
<pre class="literal-block">
std::tuple&lt;public_key, secret_key&gt; <strong>ed25519_create_keypair</strong> (
   std::array&lt;char, 32&gt; const&amp; seed);
</pre>
<p>Creates a new key pair from the given seed.</p>
<p>It's important to clarify that the seed completely determines
the key pair. Then it's enough to save the seed and the
public key as the key-pair in a buffer of 64 bytes. The standard
is (32 bytes seed, 32 bytes public key).</p>
<p>This function does work with a given seed, giving you a pair of
(64 bytes private key, 32 bytes public key). It's a trade-off between
space and CPU, saving in one format or another.</p>
<p>The smaller format is not weaker by any means, in fact, it is only
the seed (32 bytes) that determines the point in the curve.</p>
<a name="ed25519_sign()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:ed25519_sign%28%29&labels=documentation&body=Documentation+under+heading+%22ed25519_sign%28%29%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="ed25519-sign">
<h1>ed25519_sign()</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/kademlia/ed25519.hpp">libtorrent/kademlia/ed25519.hpp</a>&quot;</p>
<pre class="literal-block">
signature <strong>ed25519_sign</strong> (span&lt;char const&gt; msg
   , public_key const&amp; pk, secret_key const&amp; sk);
</pre>
<p>Creates a signature of the given message with the given key pair.</p>
<a name="ed25519_verify()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:ed25519_verify%28%29&labels=documentation&body=Documentation+under+heading+%22ed25519_verify%28%29%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="ed25519-verify">
<h1>ed25519_verify()</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/kademlia/ed25519.hpp">libtorrent/kademlia/ed25519.hpp</a>&quot;</p>
<pre class="literal-block">
bool <strong>ed25519_verify</strong> (signature const&amp; sig
   , span&lt;char const&gt; msg, public_key const&amp; pk);
</pre>
<p>Verifies the signature on the given message using <tt class="docutils literal">pk</tt></p>
<a name="ed25519_add_scalar()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:ed25519_add_scalar%28%29&labels=documentation&body=Documentation+under+heading+%22ed25519_add_scalar%28%29%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="ed25519-add-scalar">
<h1>ed25519_add_scalar()</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/kademlia/ed25519.hpp">libtorrent/kademlia/ed25519.hpp</a>&quot;</p>
<pre class="literal-block">
public_key <strong>ed25519_add_scalar</strong> (public_key const&amp; pk
   , std::array&lt;char, 32&gt; const&amp; scalar);
secret_key <strong>ed25519_add_scalar</strong> (secret_key const&amp; sk
   , std::array&lt;char, 32&gt; const&amp; scalar);
</pre>
<p>Adds a scalar to the given key pair where scalar is a 32 byte buffer
(possibly generated with <cite>ed25519_create_seed</cite>), generating a new key pair.</p>
<p>You can calculate the public key sum without knowing the private key and
vice versa by passing in null for the key you don't know. This is useful
when a third party (an authoritative server for example) needs to enforce
randomness on a key pair while only knowing the public key of the other
side.</p>
<p>Warning: the last bit of the scalar is ignored - if comparing scalars make
sure to clear it with <cite>scalar[31] &amp;= 127</cite>.</p>
<p>see <a class="reference external" href="http://crypto.stackexchange.com/a/6215/4697">http://crypto.stackexchange.com/a/6215/4697</a>
see test_ed25519 for a practical example</p>
<a name="ed25519_key_exchange()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:ed25519_key_exchange%28%29&labels=documentation&body=Documentation+under+heading+%22ed25519_key_exchange%28%29%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="ed25519-key-exchange">
<h1>ed25519_key_exchange()</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/kademlia/ed25519.hpp">libtorrent/kademlia/ed25519.hpp</a>&quot;</p>
<pre class="literal-block">
std::array&lt;char, 32&gt; <strong>ed25519_key_exchange</strong> (
   public_key const&amp; pk, secret_key const&amp; sk);
</pre>
<p>Performs a key exchange on the given public key and private key, producing a
shared secret. It is recommended to hash the shared secret before using it.</p>
<p>This is useful when two parties want to share a secret but both only knows
their respective public keys.
see test_ed25519 for a practical example</p>
</div>

    </div>
    </div>
    <div id="gradient"></div>
    <div id="filler">
    <div id="footer">
    <div><a href="index.html">home</a></div>
    <div><a href="https://blog.libtorrent.org">blog</a></div>
    <div><a href="utp.html">uTP</a></div>
    <div><a href="https://sourceforge.net/projects/libtorrent/files/libtorrent/">download</a></div>
    <div><a href="reference.html">documentation</a></div>
    <div><a href="dht_store.html">DHT put extension</a></div>
    <div><a href="python_binding.html">python bindings</a></div>
    <div><a href="features-ref.html">features</a></div>
    <div><a href="dht_sec.html">DHT security extension</a></div>
    <div><a href="https://sourceforge.net/p/libtorrent/mailman/libtorrent-discuss/">mailing list archive</a></div>
    <div><a href="contributing.html">contributing</a></div>
    <div><a href="streaming.html">streaming</a></div>
    <div><a href="https://github.com/arvidn/libtorrent/issues">report a bug</a></div>
    <div><a href="building.html">building</a></div>
    <div><a href="bittorrent.pdf">bittorrent slides</a></div>
    </div>
	</div>

</div>
</body>
</html>
