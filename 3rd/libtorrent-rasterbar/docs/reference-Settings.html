<!DOCTYPE html>
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<title>libtorrent</title>
<meta name="description" content="A feature complete BitTorrent protocol implementation as a C++ library">
<meta name=viewport content="width=device-width, initial-scale=1">
<meta property="og:image" content="img/logo-color.png" />
<meta property="og:site_name" content="libtorrent" />
<link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body>
<div class="document">
    <div id="container">
    <a href="index.html">
    <img src="img/logo-color-text.png" alt="libtorrent logo"/>
    </a>
    <div>

<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Version:</th>
<td>2.0.11</td></tr>
</tbody>
</table>
<p><a class="reference external" href="reference.html">home</a></p>
<div class="contents topic" id="table-of-contents">
<p class="topic-title">Table of contents</p>
<ul class="simple">
<li><a class="reference internal" href="#settings-pack" id="toc-entry-1">settings_pack</a><ul>
<li><a class="reference internal" href="#set-int-set-bool-set-str" id="toc-entry-2">set_int() set_bool() set_str()</a></li>
<li><a class="reference internal" href="#has-val" id="toc-entry-3">has_val()</a></li>
<li><a class="reference internal" href="#clear" id="toc-entry-4">clear()</a></li>
<li><a class="reference internal" href="#clear-1" id="toc-entry-5">clear()</a></li>
<li><a class="reference internal" href="#get-str-get-int-get-bool" id="toc-entry-6">get_str() get_int() get_bool()</a></li>
<li><a class="reference internal" href="#enum-type-bases" id="toc-entry-7">enum type_bases</a></li>
<li><a class="reference internal" href="#enum-mmap-write-mode-t" id="toc-entry-8">enum mmap_write_mode_t</a></li>
<li><a class="reference internal" href="#enum-suggest-mode-t" id="toc-entry-9">enum suggest_mode_t</a></li>
<li><a class="reference internal" href="#enum-choking-algorithm-t" id="toc-entry-10">enum choking_algorithm_t</a></li>
<li><a class="reference internal" href="#enum-seed-choking-algorithm-t" id="toc-entry-11">enum seed_choking_algorithm_t</a></li>
<li><a class="reference internal" href="#enum-io-buffer-mode-t" id="toc-entry-12">enum io_buffer_mode_t</a></li>
<li><a class="reference internal" href="#enum-bandwidth-mixed-algo-t" id="toc-entry-13">enum bandwidth_mixed_algo_t</a></li>
<li><a class="reference internal" href="#enum-enc-policy" id="toc-entry-14">enum enc_policy</a></li>
<li><a class="reference internal" href="#enum-enc-level" id="toc-entry-15">enum enc_level</a></li>
<li><a class="reference internal" href="#enum-proxy-type-t" id="toc-entry-16">enum proxy_type_t</a></li>
</ul>
</li>
<li><a class="reference internal" href="#min-memory-usage-high-performance-seed" id="toc-entry-17">min_memory_usage() high_performance_seed()</a></li>
<li><a class="reference internal" href="#name-for-setting-setting-by-name" id="toc-entry-18">name_for_setting() setting_by_name()</a></li>
<li><a class="reference internal" href="#default-settings" id="toc-entry-19">default_settings()</a></li>
<li><a class="reference internal" href="#generate-fingerprint" id="toc-entry-20">generate_fingerprint()</a></li>
</ul>
</div>
<p>You have some control over <a class="reference external" href="reference-Session.html#session">session</a> configuration through the session::apply_settings()
member function. To change one or more configuration options, create a <a class="reference external" href="reference-Settings.html#settings_pack">settings_pack</a>
object and fill it with the settings to be set and pass it in to session::apply_settings().</p>
<p>The <a class="reference external" href="reference-Settings.html#settings_pack">settings_pack</a> object is a collection of settings updates that are applied
to the <a class="reference external" href="reference-Session.html#session">session</a> when passed to session::apply_settings(). It's empty when
constructed.</p>
<p>You have control over proxy and authorization settings and also the user-agent
that will be sent to the tracker. The user-agent will also be used to identify the
client with other peers.</p>
<p>Each configuration option is named with an enum value inside the
<a class="reference external" href="reference-Settings.html#settings_pack">settings_pack</a> class. These are the available settings:</p>
<a name="settings_pack"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+settings_pack&labels=documentation&body=Documentation+under+heading+%22class+settings_pack%22+could+be+improved">report issue</a>]</span><div class="section" id="settings-pack">
<h1>settings_pack</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/settings_pack.hpp">libtorrent/settings_pack.hpp</a>&quot;</p>
<p>The <tt class="docutils literal">settings_pack</tt> struct, contains the names of all settings as
enum values. These values are passed in to the <tt class="docutils literal">set_str()</tt>,
<tt class="docutils literal">set_int()</tt>, <tt class="docutils literal">set_bool()</tt> functions, to specify the setting to
change.</p>
<p>The <tt class="docutils literal">settings_pack</tt> only stores values for settings that have been
explicitly set on this object. However, it can still be queried for
settings that have not been set and returns the default value for those
settings.</p>
<a name="user_agent"></a><table border="1" class="docutils">
<colgroup>
<col width="36%" />
<col width="24%" />
<col width="39%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>user_agent</td>
<td>string</td>
<td>libtorrent/</td>
</tr>
</tbody>
</table>
<p>this is the client identification to the tracker. The recommended
format of this string is: &quot;client-name/client-version
libtorrent/libtorrent-version&quot;. This name will not only be used when
making HTTP requests, but also when sending extended headers to
peers that support that extension. It may not contain r or n</p>
<a name="announce_ip"></a><table border="1" class="docutils">
<colgroup>
<col width="43%" />
<col width="27%" />
<col width="30%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>announce_ip</td>
<td>string</td>
<td>nullptr</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">announce_ip</tt> is the ip address passed along to trackers as the
<tt class="docutils literal">&amp;ip=</tt> parameter. If left as the default, that parameter is
omitted.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This setting is only meant for very special cases where a seed is
running on the same host as the tracker, and the tracker accepts
the IP parameter (which normal trackers don't). Do not set this
option unless you also control the tracker.</p>
</div>
<a name="handshake_client_version"></a><table border="1" class="docutils">
<colgroup>
<col width="60%" />
<col width="19%" />
<col width="21%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>handshake_client_version</td>
<td>string</td>
<td>nullptr</td>
</tr>
</tbody>
</table>
<p>this is the client name and version identifier sent to peers in the
handshake message. If this is an empty string, the user_agent is
used instead. This string must be a UTF-8 encoded unicode string.</p>
<a name="outgoing_interfaces"></a><table border="1" class="docutils">
<colgroup>
<col width="55%" />
<col width="21%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>outgoing_interfaces</td>
<td>string</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<p>This controls which IP address outgoing TCP peer connections are bound
to, in addition to controlling whether such connections are also
bound to a specific network interface/adapter (<em>bind-to-device</em>).</p>
<p>This string is a comma-separated list of IP addresses and
interface names. An empty string will not bind TCP sockets to a
device, and let the network stack assign the local address.</p>
<p>A list of names will be used to bind outgoing TCP sockets in a
round-robin fashion. An IP address will simply be used to <cite>bind()</cite>
the socket. An interface name will attempt to bind the socket to
that interface. If that fails, or is unsupported, one of the IP
addresses configured for that interface is used to <cite>bind()</cite> the
socket to. If the interface or adapter doesn't exist, the
outgoing peer connection will fail with an error message suggesting
the device cannot be found. Adapter names on Unix systems are of
the form &quot;eth0&quot;, &quot;eth1&quot;, &quot;tun0&quot;, etc. This may be useful for
clients that are multi-homed. Binding an outgoing connection to a
local IP does not necessarily make the connection via the
associated NIC/Adapter.</p>
<p>When outgoing interfaces are specified, incoming connections or
packets sent to a local interface or IP that's <em>not</em> in this list
will be rejected with a <a class="reference external" href="reference-Alerts.html#peer_blocked_alert">peer_blocked_alert</a> with
<tt class="docutils literal">invalid_local_interface</tt> as the reason.</p>
<p>Note that these are just interface/adapter names or IP addresses.
There are no ports specified in this list. IPv6 addresses without
port should be specified without enclosing <tt class="docutils literal">[</tt>, <tt class="docutils literal">]</tt>.</p>
<a name="listen_interfaces"></a><table border="1" class="docutils">
<colgroup>
<col width="37%" />
<col width="16%" />
<col width="47%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>listen_interfaces</td>
<td>string</td>
<td>0.0.0.0:6881,[::]:6881</td>
</tr>
</tbody>
</table>
<p>a comma-separated list of (IP or device name, port) pairs. These are
the listen ports that will be opened for accepting incoming uTP and
TCP peer connections. These are also used for <em>outgoing</em> uTP and UDP
tracker connections and DHT nodes.</p>
<p>It is possible to listen on multiple interfaces and
multiple ports. Binding to port 0 will make the operating system
pick the port.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">There are reasons to stick to the same port across sessions,
which would mean only using port 0 on the first start, and
recording the port that was picked for subsequent startups.
Trackers, the DHT and other peers will remember the port they see
you use and hand that port out to other peers trying to connect
to you, as well as trying to connect to you themselves.</p>
</div>
<p>A port that has an &quot;s&quot; suffix will accept SSL peer connections. (note
that SSL sockets are only available in builds with SSL support)</p>
<p>A port that has an &quot;l&quot; suffix will be considered a local network.
i.e. it's assumed to only be able to reach hosts in the same local
network as the IP address (based on the netmask associated with the
IP, queried from the operating system).</p>
<p>if binding fails, the <a class="reference external" href="reference-Alerts.html#listen_failed_alert">listen_failed_alert</a> is posted. Once a
socket binding succeeds (if it does), the <a class="reference external" href="reference-Alerts.html#listen_succeeded_alert">listen_succeeded_alert</a>
is posted. There may be multiple failures before a success.</p>
<p>If a device name that does not exist is configured, no listen
socket will be opened for that interface. If this is the only
interface configured, it will be as if no listen ports are
configured.</p>
<p>If no listen ports are configured (e.g. listen_interfaces is an
empty string), networking will be disabled. No DHT will start, no
outgoing uTP or tracker connections will be made. No incoming TCP
or uTP connections will be accepted. (outgoing TCP connections
will still be possible, depending on
<a class="reference external" href="reference-Settings.html#outgoing_interfaces">settings_pack::outgoing_interfaces</a>).</p>
<p>For example:
<tt class="docutils literal"><span class="pre">[::1]:8888</span></tt> - will only accept connections on the IPv6 loopback
address on port 8888.</p>
<p><tt class="docutils literal">eth0:4444,eth1:4444</tt> - will accept connections on port 4444 on
any IP address bound to device <tt class="docutils literal">eth0</tt> or <tt class="docutils literal">eth1</tt>.</p>
<p><tt class="docutils literal"><span class="pre">[::]:0s</span></tt> - will accept SSL connections on a port chosen by the
OS. And not accept non-SSL connections at all.</p>
<p><tt class="docutils literal"><span class="pre">0.0.0.0:6881,[::]:6881</span></tt> - binds to all interfaces on port 6881.</p>
<p><tt class="docutils literal">10.0.1.13:6881l</tt> - binds to the local IP address, port 6881, but
only allow talking to peers on the same local network. The netmask
is queried from the operating system. Interfaces marked <tt class="docutils literal">l</tt> are
not announced to trackers, unless the tracker is also on the same
local network.</p>
<p>Windows OS network adapter device name must be specified with GUID.
It can be obtained from &quot;netsh lan show interfaces&quot; command output.
GUID must be uppercased string embraced in curly brackets.
<tt class="docutils literal"><span class="pre">{E4F0B674-0DFC-48BB-98A5-2AA730BDB6D6}:7777</span></tt> - will accept
connections on port 7777 on adapter with this GUID.</p>
<p>For more information, see the <a class="reference external" href="manual-ref.html#multi-homed-hosts">Multi-homed hosts</a> section.</p>
<a name="proxy_hostname"></a><table border="1" class="docutils">
<colgroup>
<col width="48%" />
<col width="24%" />
<col width="27%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>proxy_hostname</td>
<td>string</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<p>when using a proxy, this is the hostname where the proxy is running
see proxy_type. Note that when using a proxy, the
<a class="reference external" href="reference-Settings.html#listen_interfaces">settings_pack::listen_interfaces</a> setting is overridden and only a
single interface is created, just to contact the proxy. This
means a proxy cannot be combined with SSL torrents or multiple
listen interfaces. This proxy listen interface will not accept
incoming TCP connections, will not map ports with any gateway and
will not enable local service discovery. All traffic is supposed
to be channeled through the proxy.</p>
<a name="proxy_username"></a>
<a name="proxy_password"></a><table border="1" class="docutils">
<colgroup>
<col width="48%" />
<col width="24%" />
<col width="27%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>proxy_username</td>
<td>string</td>
<td>&nbsp;</td>
</tr>
<tr><td>proxy_password</td>
<td>string</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<p>when using a proxy, these are the credentials (if any) to use when
connecting to it. see proxy_type</p>
<a name="i2p_hostname"></a><table border="1" class="docutils">
<colgroup>
<col width="45%" />
<col width="26%" />
<col width="29%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>i2p_hostname</td>
<td>string</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<p>sets the <a class="reference external" href="http://www.i2p2.de">i2p</a> SAM bridge to connect to. set the port with the
<tt class="docutils literal">i2p_port</tt> setting. Unless this is set, i2p torrents are not
supported. This setting is separate from the other proxy settings
since i2p torrents and their peers are orthogonal. You can have
i2p peers as well as regular peers via a proxy.</p>
<a name="peer_fingerprint"></a><table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="22%" />
<col width="28%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>peer_fingerprint</td>
<td>string</td>
<td>-LT20B0-</td>
</tr>
</tbody>
</table>
<p>this is the fingerprint for the client. It will be used as the
prefix to the peer_id. If this is 20 bytes (or longer) it will be
truncated to 20 bytes and used as the entire peer-id</p>
<p>There is a utility function, <a class="reference external" href="reference-Settings.html#generate_fingerprint()">generate_fingerprint()</a> that can be used
to generate a standard client peer ID fingerprint prefix.</p>
<a name="dht_bootstrap_nodes"></a><table border="1" class="docutils">
<colgroup>
<col width="38%" />
<col width="15%" />
<col width="47%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>dht_bootstrap_nodes</td>
<td>string</td>
<td>dht.libtorrent.org:25401</td>
</tr>
</tbody>
</table>
<p>This is a comma-separated list of IP port-pairs. They will be added
to the DHT node (if it's enabled) as back-up nodes in case we don't
know of any.</p>
<p>Changing these after the DHT has been started may not have any
effect until the DHT is restarted.
Here are some other bootstrap nodes that may work:
<tt class="docutils literal">router.bittorrent.com:6881</tt>,
<tt class="docutils literal">dht.transmissionbt.com:6881</tt>
<tt class="docutils literal">router.bt.ouinet.work:6881</tt>,</p>
<a name="allow_multiple_connections_per_ip"></a><table border="1" class="docutils">
<colgroup>
<col width="70%" />
<col width="12%" />
<col width="18%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>allow_multiple_connections_per_ip</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>determines if connections from the same IP address as existing
connections should be rejected or not. Rejecting multiple connections
from the same IP address will prevent abusive
behavior by peers. The logic for determining whether connections are
to the same peer is more complicated with this enabled, and more
likely to fail in some edge cases. It is not recommended to enable
this feature.</p>
<a name="send_redundant_have"></a><table border="1" class="docutils">
<colgroup>
<col width="58%" />
<col width="17%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>send_redundant_have</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">send_redundant_have</tt> controls if have messages will be sent to
peers that already have the piece. This is typically not necessary,
but it might be necessary for collecting statistics in some cases.</p>
<a name="use_dht_as_fallback"></a><table border="1" class="docutils">
<colgroup>
<col width="58%" />
<col width="17%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>use_dht_as_fallback</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">use_dht_as_fallback</tt> determines how the DHT is used. If this is
true, the DHT will only be used for torrents where all trackers in
its tracker list has failed. Either by an explicit error message or
a time out. If this is false, the DHT is used regardless of if the
trackers fail or not.</p>
<a name="upnp_ignore_nonrouters"></a><table border="1" class="docutils">
<colgroup>
<col width="62%" />
<col width="15%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>upnp_ignore_nonrouters</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">upnp_ignore_nonrouters</tt> indicates whether or not the UPnP
implementation should ignore any broadcast response from a device
whose address is not on our subnet. i.e.
it's a way to not talk to other people's routers by mistake.</p>
<a name="use_parole_mode"></a><table border="1" class="docutils">
<colgroup>
<col width="53%" />
<col width="19%" />
<col width="28%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>use_parole_mode</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">use_parole_mode</tt> specifies if parole mode should be used. Parole
mode means that peers that participate in pieces that fail the hash
check are put in a mode where they are only allowed to download
whole pieces. If the whole piece a peer in parole mode fails the
hash check, it is banned. If a peer participates in a piece that
passes the hash check, it is taken out of parole mode.</p>
<a name="auto_manage_prefer_seeds"></a><table border="1" class="docutils">
<colgroup>
<col width="63%" />
<col width="15%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>auto_manage_prefer_seeds</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>if true, prefer seeding torrents when determining which torrents to give
active slots to. If false, give preference to downloading torrents</p>
<a name="dont_count_slow_torrents"></a><table border="1" class="docutils">
<colgroup>
<col width="63%" />
<col width="15%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>dont_count_slow_torrents</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>if <tt class="docutils literal">dont_count_slow_torrents</tt> is true, torrents without any
payload transfers are not subject to the <tt class="docutils literal">active_seeds</tt> and
<tt class="docutils literal">active_downloads</tt> limits. This is intended to make it more
likely to utilize all available bandwidth, and avoid having
torrents that don't transfer anything block the active slots.</p>
<a name="close_redundant_connections"></a><table border="1" class="docutils">
<colgroup>
<col width="66%" />
<col width="14%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>close_redundant_connections</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">close_redundant_connections</tt> specifies whether libtorrent should
close connections where both ends have no utility in keeping the
connection open. For instance if both ends have completed their
downloads, there's no point in keeping it open.</p>
<a name="prioritize_partial_pieces"></a><table border="1" class="docutils">
<colgroup>
<col width="64%" />
<col width="14%" />
<col width="21%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>prioritize_partial_pieces</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>If <tt class="docutils literal">prioritize_partial_pieces</tt> is true, partial pieces are picked
before pieces that are more rare. If false, rare pieces are always
prioritized, unless the number of partial pieces is growing out of
proportion.</p>
<a name="rate_limit_ip_overhead"></a><table border="1" class="docutils">
<colgroup>
<col width="62%" />
<col width="15%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>rate_limit_ip_overhead</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>if set to true, the estimated TCP/IP overhead is drained from the
rate limiters, to avoid exceeding the limits with the total traffic</p>
<a name="announce_to_all_tiers"></a>
<a name="announce_to_all_trackers"></a><table border="1" class="docutils">
<colgroup>
<col width="63%" />
<col width="15%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>announce_to_all_tiers</td>
<td>bool</td>
<td>false</td>
</tr>
<tr><td>announce_to_all_trackers</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">announce_to_all_trackers</tt> controls how multi tracker torrents
are treated. If this is set to true, all trackers in the same tier
are announced to in parallel. If all trackers in tier 0 fails, all
trackers in tier 1 are announced as well. If it's set to false, the
behavior is as defined by the multi tracker specification.</p>
<p><tt class="docutils literal">announce_to_all_tiers</tt> also controls how multi tracker torrents
are treated. When this is set to true, one tracker from each tier
is announced to. This is the uTorrent behavior. To be compliant
with the Multi-tracker specification, set it to false.</p>
<a name="prefer_udp_trackers"></a><table border="1" class="docutils">
<colgroup>
<col width="58%" />
<col width="17%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>prefer_udp_trackers</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">prefer_udp_trackers</tt>: true means that trackers
may be rearranged in a way that udp trackers are always tried
before http trackers for the same hostname. Setting this to false
means that the tracker's tier is respected and there's no
preference of one protocol over another.</p>
<a name="disable_hash_checks"></a><table border="1" class="docutils">
<colgroup>
<col width="58%" />
<col width="17%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>disable_hash_checks</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>when set to true, all data downloaded from peers will be assumed to
be correct, and not tested to match the hashes in the torrent this
is only useful for simulation and testing purposes (typically
combined with disabled_storage)</p>
<a name="allow_i2p_mixed"></a><table border="1" class="docutils">
<colgroup>
<col width="53%" />
<col width="19%" />
<col width="28%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>allow_i2p_mixed</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>if this is true, i2p torrents are allowed to also get peers from
other sources than the tracker, and connect to regular IPs, not
providing any anonymization. This may be useful if the user is not
interested in the anonymization of i2p, but still wants to be able
to connect to i2p peers.</p>
<a name="no_atime_storage"></a><table border="1" class="docutils">
<colgroup>
<col width="55%" />
<col width="18%" />
<col width="27%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>no_atime_storage</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">no_atime_storage</tt> this is a Linux-only option and passes in the
<tt class="docutils literal">O_NOATIME</tt> to <tt class="docutils literal">open()</tt> when opening files. This may lead to
some disk performance improvements.</p>
<a name="incoming_starts_queued_torrents"></a><table border="1" class="docutils">
<colgroup>
<col width="69%" />
<col width="13%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>incoming_starts_queued_torrents</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">incoming_starts_queued_torrents</tt>.  If a torrent
has been paused by the auto managed feature in libtorrent, i.e. the
torrent is paused and auto managed, this feature affects whether or
not it is automatically started on an incoming connection. The main
reason to queue torrents, is not to make them unavailable, but to
save on the overhead of announcing to the trackers, the DHT and to
avoid spreading one's unchoke slots too thin. If a peer managed to
find us, even though we're no in the torrent anymore, this setting
can make us start the torrent and serve it.</p>
<a name="report_true_downloaded"></a><table border="1" class="docutils">
<colgroup>
<col width="62%" />
<col width="15%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>report_true_downloaded</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>when set to true, the downloaded counter sent to trackers will
include the actual number of payload bytes downloaded including
redundant bytes. If set to false, it will not include any redundancy
bytes</p>
<a name="strict_end_game_mode"></a><table border="1" class="docutils">
<colgroup>
<col width="59%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>strict_end_game_mode</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">strict_end_game_mode</tt> controls when a
block may be requested twice. If this is <tt class="docutils literal">true</tt>, a block may only
be requested twice when there's at least one request to every piece
that's left to download in the torrent. This may slow down progress
on some pieces sometimes, but it may also avoid downloading a lot
of redundant bytes. If this is <tt class="docutils literal">false</tt>, libtorrent attempts to
use each peer connection to its max, by always requesting
something, even if it means requesting something that has been
requested from another peer already.</p>
<a name="enable_outgoing_utp"></a>
<a name="enable_incoming_utp"></a>
<a name="enable_outgoing_tcp"></a>
<a name="enable_incoming_tcp"></a><table border="1" class="docutils">
<colgroup>
<col width="58%" />
<col width="17%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>enable_outgoing_utp</td>
<td>bool</td>
<td>true</td>
</tr>
<tr><td>enable_incoming_utp</td>
<td>bool</td>
<td>true</td>
</tr>
<tr><td>enable_outgoing_tcp</td>
<td>bool</td>
<td>true</td>
</tr>
<tr><td>enable_incoming_tcp</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>Enables incoming and outgoing, TCP and uTP peer connections.
<tt class="docutils literal">false</tt> is disabled and <tt class="docutils literal">true</tt> is enabled. When outgoing
connections are disabled, libtorrent will simply not make
outgoing peer connections with the specific transport protocol.
Disabled incoming peer connections will simply be rejected.
These options only apply to peer connections, not tracker- or any
other kinds of connections.</p>
<a name="no_recheck_incomplete_resume"></a><table border="1" class="docutils">
<colgroup>
<col width="67%" />
<col width="13%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>no_recheck_incomplete_resume</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">no_recheck_incomplete_resume</tt> determines if the storage should
check the whole files when resume data is incomplete or missing or
whether it should simply assume we don't have any of the data. If
false, any existing files will be checked.
By setting this setting to true, the files won't be checked, but
will go straight to download mode.</p>
<a name="anonymous_mode"></a><table border="1" class="docutils">
<colgroup>
<col width="52%" />
<col width="19%" />
<col width="29%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>anonymous_mode</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">anonymous_mode</tt>: When set to true, the client tries to hide
its identity to a certain degree.</p>
<ul class="simple">
<li>A generic user-agent will be
used for trackers (except for private torrents).</li>
<li>Your local IPv4 and IPv6 address won't be sent as query string
parameters to private trackers.</li>
<li>If announce_ip is configured, it will not be sent to trackers</li>
<li>The client version will not be sent to peers in the extension
handshake.</li>
</ul>
<a name="report_web_seed_downloads"></a><table border="1" class="docutils">
<colgroup>
<col width="64%" />
<col width="14%" />
<col width="21%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>report_web_seed_downloads</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>specifies whether downloads from web seeds is reported to the
tracker or not. Turning it off also excludes web
seed traffic from other stats and download rate reporting via the
libtorrent API.</p>
<a name="seeding_outgoing_connections"></a><table border="1" class="docutils">
<colgroup>
<col width="67%" />
<col width="13%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>seeding_outgoing_connections</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">seeding_outgoing_connections</tt> determines if seeding (and
finished) torrents should attempt to make outgoing connections or
not. It may be set to false in very
specific applications where the cost of making outgoing connections
is high, and there are no or small benefits of doing so. For
instance, if no nodes are behind a firewall or a NAT, seeds don't
need to make outgoing connections.</p>
<a name="no_connect_privileged_ports"></a><table border="1" class="docutils">
<colgroup>
<col width="66%" />
<col width="14%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>no_connect_privileged_ports</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>when this is true, libtorrent will not attempt to make outgoing
connections to peers whose port is &lt; 1024. This is a safety
precaution to avoid being part of a DDoS attack</p>
<a name="smooth_connects"></a><table border="1" class="docutils">
<colgroup>
<col width="53%" />
<col width="19%" />
<col width="28%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>smooth_connects</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">smooth_connects</tt> means the number of
connection attempts per second may be limited to below the
<tt class="docutils literal">connection_speed</tt>, in case we're close to bump up against the
limit of number of connections. The intention of this setting is to
more evenly distribute our connection attempts over time, instead
of attempting to connect in batches, and timing them out in
batches.</p>
<a name="always_send_user_agent"></a><table border="1" class="docutils">
<colgroup>
<col width="62%" />
<col width="15%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>always_send_user_agent</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>always send user-agent in every web seed request. If false, only
the first request per http connection will include the user agent</p>
<a name="apply_ip_filter_to_trackers"></a><table border="1" class="docutils">
<colgroup>
<col width="66%" />
<col width="14%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>apply_ip_filter_to_trackers</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">apply_ip_filter_to_trackers</tt> determines
whether the IP filter applies to trackers as well as peers. If this
is set to false, trackers are exempt from the IP filter (if there
is one). If no IP filter is set, this setting is irrelevant.</p>
<a name="ban_web_seeds"></a><table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="20%" />
<col width="30%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>ban_web_seeds</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>when true, web seeds sending bad data will be banned</p>
<a name="support_share_mode"></a><table border="1" class="docutils">
<colgroup>
<col width="57%" />
<col width="17%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>support_share_mode</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>if false, prevents libtorrent to advertise share-mode support</p>
<a name="report_redundant_bytes"></a><table border="1" class="docutils">
<colgroup>
<col width="62%" />
<col width="15%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>report_redundant_bytes</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>if this is true, the number of redundant bytes is sent to the
tracker</p>
<a name="listen_system_port_fallback"></a><table border="1" class="docutils">
<colgroup>
<col width="66%" />
<col width="14%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>listen_system_port_fallback</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>if this is true, libtorrent will fall back to listening on a port
chosen by the operating system (i.e. binding to port 0). If a
failure is preferred, set this to false.</p>
<a name="announce_crypto_support"></a><table border="1" class="docutils">
<colgroup>
<col width="63%" />
<col width="15%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>announce_crypto_support</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>when this is true, and incoming encrypted connections are enabled,
&amp;supportcrypt=1 is included in http tracker announces</p>
<a name="enable_upnp"></a><table border="1" class="docutils">
<colgroup>
<col width="46%" />
<col width="21%" />
<col width="32%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>enable_upnp</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>Starts and stops the UPnP service. When started, the listen port
and the DHT port are attempted to be forwarded on local UPnP router
devices.</p>
<p>The upnp object returned by <tt class="docutils literal">start_upnp()</tt> can be used to add and
remove arbitrary port mappings. Mapping status is returned through
the <a class="reference external" href="reference-Alerts.html#portmap_alert">portmap_alert</a> and the <a class="reference external" href="reference-Alerts.html#portmap_error_alert">portmap_error_alert</a>. The object will be
valid until <tt class="docutils literal">stop_upnp()</tt> is called. See <a class="reference external" href="manual-ref.html#upnp-and-nat-pmp">upnp and nat pmp</a>.</p>
<a name="enable_natpmp"></a><table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="20%" />
<col width="30%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>enable_natpmp</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>Starts and stops the NAT-PMP service. When started, the listen port
and the DHT port are attempted to be forwarded on the router
through NAT-PMP.</p>
<p>The natpmp object returned by <tt class="docutils literal">start_natpmp()</tt> can be used to add
and remove arbitrary port mappings. Mapping status is returned
through the <a class="reference external" href="reference-Alerts.html#portmap_alert">portmap_alert</a> and the <a class="reference external" href="reference-Alerts.html#portmap_error_alert">portmap_error_alert</a>. The object
will be valid until <tt class="docutils literal">stop_natpmp()</tt> is called. See
<a class="reference external" href="manual-ref.html#upnp-and-nat-pmp">upnp and nat pmp</a>.</p>
<a name="enable_lsd"></a><table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="22%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>enable_lsd</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>Starts and stops Local Service Discovery. This service will
broadcast the info-hashes of all the non-private torrents on the
local network to look for peers on the same swarm within multicast
reach.</p>
<a name="enable_dht"></a><table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="22%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>enable_dht</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>starts the dht node and makes the trackerless service available to
torrents.</p>
<a name="prefer_rc4"></a><table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="22%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>prefer_rc4</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>if the allowed encryption level is both, setting this to true will
prefer RC4 if both methods are offered, plain text otherwise</p>
<a name="proxy_hostnames"></a><table border="1" class="docutils">
<colgroup>
<col width="53%" />
<col width="19%" />
<col width="28%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>proxy_hostnames</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>if true, hostname lookups are done via the configured proxy (if
any). This is only supported by SOCKS5 and HTTP.</p>
<a name="proxy_peer_connections"></a><table border="1" class="docutils">
<colgroup>
<col width="62%" />
<col width="15%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>proxy_peer_connections</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>if true, peer connections are made (and accepted) over the
configured proxy, if any. Web seeds as well as regular bittorrent
peer connections are considered &quot;peer connections&quot;. Anything
transporting actual torrent payload (trackers and DHT traffic are
not considered peer connections).</p>
<a name="auto_sequential"></a><table border="1" class="docutils">
<colgroup>
<col width="53%" />
<col width="19%" />
<col width="28%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>auto_sequential</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>if this setting is true, torrents with a very high availability of
pieces (and seeds) are downloaded sequentially. This is more
efficient for the disk I/O. With many seeds, the download order is
unlikely to matter anyway</p>
<a name="proxy_tracker_connections"></a><table border="1" class="docutils">
<colgroup>
<col width="64%" />
<col width="14%" />
<col width="21%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>proxy_tracker_connections</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>if true, tracker connections are made over the configured proxy, if
any.</p>
<a name="enable_ip_notifier"></a><table border="1" class="docutils">
<colgroup>
<col width="57%" />
<col width="17%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>enable_ip_notifier</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>Starts and stops the internal IP table route changes notifier.</p>
<p>The current implementation supports multiple platforms, and it is
recommended to have it enable, but you may want to disable it if
it's supported but unreliable, or if you have a better way to
detect the changes. In the later case, you should manually call
<tt class="docutils literal"><span class="pre">session_handle::reopen_network_sockets</span></tt> to ensure network
changes are taken in consideration.</p>
<a name="dht_prefer_verified_node_ids"></a><table border="1" class="docutils">
<colgroup>
<col width="67%" />
<col width="13%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>dht_prefer_verified_node_ids</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>when this is true, nodes whose IDs are derived from their source
IP according to <a class="reference external" href="https://www.bittorrent.org/beps/bep_0042.html">BEP 42</a> are preferred in the routing table.</p>
<a name="dht_restrict_routing_ips"></a><table border="1" class="docutils">
<colgroup>
<col width="63%" />
<col width="15%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>dht_restrict_routing_ips</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>determines if the routing table entries should restrict entries to one
per IP. This defaults to true, which helps mitigate some attacks on
the DHT. It prevents adding multiple nodes with IPs with a very close
CIDR distance.</p>
<p>when set, nodes whose IP address that's in the same /24 (or /64 for
IPv6) range in the same routing table bucket. This is an attempt to
mitigate node ID spoofing attacks also restrict any IP to only have a
single <a class="reference external" href="reference-Bencoding.html#entry">entry</a> in the whole routing table</p>
<a name="dht_restrict_search_ips"></a><table border="1" class="docutils">
<colgroup>
<col width="63%" />
<col width="15%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>dht_restrict_search_ips</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>determines if DHT searches should prevent adding nodes with IPs with
very close CIDR distance. This also defaults to true and helps
mitigate certain attacks on the DHT.</p>
<a name="dht_extended_routing_table"></a><table border="1" class="docutils">
<colgroup>
<col width="65%" />
<col width="14%" />
<col width="21%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>dht_extended_routing_table</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>makes the first buckets in the DHT routing table fit 128, 64, 32 and
16 nodes respectively, as opposed to the standard size of 8. All other
buckets have size 8 still.</p>
<a name="dht_aggressive_lookups"></a><table border="1" class="docutils">
<colgroup>
<col width="62%" />
<col width="15%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>dht_aggressive_lookups</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>slightly changes the lookup behavior in terms of how many outstanding
requests we keep. Instead of having branch factor be a hard limit, we
always keep <em>branch factor</em> outstanding requests to the closest nodes.
i.e. every time we get results back with closer nodes, we query them
right away. It lowers the lookup times at the cost of more outstanding
queries.</p>
<a name="dht_privacy_lookups"></a><table border="1" class="docutils">
<colgroup>
<col width="58%" />
<col width="17%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>dht_privacy_lookups</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>when set, perform lookups in a way that is slightly more expensive,
but which minimizes the amount of information leaked about you.</p>
<a name="dht_enforce_node_id"></a><table border="1" class="docutils">
<colgroup>
<col width="58%" />
<col width="17%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>dht_enforce_node_id</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>when set, node's whose IDs that are not correctly generated based on
its external IP are ignored. When a query arrives from such node, an
error message is returned with a message saying &quot;invalid node ID&quot;.</p>
<a name="dht_ignore_dark_internet"></a><table border="1" class="docutils">
<colgroup>
<col width="63%" />
<col width="15%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>dht_ignore_dark_internet</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>ignore DHT messages from parts of the internet we wouldn't expect to
see any traffic from</p>
<a name="dht_read_only"></a><table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="20%" />
<col width="30%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>dht_read_only</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>when set, the other nodes won't keep this node in their routing
tables, it's meant for low-power and/or ephemeral devices that
cannot support the DHT, it is also useful for mobile devices which
are sensitive to network traffic and battery life.
this node no longer responds to 'query' messages, and will place a
'ro' key (value = 1) in the top-level message dictionary of outgoing
query messages.</p>
<a name="piece_extent_affinity"></a><table border="1" class="docutils">
<colgroup>
<col width="61%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>piece_extent_affinity</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>when this is true, create an affinity for downloading 4 MiB extents
of adjacent pieces. This is an attempt to achieve better disk I/O
throughput by downloading larger extents of bytes, for torrents with
small piece sizes</p>
<a name="validate_https_trackers"></a><table border="1" class="docutils">
<colgroup>
<col width="63%" />
<col width="15%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>validate_https_trackers</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>when set to true, the certificate of HTTPS trackers and HTTPS web
seeds will be validated against the system's certificate store
(as defined by OpenSSL). If the system does not have a
certificate store, this option may have to be disabled in order
to get trackers and web seeds to work).</p>
<a name="ssrf_mitigation"></a><table border="1" class="docutils">
<colgroup>
<col width="53%" />
<col width="19%" />
<col width="28%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>ssrf_mitigation</td>
<td>bool</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>when enabled, tracker and web seed requests are subject to
certain restrictions.</p>
<p>An HTTP(s) tracker requests to localhost (loopback)
must have the request path start with &quot;/announce&quot;. This is the
conventional bittorrent tracker request. Any other HTTP(S)
tracker request to loopback will be rejected. This applies to
trackers that redirect to loopback as well.</p>
<p>Web seeds that end up on the client's local network (i.e. in a
private IP address range) may not include query string arguments.
This applies to web seeds redirecting to the local network as
well.</p>
<p>Web seeds on global IPs (i.e. not local network) may not redirect
to a local network address</p>
<a name="allow_idna"></a><table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="22%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>allow_idna</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>when disabled, any tracker or web seed with an IDNA hostname
(internationalized domain name) is ignored. This is a security
precaution to avoid various unicode encoding attacks that might
happen at the application level.</p>
<a name="enable_set_file_valid_data"></a><table border="1" class="docutils">
<colgroup>
<col width="65%" />
<col width="14%" />
<col width="21%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>enable_set_file_valid_data</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>when set to true, enables the attempt to use SetFileValidData()
to pre-allocate disk space. This system call will only work when
running with Administrator privileges on Windows, and so this
setting is only relevant in that scenario. Using
SetFileValidData() poses a security risk, as it may reveal
previously deleted information from the disk.</p>
<a name="socks5_udp_send_local_ep"></a><table border="1" class="docutils">
<colgroup>
<col width="63%" />
<col width="15%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>socks5_udp_send_local_ep</td>
<td>bool</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>When using a SOCKS5 proxy, UDP traffic is routed through the
proxy by sending a UDP ASSOCIATE command. If this option is true,
the UDP ASSOCIATE command will include the IP address and
listen port to the local UDP socket. This indicates to the proxy
which source endpoint to expect our packets from. The benefit is
that incoming packets can be forwarded correctly, before any
outgoing packets are sent. The risk is that if there's a NAT
between the client and the proxy, the IP address specified in the
protocol may not be valid from the proxy's point of view.</p>
<a name="tracker_completion_timeout"></a><table border="1" class="docutils">
<colgroup>
<col width="65%" />
<col width="14%" />
<col width="21%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>tracker_completion_timeout</td>
<td>int</td>
<td>30</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">tracker_completion_timeout</tt> is the number of seconds the tracker
connection will wait from when it sent the request until it
considers the tracker to have timed-out.</p>
<a name="tracker_receive_timeout"></a><table border="1" class="docutils">
<colgroup>
<col width="63%" />
<col width="15%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>tracker_receive_timeout</td>
<td>int</td>
<td>10</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">tracker_receive_timeout</tt> is the number of seconds to wait to
receive any data from the tracker. If no data is received for this
number of seconds, the tracker will be considered as having timed
out. If a tracker is down, this is the kind of timeout that will
occur.</p>
<a name="stop_tracker_timeout"></a><table border="1" class="docutils">
<colgroup>
<col width="59%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>stop_tracker_timeout</td>
<td>int</td>
<td>5</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">stop_tracker_timeout</tt> is the number of seconds to wait when
sending a stopped message before considering a tracker to have
timed out. This is usually shorter, to make the client quit faster.
If the value is set to 0, the connections to trackers with the
stopped event are suppressed.</p>
<a name="tracker_maximum_response_length"></a><table border="1" class="docutils">
<colgroup>
<col width="66%" />
<col width="12%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>tracker_maximum_response_length</td>
<td>int</td>
<td>1024*1024</td>
</tr>
</tbody>
</table>
<p>this is the maximum number of bytes in a tracker response. If a
response size passes this number of bytes it will be rejected and
the connection will be closed. On gzipped responses this size is
measured on the uncompressed data. So, if you get 20 bytes of gzip
response that'll expand to 2 megabytes, it will be interrupted
before the entire response has been uncompressed (assuming the
limit is lower than 2 MiB).</p>
<a name="piece_timeout"></a><table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="20%" />
<col width="30%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>piece_timeout</td>
<td>int</td>
<td>20</td>
</tr>
</tbody>
</table>
<p>the number of seconds from a request is sent until it times out if
no piece response is returned.</p>
<a name="request_timeout"></a><table border="1" class="docutils">
<colgroup>
<col width="53%" />
<col width="19%" />
<col width="28%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>request_timeout</td>
<td>int</td>
<td>60</td>
</tr>
</tbody>
</table>
<p>the number of seconds one block (16 kiB) is expected to be received
within. If it's not, the block is requested from a different peer</p>
<a name="request_queue_time"></a><table border="1" class="docutils">
<colgroup>
<col width="57%" />
<col width="17%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>request_queue_time</td>
<td>int</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>the length of the request queue given in the number of seconds it
should take for the other end to send all the pieces. i.e. the
actual number of requests depends on the download rate and this
number.</p>
<a name="max_allowed_in_request_queue"></a><table border="1" class="docutils">
<colgroup>
<col width="67%" />
<col width="13%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>max_allowed_in_request_queue</td>
<td>int</td>
<td>2000</td>
</tr>
</tbody>
</table>
<p>the number of outstanding block requests a peer is allowed to queue
up in the client. If a peer sends more requests than this (before
the first one has been sent) the last request will be dropped. the
higher this is, the faster upload speeds the client can get to a
single peer.</p>
<a name="max_out_request_queue"></a><table border="1" class="docutils">
<colgroup>
<col width="61%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>max_out_request_queue</td>
<td>int</td>
<td>500</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">max_out_request_queue</tt> is the maximum number of outstanding
requests to send to a peer. This limit takes precedence over
<tt class="docutils literal">request_queue_time</tt>. i.e. no matter the download speed, the
number of outstanding requests will never exceed this limit.</p>
<a name="whole_pieces_threshold"></a><table border="1" class="docutils">
<colgroup>
<col width="62%" />
<col width="15%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>whole_pieces_threshold</td>
<td>int</td>
<td>20</td>
</tr>
</tbody>
</table>
<p>if a whole piece can be downloaded in this number of seconds, or
less, the peer_connection will prefer to request whole pieces at a
time from this peer. The benefit of this is to better utilize disk
caches by doing localized accesses and also to make it easier to
identify bad peers if a piece fails the hash check.</p>
<a name="peer_timeout"></a><table border="1" class="docutils">
<colgroup>
<col width="48%" />
<col width="21%" />
<col width="31%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>peer_timeout</td>
<td>int</td>
<td>120</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">peer_timeout</tt> is the number of seconds the peer connection
should wait (for any activity on the peer connection) before
closing it due to time out. 120 seconds is
specified in the protocol specification. After half
the time out, a keep alive message is sent.</p>
<a name="urlseed_timeout"></a><table border="1" class="docutils">
<colgroup>
<col width="53%" />
<col width="19%" />
<col width="28%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>urlseed_timeout</td>
<td>int</td>
<td>20</td>
</tr>
</tbody>
</table>
<p>same as peer_timeout, but only applies to url-seeds. this is
usually set lower, because web servers are expected to be more
reliable.</p>
<a name="urlseed_pipeline_size"></a><table border="1" class="docutils">
<colgroup>
<col width="61%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>urlseed_pipeline_size</td>
<td>int</td>
<td>5</td>
</tr>
</tbody>
</table>
<p>controls the pipelining size of url and http seeds. i.e. the number of HTTP
request to keep outstanding before waiting for the first one to
complete. It's common for web servers to limit this to a relatively
low number, like 5</p>
<a name="urlseed_wait_retry"></a><table border="1" class="docutils">
<colgroup>
<col width="57%" />
<col width="17%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>urlseed_wait_retry</td>
<td>int</td>
<td>30</td>
</tr>
</tbody>
</table>
<p>number of seconds until a new retry of a url-seed takes place.
Default retry value for http-seeds that don't provide
a valid <tt class="docutils literal"><span class="pre">retry-after</span></tt> header.</p>
<a name="file_pool_size"></a><table border="1" class="docutils">
<colgroup>
<col width="52%" />
<col width="19%" />
<col width="29%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>file_pool_size</td>
<td>int</td>
<td>40</td>
</tr>
</tbody>
</table>
<p>sets the upper limit on the total number of files this <a class="reference external" href="reference-Session.html#session">session</a> will
keep open. The reason why files are left open at all is that some
anti virus software hooks on every file close, and scans the file
for viruses. deferring the closing of the files will be the
difference between a usable system and a completely hogged down
system. Most operating systems also has a limit on the total number
of file descriptors a process may have open.</p>
<a name="max_failcount"></a><table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="20%" />
<col width="30%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>max_failcount</td>
<td>int</td>
<td>3</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">max_failcount</tt> is the maximum times we try to
connect to a peer before stop connecting again. If a
peer succeeds, the failure counter is reset. If a
peer is retrieved from a peer source (other than DHT)
the failcount is decremented by one, allowing another
try.</p>
<a name="min_reconnect_time"></a><table border="1" class="docutils">
<colgroup>
<col width="57%" />
<col width="17%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>min_reconnect_time</td>
<td>int</td>
<td>60</td>
</tr>
</tbody>
</table>
<p>the number of seconds to wait to reconnect to a peer. this time is
multiplied with the failcount.</p>
<a name="peer_connect_timeout"></a><table border="1" class="docutils">
<colgroup>
<col width="59%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>peer_connect_timeout</td>
<td>int</td>
<td>15</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">peer_connect_timeout</tt> the number of seconds to wait after a
connection attempt is initiated to a peer until it is considered as
having timed out. This setting is especially important in case the
number of half-open connections are limited, since stale half-open
connection may delay the connection of other peers considerably.</p>
<a name="connection_speed"></a><table border="1" class="docutils">
<colgroup>
<col width="55%" />
<col width="18%" />
<col width="27%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>connection_speed</td>
<td>int</td>
<td>30</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">connection_speed</tt> is the number of connection attempts that are
made per second. If a number &lt; 0 is specified, it will default to
200 connections per second. If 0 is specified, it means don't make
outgoing connections at all.</p>
<a name="inactivity_timeout"></a><table border="1" class="docutils">
<colgroup>
<col width="57%" />
<col width="17%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>inactivity_timeout</td>
<td>int</td>
<td>600</td>
</tr>
</tbody>
</table>
<p>if a peer is uninteresting and uninterested for longer than this
number of seconds, it will be disconnected.</p>
<a name="unchoke_interval"></a><table border="1" class="docutils">
<colgroup>
<col width="55%" />
<col width="18%" />
<col width="27%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>unchoke_interval</td>
<td>int</td>
<td>15</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">unchoke_interval</tt> is the number of seconds between
chokes/unchokes. On this interval, peers are re-evaluated for being
choked/unchoked. This is defined as 30 seconds in the protocol, and
it should be significantly longer than what it takes for TCP to
ramp up to it's max rate.</p>
<a name="optimistic_unchoke_interval"></a><table border="1" class="docutils">
<colgroup>
<col width="66%" />
<col width="14%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>optimistic_unchoke_interval</td>
<td>int</td>
<td>30</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">optimistic_unchoke_interval</tt> is the number of seconds between
each <em>optimistic</em> unchoke. On this timer, the currently
optimistically unchoked peer will change.</p>
<a name="num_want"></a><table border="1" class="docutils">
<colgroup>
<col width="40%" />
<col width="24%" />
<col width="36%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>num_want</td>
<td>int</td>
<td>200</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">num_want</tt> is the number of peers we want from each tracker
request. It defines what is sent as the <tt class="docutils literal">&amp;num_want=</tt> parameter to
the tracker.</p>
<a name="initial_picker_threshold"></a><table border="1" class="docutils">
<colgroup>
<col width="63%" />
<col width="15%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>initial_picker_threshold</td>
<td>int</td>
<td>4</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">initial_picker_threshold</tt> specifies the number of pieces we need
before we switch to rarest first picking. The first
<tt class="docutils literal">initial_picker_threshold</tt> pieces in any torrent are picked at random
, the following pieces are picked in rarest first order.</p>
<a name="allowed_fast_set_size"></a><table border="1" class="docutils">
<colgroup>
<col width="61%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>allowed_fast_set_size</td>
<td>int</td>
<td>5</td>
</tr>
</tbody>
</table>
<p>the number of allowed pieces to send to peers that supports the
fast extensions</p>
<a name="suggest_mode"></a><table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="11%" />
<col width="65%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>suggest_mode</td>
<td>int</td>
<td>settings_pack::no_piece_suggestions</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">suggest_mode</tt> controls whether or not libtorrent will send out
suggest messages to create a bias of its peers to request certain
pieces. The modes are:</p>
<ul class="simple">
<li><tt class="docutils literal">no_piece_suggestions</tt> which will not send out suggest messages.</li>
<li><tt class="docutils literal">suggest_read_cache</tt> which will send out suggest messages for
the most recent pieces that are in the read cache.</li>
</ul>
<a name="max_queued_disk_bytes"></a><table border="1" class="docutils">
<colgroup>
<col width="55%" />
<col width="14%" />
<col width="31%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>max_queued_disk_bytes</td>
<td>int</td>
<td>1024 * 1024</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">max_queued_disk_bytes</tt> is the maximum number of bytes, to
be written to disk, that can wait in the disk I/O thread queue.
This queue is only for waiting for the disk I/O thread to receive
the job and either write it to disk or insert it in the write
cache. When this limit is reached, the peer connections will stop
reading data from their sockets, until the disk thread catches up.
Setting this too low will severely limit your download rate.</p>
<a name="handshake_timeout"></a><table border="1" class="docutils">
<colgroup>
<col width="56%" />
<col width="18%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>handshake_timeout</td>
<td>int</td>
<td>10</td>
</tr>
</tbody>
</table>
<p>the number of seconds to wait for a handshake response from a peer.
If no response is received within this time, the peer is
disconnected.</p>
<a name="send_buffer_low_watermark"></a>
<a name="send_buffer_watermark"></a>
<a name="send_buffer_watermark_factor"></a><table border="1" class="docutils">
<colgroup>
<col width="63%" />
<col width="13%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>send_buffer_low_watermark</td>
<td>int</td>
<td>10 * 1024</td>
</tr>
<tr><td>send_buffer_watermark</td>
<td>int</td>
<td>500 * 1024</td>
</tr>
<tr><td>send_buffer_watermark_factor</td>
<td>int</td>
<td>50</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">send_buffer_low_watermark</tt> the minimum send buffer target size
(send buffer includes bytes pending being read from disk). For good
and snappy seeding performance, set this fairly high, to at least
fit a few blocks. This is essentially the initial window size which
will determine how fast we can ramp up the send rate</p>
<p>if the send buffer has fewer bytes than <tt class="docutils literal">send_buffer_watermark</tt>,
we'll read another 16 kiB block onto it. If set too small, upload
rate capacity will suffer. If set too high, memory will be wasted.
The actual watermark may be lower than this in case the upload rate
is low, this is the upper limit.</p>
<p>the current upload rate to a peer is multiplied by this factor to
get the send buffer watermark. The factor is specified as a
percentage. i.e. 50 -&gt; 0.5 This product is clamped to the
<tt class="docutils literal">send_buffer_watermark</tt> setting to not exceed the max. For high
speed upload, this should be set to a greater value than 100. For
high capacity connections, setting this higher can improve upload
performance and disk throughput. Setting it too high may waste RAM
and create a bias towards read jobs over write jobs.</p>
<a name="choking_algorithm"></a>
<a name="seed_choking_algorithm"></a><table border="1" class="docutils">
<colgroup>
<col width="37%" />
<col width="9%" />
<col width="54%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>choking_algorithm</td>
<td>int</td>
<td>settings_pack::fixed_slots_choker</td>
</tr>
<tr><td>seed_choking_algorithm</td>
<td>int</td>
<td>settings_pack::round_robin</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">choking_algorithm</tt> specifies which algorithm to use to determine
how many peers to unchoke. The unchoking algorithm for
downloading torrents is always &quot;tit-for-tat&quot;, i.e. the peers we
download the fastest from are unchoked.</p>
<p>The options for choking algorithms are defined in the
<a class="reference external" href="reference-Settings.html#choking_algorithm_t">choking_algorithm_t</a> enum.</p>
<p><tt class="docutils literal">seed_choking_algorithm</tt> controls the seeding unchoke behavior.
i.e. How we select which peers to unchoke for seeding torrents.
Since a seeding torrent isn't downloading anything, the
tit-for-tat mechanism cannot be used. The available options are
defined in the <a class="reference external" href="reference-Settings.html#seed_choking_algorithm_t">seed_choking_algorithm_t</a> enum.</p>
<a name="disk_io_write_mode"></a>
<a name="disk_io_read_mode"></a><table border="1" class="docutils">
<colgroup>
<col width="34%" />
<col width="10%" />
<col width="55%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>disk_io_write_mode</td>
<td>int</td>
<td>DISK_WRITE_MODE</td>
</tr>
<tr><td>disk_io_read_mode</td>
<td>int</td>
<td>settings_pack::enable_os_cache</td>
</tr>
</tbody>
</table>
<p>determines how files are opened when they're in read only mode
versus read and write mode. The options are:</p>
<dl class="docutils">
<dt>enable_os_cache</dt>
<dd>Files are opened normally, with the OS caching reads and writes.</dd>
<dt>disable_os_cache</dt>
<dd>This opens all files in no-cache mode. This corresponds to the
OS not letting blocks for the files linger in the cache. This
makes sense in order to avoid the bittorrent client to
potentially evict all other processes' cache by simply handling
high throughput and large files. If libtorrent's read cache is
disabled, enabling this may reduce performance.</dd>
<dt>write_through</dt>
<dd>flush pieces to disk as they complete validation.</dd>
</dl>
<p>One reason to disable caching is that it may help the operating
system from growing its file cache indefinitely.</p>
<a name="outgoing_port"></a>
<a name="num_outgoing_ports"></a><table border="1" class="docutils">
<colgroup>
<col width="57%" />
<col width="17%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>outgoing_port</td>
<td>int</td>
<td>0</td>
</tr>
<tr><td>num_outgoing_ports</td>
<td>int</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>this is the first port to use for binding outgoing connections to.
This is useful for users that have routers that allow QoS settings
based on local port. when binding outgoing connections to specific
ports, <tt class="docutils literal">num_outgoing_ports</tt> is the size of the range. It should
be more than a few</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">setting outgoing ports will limit the ability to keep
multiple connections to the same client, even for different
torrents. It is not recommended to change this setting. Its main
purpose is to use as an escape hatch for cheap routers with QoS
capability but can only classify flows based on port numbers.</p>
</div>
<p>It is a range instead of a single port because of the problems with
failing to reconnect to peers if a previous socket to that peer and
port is in <tt class="docutils literal">TIME_WAIT</tt> state.</p>
<a name="peer_dscp"></a><table border="1" class="docutils">
<colgroup>
<col width="42%" />
<col width="23%" />
<col width="35%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>peer_dscp</td>
<td>int</td>
<td>0x04</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">peer_dscp</tt> determines the DSCP field in the IP header of every
packet sent to peers (including web seeds). <tt class="docutils literal">0x0</tt> means no marking,
<tt class="docutils literal">0x04</tt> represents Lower Effort. For more details see <a class="reference external" href="http://www.faqs.org/rfcs/rfc8622.html">RFC 8622</a>.</p>
<p><tt class="docutils literal">peer_tos</tt> is the backwards compatible name for this setting.</p>
<a name="active_downloads"></a>
<a name="active_seeds"></a>
<a name="active_checking"></a>
<a name="active_dht_limit"></a>
<a name="active_tracker_limit"></a>
<a name="active_lsd_limit"></a>
<a name="active_limit"></a><table border="1" class="docutils">
<colgroup>
<col width="59%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>active_downloads</td>
<td>int</td>
<td>3</td>
</tr>
<tr><td>active_seeds</td>
<td>int</td>
<td>5</td>
</tr>
<tr><td>active_checking</td>
<td>int</td>
<td>1</td>
</tr>
<tr><td>active_dht_limit</td>
<td>int</td>
<td>88</td>
</tr>
<tr><td>active_tracker_limit</td>
<td>int</td>
<td>1600</td>
</tr>
<tr><td>active_lsd_limit</td>
<td>int</td>
<td>60</td>
</tr>
<tr><td>active_limit</td>
<td>int</td>
<td>500</td>
</tr>
</tbody>
</table>
<p>for auto managed torrents, these are the limits they are subject
to. If there are too many torrents some of the auto managed ones
will be paused until some slots free up. <tt class="docutils literal">active_downloads</tt> and
<tt class="docutils literal">active_seeds</tt> controls how many active seeding and downloading
torrents the queuing mechanism allows. The target number of active
torrents is <tt class="docutils literal">min(active_downloads + active_seeds, active_limit)</tt>.
<tt class="docutils literal">active_downloads</tt> and <tt class="docutils literal">active_seeds</tt> are upper limits on the
number of downloading torrents and seeding torrents respectively.
Setting the value to -1 means unlimited.</p>
<p>For example if there are 10 seeding torrents and 10 downloading
torrents, and <tt class="docutils literal">active_downloads</tt> is 4 and <tt class="docutils literal">active_seeds</tt> is 4,
there will be 4 seeds active and 4 downloading torrents. If the
settings are <tt class="docutils literal">active_downloads</tt> = 2 and <tt class="docutils literal">active_seeds</tt> = 4,
then there will be 2 downloading torrents and 4 seeding torrents
active. Torrents that are not auto managed are not counted against
these limits.</p>
<p><tt class="docutils literal">active_checking</tt> is the limit of number of simultaneous checking
torrents.</p>
<p><tt class="docutils literal">active_limit</tt> is a hard limit on the number of active (auto
managed) torrents. This limit also applies to slow torrents.</p>
<p><tt class="docutils literal">active_dht_limit</tt> is the max number of torrents to announce to
the DHT.</p>
<p><tt class="docutils literal">active_tracker_limit</tt> is the max number of torrents to announce
to their trackers.</p>
<p><tt class="docutils literal">active_lsd_limit</tt> is the max number of torrents to announce to
the local network over the local service discovery protocol.</p>
<p>You can have more torrents <em>active</em>, even though they are not
announced to the DHT, lsd or their tracker. If some peer knows
about you for any reason and tries to connect, it will still be
accepted, unless the torrent is paused, which means it won't accept
any connections.</p>
<a name="auto_manage_interval"></a><table border="1" class="docutils">
<colgroup>
<col width="59%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>auto_manage_interval</td>
<td>int</td>
<td>30</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">auto_manage_interval</tt> is the number of seconds between the
torrent queue is updated, and rotated.</p>
<a name="seed_time_limit"></a><table border="1" class="docutils">
<colgroup>
<col width="46%" />
<col width="16%" />
<col width="38%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>seed_time_limit</td>
<td>int</td>
<td>24 * 60 * 60</td>
</tr>
</tbody>
</table>
<p>this is the limit on the time a torrent has been an active seed
(specified in seconds) before it is considered having met the seed
limit criteria. See <a class="reference external" href="manual-ref.html#queuing">queuing</a>.</p>
<a name="auto_scrape_interval"></a>
<a name="auto_scrape_min_interval"></a><table border="1" class="docutils">
<colgroup>
<col width="63%" />
<col width="15%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>auto_scrape_interval</td>
<td>int</td>
<td>1800</td>
</tr>
<tr><td>auto_scrape_min_interval</td>
<td>int</td>
<td>300</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">auto_scrape_interval</tt> is the number of seconds between scrapes
of queued torrents (auto managed and paused torrents). Auto managed
torrents that are paused, are scraped regularly in order to keep
track of their downloader/seed ratio. This ratio is used to
determine which torrents to seed and which to pause.</p>
<p><tt class="docutils literal">auto_scrape_min_interval</tt> is the minimum number of seconds
between any automatic scrape (regardless of torrent). In case there
are a large number of paused auto managed torrents, this puts a
limit on how often a scrape request is sent.</p>
<a name="max_peerlist_size"></a>
<a name="max_paused_peerlist_size"></a><table border="1" class="docutils">
<colgroup>
<col width="63%" />
<col width="15%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>max_peerlist_size</td>
<td>int</td>
<td>3000</td>
</tr>
<tr><td>max_paused_peerlist_size</td>
<td>int</td>
<td>1000</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">max_peerlist_size</tt> is the maximum number of peers in the list of
known peers. These peers are not necessarily connected, so this
number should be much greater than the maximum number of connected
peers. Peers are evicted from the cache when the list grows passed
90% of this limit, and once the size hits the limit, peers are no
longer added to the list. If this limit is set to 0, there is no
limit on how many peers we'll keep in the peer list.</p>
<p><tt class="docutils literal">max_paused_peerlist_size</tt> is the max peer list size used for
torrents that are paused. This can be used to save memory for paused
torrents, since it's not as important for them to keep a large peer
list.</p>
<a name="min_announce_interval"></a><table border="1" class="docutils">
<colgroup>
<col width="61%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>min_announce_interval</td>
<td>int</td>
<td>5 * 60</td>
</tr>
</tbody>
</table>
<p>this is the minimum allowed announce interval for a tracker. This
is specified in seconds and is used as a sanity check on what is
returned from a tracker. It mitigates hammering mis-configured
trackers.</p>
<a name="auto_manage_startup"></a><table border="1" class="docutils">
<colgroup>
<col width="58%" />
<col width="17%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>auto_manage_startup</td>
<td>int</td>
<td>60</td>
</tr>
</tbody>
</table>
<p>this is the number of seconds a torrent is considered active after
it was started, regardless of upload and download speed. This is so
that newly started torrents are not considered inactive until they
have a fair chance to start downloading.</p>
<a name="seeding_piece_quota"></a><table border="1" class="docutils">
<colgroup>
<col width="58%" />
<col width="17%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>seeding_piece_quota</td>
<td>int</td>
<td>20</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">seeding_piece_quota</tt> is the number of pieces to send to a peer,
when seeding, before rotating in another peer to the unchoke set.</p>
<a name="max_rejects"></a><table border="1" class="docutils">
<colgroup>
<col width="46%" />
<col width="21%" />
<col width="32%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>max_rejects</td>
<td>int</td>
<td>50</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">max_rejects</tt> is the number of piece requests we will reject in a
row while a peer is choked before the peer is considered abusive
and is disconnected.</p>
<a name="recv_socket_buffer_size"></a>
<a name="send_socket_buffer_size"></a><table border="1" class="docutils">
<colgroup>
<col width="63%" />
<col width="15%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>recv_socket_buffer_size</td>
<td>int</td>
<td>0</td>
</tr>
<tr><td>send_socket_buffer_size</td>
<td>int</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>specifies the buffer sizes set on peer sockets. 0 means the OS
default (i.e. don't change the buffer sizes).
The socket buffer sizes are changed using setsockopt() with
SOL_SOCKET/SO_RCVBUF and SO_SNDBUFFER.</p>
<p>Note that uTP peers share a single UDP socket buffer for each of the
<tt class="docutils literal">listen_interfaces</tt>, along with DHT and UDP tracker traffic.
If the buffer size is too small for the combined traffic through the
socket, packets may be dropped.</p>
<a name="max_peer_recv_buffer_size"></a><table border="1" class="docutils">
<colgroup>
<col width="54%" />
<col width="12%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>max_peer_recv_buffer_size</td>
<td>int</td>
<td>2 * 1024 * 1024</td>
</tr>
</tbody>
</table>
<p>the max number of bytes a single peer connection's receive buffer is
allowed to grow to.</p>
<a name="optimistic_disk_retry"></a><table border="1" class="docutils">
<colgroup>
<col width="61%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>optimistic_disk_retry</td>
<td>int</td>
<td>10 * 60</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">optimistic_disk_retry</tt> is the number of seconds from a disk
write errors occur on a torrent until libtorrent will take it out
of the upload mode, to test if the error condition has been fixed.</p>
<p>libtorrent will only do this automatically for auto managed
torrents.</p>
<p>You can explicitly take a torrent out of upload only mode using
set_upload_mode().</p>
<a name="max_suggest_pieces"></a><table border="1" class="docutils">
<colgroup>
<col width="57%" />
<col width="17%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>max_suggest_pieces</td>
<td>int</td>
<td>16</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">max_suggest_pieces</tt> is the max number of suggested piece indices
received from a peer that's remembered. If a peer floods suggest
messages, this limit prevents libtorrent from using too much RAM.</p>
<a name="local_service_announce_interval"></a><table border="1" class="docutils">
<colgroup>
<col width="69%" />
<col width="13%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>local_service_announce_interval</td>
<td>int</td>
<td>5 * 60</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">local_service_announce_interval</tt> is the time between local
network announces for a torrent.
This interval is specified in seconds.</p>
<a name="dht_announce_interval"></a><table border="1" class="docutils">
<colgroup>
<col width="61%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>dht_announce_interval</td>
<td>int</td>
<td>15 * 60</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">dht_announce_interval</tt> is the number of seconds between
announcing torrents to the distributed hash table (DHT).</p>
<a name="udp_tracker_token_expiry"></a><table border="1" class="docutils">
<colgroup>
<col width="63%" />
<col width="15%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>udp_tracker_token_expiry</td>
<td>int</td>
<td>60</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">udp_tracker_token_expiry</tt> is the number of seconds libtorrent
will keep UDP tracker connection tokens around for. This is
specified to be 60 seconds. The higher this
value is, the fewer packets have to be sent to the UDP tracker. In
order for higher values to work, the tracker needs to be configured
to match the expiration time for tokens.</p>
<a name="num_optimistic_unchoke_slots"></a><table border="1" class="docutils">
<colgroup>
<col width="67%" />
<col width="13%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>num_optimistic_unchoke_slots</td>
<td>int</td>
<td>0</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">num_optimistic_unchoke_slots</tt> is the number of optimistic
unchoke slots to use.
Having a higher number of optimistic unchoke slots mean you will
find the good peers faster but with the trade-off to use up more
bandwidth. 0 means automatic, where libtorrent opens up 20% of your
allowed upload slots as optimistic unchoke slots.</p>
<a name="max_pex_peers"></a><table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="20%" />
<col width="30%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>max_pex_peers</td>
<td>int</td>
<td>50</td>
</tr>
</tbody>
</table>
<p>the max number of peers we accept from pex messages from a single
peer. this limits the number of concurrent peers any of our peers
claims to be connected to. If they claim to be connected to more
than this, we'll ignore any peer that exceeds this limit</p>
<a name="tick_interval"></a><table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="20%" />
<col width="30%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>tick_interval</td>
<td>int</td>
<td>500</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">tick_interval</tt> specifies the number of milliseconds between
internal ticks. This is the frequency with which bandwidth quota is
distributed to peers. It should not be more than one second (i.e.
1000 ms). Setting this to a low value (around 100) means higher
resolution bandwidth quota distribution, setting it to a higher
value saves CPU cycles.</p>
<a name="share_mode_target"></a><table border="1" class="docutils">
<colgroup>
<col width="56%" />
<col width="18%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>share_mode_target</td>
<td>int</td>
<td>3</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">share_mode_target</tt> specifies the target share ratio for share
mode torrents. If set to 3, we'll try to upload 3
times as much as we download. Setting this very high, will make it
very conservative and you might end up not downloading anything
ever (and not affecting your share ratio). It does not make any
sense to set this any lower than 2. For instance, if only 3 peers
need to download the rarest piece, it's impossible to download a
single piece and upload it more than 3 times. If the
share_mode_target is set to more than 3, nothing is downloaded.</p>
<a name="upload_rate_limit"></a>
<a name="download_rate_limit"></a><table border="1" class="docutils">
<colgroup>
<col width="58%" />
<col width="17%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>upload_rate_limit</td>
<td>int</td>
<td>0</td>
</tr>
<tr><td>download_rate_limit</td>
<td>int</td>
<td>0</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">upload_rate_limit</tt> and <tt class="docutils literal">download_rate_limit</tt> sets
the session-global limits of upload and download rate limits, in
bytes per second. By default peers on the local network are not rate
limited.</p>
<p>A value of 0 means unlimited.</p>
<p>For fine grained control over rate limits, including making them apply
to local peers, see <a class="reference external" href="manual-ref.html#peer-classes">peer classes</a>.</p>
<a name="dht_upload_rate_limit"></a><table border="1" class="docutils">
<colgroup>
<col width="61%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>dht_upload_rate_limit</td>
<td>int</td>
<td>8000</td>
</tr>
</tbody>
</table>
<p>the number of bytes per second (on average) the DHT is allowed to send.
If the incoming requests causes to many bytes to be sent in responses,
incoming requests will be dropped until the quota has been replenished.</p>
<a name="unchoke_slots_limit"></a><table border="1" class="docutils">
<colgroup>
<col width="58%" />
<col width="17%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>unchoke_slots_limit</td>
<td>int</td>
<td>8</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">unchoke_slots_limit</tt> is the max number of unchoked peers in the
<a class="reference external" href="reference-Session.html#session">session</a>. The number of unchoke slots may be ignored depending on
what <tt class="docutils literal">choking_algorithm</tt> is set to. Setting this limit to -1
means unlimited, i.e. all peers will always be unchoked.</p>
<a name="connections_limit"></a><table border="1" class="docutils">
<colgroup>
<col width="56%" />
<col width="18%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>connections_limit</td>
<td>int</td>
<td>200</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">connections_limit</tt> sets a global limit on the number of
connections opened. The number of connections is set to a hard
minimum of at least two per torrent, so if you set a too low
connections limit, and open too many torrents, the limit will not
be met.</p>
<a name="connections_slack"></a><table border="1" class="docutils">
<colgroup>
<col width="56%" />
<col width="18%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>connections_slack</td>
<td>int</td>
<td>10</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">connections_slack</tt> is the number of incoming connections
exceeding the connection limit to accept in order to potentially
replace existing ones.</p>
<a name="utp_target_delay"></a>
<a name="utp_gain_factor"></a>
<a name="utp_min_timeout"></a>
<a name="utp_syn_resends"></a>
<a name="utp_fin_resends"></a>
<a name="utp_num_resends"></a>
<a name="utp_connect_timeout"></a>
<a name="utp_loss_multiplier"></a><table border="1" class="docutils">
<colgroup>
<col width="58%" />
<col width="17%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>utp_target_delay</td>
<td>int</td>
<td>100</td>
</tr>
<tr><td>utp_gain_factor</td>
<td>int</td>
<td>3000</td>
</tr>
<tr><td>utp_min_timeout</td>
<td>int</td>
<td>500</td>
</tr>
<tr><td>utp_syn_resends</td>
<td>int</td>
<td>2</td>
</tr>
<tr><td>utp_fin_resends</td>
<td>int</td>
<td>2</td>
</tr>
<tr><td>utp_num_resends</td>
<td>int</td>
<td>3</td>
</tr>
<tr><td>utp_connect_timeout</td>
<td>int</td>
<td>3000</td>
</tr>
<tr><td>utp_loss_multiplier</td>
<td>int</td>
<td>50</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">utp_target_delay</tt> is the target delay for uTP sockets in
milliseconds. A high value will make uTP connections more
aggressive and cause longer queues in the upload bottleneck. It
cannot be too low, since the noise in the measurements would cause
it to send too slow.
<tt class="docutils literal">utp_gain_factor</tt> is the number of bytes the uTP congestion
window can increase at the most in one RTT.
If this is set too high, the congestion controller reacts
too hard to noise and will not be stable, if it's set too low, it
will react slow to congestion and not back off as fast.</p>
<p><tt class="docutils literal">utp_min_timeout</tt> is the shortest allowed uTP socket timeout,
specified in milliseconds. The
timeout depends on the RTT of the connection, but is never smaller
than this value. A connection times out when every packet in a
window is lost, or when a packet is lost twice in a row (i.e. the
resent packet is lost as well).</p>
<p>The shorter the timeout is, the faster the connection will recover
from this situation, assuming the RTT is low enough.
<tt class="docutils literal">utp_syn_resends</tt> is the number of SYN packets that are sent (and
timed out) before giving up and closing the socket.
<tt class="docutils literal">utp_num_resends</tt> is the number of times a packet is sent (and
lost or timed out) before giving up and closing the connection.
<tt class="docutils literal">utp_connect_timeout</tt> is the number of milliseconds of timeout
for the initial SYN packet for uTP connections. For each timed out
packet (in a row), the timeout is doubled. <tt class="docutils literal">utp_loss_multiplier</tt>
controls how the congestion window is changed when a packet loss is
experienced. It's specified as a percentage multiplier for
<tt class="docutils literal">cwnd</tt>. Do not change this value unless you know what you're doing.
Never set it higher than 100.</p>
<a name="mixed_mode_algorithm"></a><table border="1" class="docutils">
<colgroup>
<col width="35%" />
<col width="10%" />
<col width="55%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>mixed_mode_algorithm</td>
<td>int</td>
<td>settings_pack::peer_proportional</td>
</tr>
</tbody>
</table>
<p>The <tt class="docutils literal">mixed_mode_algorithm</tt> determines how to treat TCP
connections when there are uTP connections. Since uTP is designed
to yield to TCP, there's an inherent problem when using swarms that
have both TCP and uTP connections. If nothing is done, uTP
connections would often be starved out for bandwidth by the TCP
connections. This mode is <tt class="docutils literal">prefer_tcp</tt>. The <tt class="docutils literal">peer_proportional</tt>
mode simply looks at the current throughput and rate limits all TCP
connections to their proportional share based on how many of the
connections are TCP. This works best if uTP connections are not
rate limited by the global rate limiter (which they aren't by
default).</p>
<a name="listen_queue_size"></a><table border="1" class="docutils">
<colgroup>
<col width="56%" />
<col width="18%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>listen_queue_size</td>
<td>int</td>
<td>5</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">listen_queue_size</tt> is the value passed in to listen() for the
listen socket. It is the number of outstanding incoming connections
to queue up while we're not actively waiting for a connection to be
accepted. 5 should be sufficient for any
normal client. If this is a high performance server which expects
to receive a lot of connections, or used in a simulator or test, it
might make sense to raise this number. It will not take affect
until the <tt class="docutils literal">listen_interfaces</tt> settings is updated.</p>
<a name="torrent_connect_boost"></a><table border="1" class="docutils">
<colgroup>
<col width="61%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>torrent_connect_boost</td>
<td>int</td>
<td>30</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">torrent_connect_boost</tt> is the number of peers to try to connect
to immediately when the first tracker response is received for a
torrent. This is a boost to given to new torrents to accelerate
them starting up. The normal connect scheduler is run once every
second, this allows peers to be connected immediately instead of
waiting for the <a class="reference external" href="reference-Session.html#session">session</a> tick to trigger connections.
This may not be set higher than 255.</p>
<a name="alert_queue_size"></a><table border="1" class="docutils">
<colgroup>
<col width="55%" />
<col width="18%" />
<col width="27%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>alert_queue_size</td>
<td>int</td>
<td>2000</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">alert_queue_size</tt> is the maximum number of alerts queued up
internally. If alerts are not popped, the queue will eventually
fill up to this level. Once the <a class="reference external" href="reference-Alerts.html#alert">alert</a> queue is full, additional
alerts will be dropped, and not delivered to the client. Once the
client drains the queue, new alerts may be delivered again. In order
to know that alerts have been dropped, see
session_handle::dropped_alerts().</p>
<a name="max_metadata_size"></a><table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="14%" />
<col width="42%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>max_metadata_size</td>
<td>int</td>
<td>3 * 1024 * 10240</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">max_metadata_size</tt> is the maximum allowed size (in bytes) to be
received by the metadata extension, i.e. magnet links.</p>
<a name="hashing_threads"></a><table border="1" class="docutils">
<colgroup>
<col width="53%" />
<col width="19%" />
<col width="28%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>hashing_threads</td>
<td>int</td>
<td>1</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">hashing_threads</tt> is the number of disk I/O threads to use for
piece hash verification. These threads are <em>in addition</em> to the
regular disk I/O threads specified by <a class="reference external" href="reference-Settings.html#aio_threads">settings_pack::aio_threads</a>.
These threads are only used for full checking of torrents. The
hash checking done while downloading are done by the regular disk
I/O threads.
The <a class="reference external" href="reference-Utility.html#hasher">hasher</a> threads do not only compute hashes, but also perform
the read from disk. On storage optimal for sequential access,
such as hard drives, this setting should be set to 1, which is
also the default.</p>
<a name="checking_mem_usage"></a><table border="1" class="docutils">
<colgroup>
<col width="57%" />
<col width="17%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>checking_mem_usage</td>
<td>int</td>
<td>256</td>
</tr>
</tbody>
</table>
<p>the number of blocks to keep outstanding at any given time when
checking torrents. Higher numbers give faster re-checks but uses
more memory. Specified in number of 16 kiB blocks</p>
<a name="predictive_piece_announce"></a><table border="1" class="docutils">
<colgroup>
<col width="64%" />
<col width="14%" />
<col width="21%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>predictive_piece_announce</td>
<td>int</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>if set to &gt; 0, pieces will be announced to other peers before they
are fully downloaded (and before they are hash checked). The
intention is to gain 1.5 potential round trip times per downloaded
piece. When non-zero, this indicates how many milliseconds in
advance pieces should be announced, before they are expected to be
completed.</p>
<a name="aio_threads"></a><table border="1" class="docutils">
<colgroup>
<col width="46%" />
<col width="21%" />
<col width="32%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>aio_threads</td>
<td>int</td>
<td>10</td>
</tr>
</tbody>
</table>
<p>for some aio back-ends, <tt class="docutils literal">aio_threads</tt> specifies the number of
io-threads to use.</p>
<a name="tracker_backoff"></a><table border="1" class="docutils">
<colgroup>
<col width="53%" />
<col width="19%" />
<col width="28%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>tracker_backoff</td>
<td>int</td>
<td>250</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">tracker_backoff</tt> determines how aggressively to back off from
retrying failing trackers. This value determines <em>x</em> in the
following formula, determining the number of seconds to wait until
the next retry:</p>
<blockquote>
delay = 5 + 5 * x / 100 * fails^2</blockquote>
<p>This setting may be useful to make libtorrent more or less
aggressive in hitting trackers.</p>
<a name="share_ratio_limit"></a>
<a name="seed_time_ratio_limit"></a><table border="1" class="docutils">
<colgroup>
<col width="61%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>share_ratio_limit</td>
<td>int</td>
<td>200</td>
</tr>
<tr><td>seed_time_ratio_limit</td>
<td>int</td>
<td>700</td>
</tr>
</tbody>
</table>
<p>when a seeding torrent reaches either the share ratio (bytes up /
bytes down) or the seed time ratio (seconds as seed / seconds as
downloader) or the seed time limit (seconds as seed) it is
considered done, and it will leave room for other torrents. These
are specified as percentages. Torrents that are considered done will
still be allowed to be seeded, they just won't have priority anymore.
For more, see <a class="reference external" href="manual-ref.html#queuing">queuing</a>.</p>
<a name="peer_turnover"></a>
<a name="peer_turnover_cutoff"></a>
<a name="peer_turnover_interval"></a><table border="1" class="docutils">
<colgroup>
<col width="62%" />
<col width="15%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>peer_turnover</td>
<td>int</td>
<td>4</td>
</tr>
<tr><td>peer_turnover_cutoff</td>
<td>int</td>
<td>90</td>
</tr>
<tr><td>peer_turnover_interval</td>
<td>int</td>
<td>300</td>
</tr>
</tbody>
</table>
<p>peer_turnover is the percentage of peers to disconnect every
turnover peer_turnover_interval (if we're at the peer limit), this
is specified in percent when we are connected to more than limit *
peer_turnover_cutoff peers disconnect peer_turnover fraction of the
peers. It is specified in percent peer_turnover_interval is the
interval (in seconds) between optimistic disconnects if the
disconnects happen and how many peers are disconnected is
controlled by peer_turnover and peer_turnover_cutoff</p>
<a name="connect_seed_every_n_download"></a><table border="1" class="docutils">
<colgroup>
<col width="67%" />
<col width="13%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>connect_seed_every_n_download</td>
<td>int</td>
<td>10</td>
</tr>
</tbody>
</table>
<p>this setting controls the priority of downloading torrents over
seeding or finished torrents when it comes to making peer
connections. Peer connections are throttled by the connection_speed
and the half-open connection limit. This makes peer connections a
limited resource. Torrents that still have pieces to download are
prioritized by default, to avoid having many seeding torrents use
most of the connection attempts and only give one peer every now
and then to the downloading torrent. libtorrent will loop over the
downloading torrents to connect a peer each, and every n:th
connection attempt, a finished torrent is picked to be allowed to
connect to a peer. This setting controls n.</p>
<a name="max_http_recv_buffer_size"></a><table border="1" class="docutils">
<colgroup>
<col width="60%" />
<col width="13%" />
<col width="27%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>max_http_recv_buffer_size</td>
<td>int</td>
<td>4*1024*204</td>
</tr>
</tbody>
</table>
<p>the max number of bytes to allow an HTTP response to be when
announcing to trackers or downloading .torrent files via the
<tt class="docutils literal">url</tt> provided in <tt class="docutils literal">add_torrent_params</tt>.</p>
<a name="max_retry_port_bind"></a><table border="1" class="docutils">
<colgroup>
<col width="58%" />
<col width="17%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>max_retry_port_bind</td>
<td>int</td>
<td>10</td>
</tr>
</tbody>
</table>
<p>if binding to a specific port fails, should the port be incremented
by one and tried again? This setting specifies how many times to
retry a failed port bind</p>
<a name="alert_mask"></a><table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="22%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>alert_mask</td>
<td>int</td>
<td>int</td>
</tr>
</tbody>
</table>
<p>a bitmask combining flags from <a class="reference external" href="reference-Alerts.html#alert_category_t">alert_category_t</a> defining which
kinds of alerts to receive</p>
<a name="out_enc_policy"></a>
<a name="in_enc_policy"></a><table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="12%" />
<col width="55%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>out_enc_policy</td>
<td>int</td>
<td>settings_pack::pe_enabled</td>
</tr>
<tr><td>in_enc_policy</td>
<td>int</td>
<td>settings_pack::pe_enabled</td>
</tr>
</tbody>
</table>
<p>control the settings for incoming and outgoing connections
respectively. see <a class="reference external" href="reference-Settings.html#enc_policy">enc_policy</a> enum for the available options.
Keep in mind that protocol encryption degrades performance in
several respects:</p>
<ol class="arabic simple">
<li>It prevents &quot;zero copy&quot; disk buffers being sent to peers, since
each peer needs to mutate the data (i.e. encrypt it) the data
must be copied per peer connection rather than sending the same
buffer to multiple peers.</li>
<li>The encryption itself requires more CPU than plain bittorrent
protocol. The highest cost is the Diffie Hellman exchange on
connection setup.</li>
<li>The encryption handshake adds several round-trips to the
connection setup, and delays transferring data.</li>
</ol>
<a name="allowed_enc_level"></a><table border="1" class="docutils">
<colgroup>
<col width="39%" />
<col width="12%" />
<col width="49%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>allowed_enc_level</td>
<td>int</td>
<td>settings_pack::pe_both</td>
</tr>
</tbody>
</table>
<p>determines the encryption level of the connections. This setting
will adjust which encryption scheme is offered to the other peer,
as well as which encryption scheme is selected by the client. See
<a class="reference external" href="reference-Settings.html#enc_level">enc_level</a> enum for options.</p>
<a name="inactive_down_rate"></a>
<a name="inactive_up_rate"></a><table border="1" class="docutils">
<colgroup>
<col width="57%" />
<col width="17%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>inactive_down_rate</td>
<td>int</td>
<td>2048</td>
</tr>
<tr><td>inactive_up_rate</td>
<td>int</td>
<td>2048</td>
</tr>
</tbody>
</table>
<p>the download and upload rate limits for a torrent to be considered
active by the queuing mechanism. A torrent whose download rate is
less than <tt class="docutils literal">inactive_down_rate</tt> and whose upload rate is less than
<tt class="docutils literal">inactive_up_rate</tt> for <tt class="docutils literal">auto_manage_startup</tt> seconds, is
considered inactive, and another queued torrent may be started.
This logic is disabled if <tt class="docutils literal">dont_count_slow_torrents</tt> is false.</p>
<a name="proxy_type"></a><table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="15%" />
<col width="54%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>proxy_type</td>
<td>int</td>
<td>settings_pack::none</td>
</tr>
</tbody>
</table>
<p>proxy to use. see <a class="reference external" href="reference-Settings.html#proxy_type_t">proxy_type_t</a>.</p>
<a name="proxy_port"></a><table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="22%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>proxy_port</td>
<td>int</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>the port of the proxy server</p>
<a name="i2p_port"></a><table border="1" class="docutils">
<colgroup>
<col width="40%" />
<col width="24%" />
<col width="36%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>i2p_port</td>
<td>int</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>sets the <a class="reference external" href="http://www.i2p2.de">i2p</a> SAM bridge port to connect to. set the hostname with
the <tt class="docutils literal">i2p_hostname</tt> setting.</p>
<a name="urlseed_max_request_bytes"></a><table border="1" class="docutils">
<colgroup>
<col width="53%" />
<col width="12%" />
<col width="35%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>urlseed_max_request_bytes</td>
<td>int</td>
<td>16 * 1024 * 1024</td>
</tr>
</tbody>
</table>
<p>The maximum request range of an url seed in bytes. This value
defines the largest possible sequential web seed request. Lower values
are possible but will be ignored if they are lower then piece size.
This value should be related to your download speed to prevent
libtorrent from creating too many expensive http requests per
second. You can select a value as high as you want but keep in mind
that libtorrent can't create parallel requests if the first request
did already select the whole file.
If you combine bittorrent seeds with web seeds and pick strategies
like rarest first you may find your web seed requests split into
smaller parts because we don't download already picked pieces
twice.</p>
<a name="web_seed_name_lookup_retry"></a><table border="1" class="docutils">
<colgroup>
<col width="65%" />
<col width="14%" />
<col width="21%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>web_seed_name_lookup_retry</td>
<td>int</td>
<td>1800</td>
</tr>
</tbody>
</table>
<p>time to wait until a new retry of a web seed name lookup</p>
<a name="close_file_interval"></a><table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="13%" />
<col width="44%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>close_file_interval</td>
<td>int</td>
<td>CLOSE_FILE_INTERVAL</td>
</tr>
</tbody>
</table>
<p>the number of seconds between closing the file opened the longest
ago. 0 means to disable the feature. The purpose of this is to
periodically close files to trigger the operating system flushing
disk cache. Specifically it has been observed to be required on
windows to not have the disk cache grow indefinitely.
This defaults to 240 seconds on windows, and disabled on other
systems.</p>
<a name="utp_cwnd_reduce_timer"></a><table border="1" class="docutils">
<colgroup>
<col width="61%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>utp_cwnd_reduce_timer</td>
<td>int</td>
<td>100</td>
</tr>
</tbody>
</table>
<p>When uTP experiences packet loss, it will reduce the congestion
window, and not reduce it again for this many milliseconds, even if
experiencing another lost packet.</p>
<a name="max_web_seed_connections"></a><table border="1" class="docutils">
<colgroup>
<col width="63%" />
<col width="15%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>max_web_seed_connections</td>
<td>int</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>the max number of web seeds to have connected per torrent at any
given time.</p>
<a name="resolver_cache_timeout"></a><table border="1" class="docutils">
<colgroup>
<col width="62%" />
<col width="15%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>resolver_cache_timeout</td>
<td>int</td>
<td>1200</td>
</tr>
</tbody>
</table>
<p>the number of seconds before the internal host name resolver
considers a cache value timed out, negative values are interpreted
as zero.</p>
<a name="send_not_sent_low_watermark"></a><table border="1" class="docutils">
<colgroup>
<col width="66%" />
<col width="14%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>send_not_sent_low_watermark</td>
<td>int</td>
<td>16384</td>
</tr>
</tbody>
</table>
<p>specify the not-sent low watermark for socket send buffers. This
corresponds to the, Linux-specific, <tt class="docutils literal">TCP_NOTSENT_LOWAT</tt> TCP socket
option.</p>
<a name="rate_choker_initial_threshold"></a><table border="1" class="docutils">
<colgroup>
<col width="67%" />
<col width="13%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>rate_choker_initial_threshold</td>
<td>int</td>
<td>1024</td>
</tr>
</tbody>
</table>
<p>the rate based choker compares the upload rate to peers against a
threshold that increases proportionally by its size for every
peer it visits, visiting peers in decreasing upload rate. The
number of upload slots is determined by the number of peers whose
upload rate exceeds the threshold. This option sets the start
value for this threshold. A higher value leads to fewer unchoke
slots, a lower value leads to more.</p>
<a name="upnp_lease_duration"></a><table border="1" class="docutils">
<colgroup>
<col width="58%" />
<col width="17%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>upnp_lease_duration</td>
<td>int</td>
<td>3600</td>
</tr>
</tbody>
</table>
<p>The expiration time of UPnP port-mappings, specified in seconds. 0
means permanent lease. Some routers do not support expiration times
on port-maps (nor correctly returning an error indicating lack of
support). In those cases, set this to 0. Otherwise, don't set it any
lower than 5 minutes.</p>
<a name="max_concurrent_http_announces"></a><table border="1" class="docutils">
<colgroup>
<col width="67%" />
<col width="13%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>max_concurrent_http_announces</td>
<td>int</td>
<td>50</td>
</tr>
</tbody>
</table>
<p>limits the number of concurrent HTTP tracker announces. Once the
limit is hit, tracker requests are queued and issued when an
outstanding announce completes.</p>
<a name="dht_max_peers_reply"></a><table border="1" class="docutils">
<colgroup>
<col width="58%" />
<col width="17%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>dht_max_peers_reply</td>
<td>int</td>
<td>100</td>
</tr>
</tbody>
</table>
<p>the maximum number of peers to send in a reply to <tt class="docutils literal">get_peers</tt></p>
<a name="dht_search_branching"></a><table border="1" class="docutils">
<colgroup>
<col width="59%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>dht_search_branching</td>
<td>int</td>
<td>5</td>
</tr>
</tbody>
</table>
<p>the number of concurrent search request the node will send when
announcing and refreshing the routing table. This parameter is called
alpha in the kademlia paper</p>
<a name="dht_max_fail_count"></a><table border="1" class="docutils">
<colgroup>
<col width="57%" />
<col width="17%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>dht_max_fail_count</td>
<td>int</td>
<td>20</td>
</tr>
</tbody>
</table>
<p>the maximum number of failed tries to contact a node before it is
removed from the routing table. If there are known working nodes that
are ready to replace a failing node, it will be replaced immediately,
this limit is only used to clear out nodes that don't have any node
that can replace them.</p>
<a name="dht_max_torrents"></a><table border="1" class="docutils">
<colgroup>
<col width="55%" />
<col width="18%" />
<col width="27%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>dht_max_torrents</td>
<td>int</td>
<td>2000</td>
</tr>
</tbody>
</table>
<p>the total number of torrents to track from the DHT. This is simply an
upper limit to make sure malicious DHT nodes cannot make us allocate
an unbounded amount of memory.</p>
<a name="dht_max_dht_items"></a><table border="1" class="docutils">
<colgroup>
<col width="56%" />
<col width="18%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>dht_max_dht_items</td>
<td>int</td>
<td>700</td>
</tr>
</tbody>
</table>
<p>max number of items the DHT will store</p>
<a name="dht_max_peers"></a><table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="20%" />
<col width="30%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>dht_max_peers</td>
<td>int</td>
<td>500</td>
</tr>
</tbody>
</table>
<p>the max number of peers to store per torrent (for the DHT)</p>
<a name="dht_max_torrent_search_reply"></a><table border="1" class="docutils">
<colgroup>
<col width="67%" />
<col width="13%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>dht_max_torrent_search_reply</td>
<td>int</td>
<td>20</td>
</tr>
</tbody>
</table>
<p>the max number of torrents to return in a torrent search query to the
DHT</p>
<a name="dht_block_timeout"></a><table border="1" class="docutils">
<colgroup>
<col width="56%" />
<col width="18%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>dht_block_timeout</td>
<td>int</td>
<td>5 * 60</td>
</tr>
</tbody>
</table>
<p>the number of seconds a DHT node is banned if it exceeds the rate
limit. The rate limit is averaged over 10 seconds to allow for bursts
above the limit.</p>
<a name="dht_block_ratelimit"></a><table border="1" class="docutils">
<colgroup>
<col width="58%" />
<col width="17%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>dht_block_ratelimit</td>
<td>int</td>
<td>5</td>
</tr>
</tbody>
</table>
<p>the max number of packets per second a DHT node is allowed to send
without getting banned.</p>
<a name="dht_item_lifetime"></a><table border="1" class="docutils">
<colgroup>
<col width="56%" />
<col width="18%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>dht_item_lifetime</td>
<td>int</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>the number of seconds a immutable/mutable item will be expired.
default is 0, means never expires.</p>
<a name="dht_sample_infohashes_interval"></a><table border="1" class="docutils">
<colgroup>
<col width="68%" />
<col width="13%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>dht_sample_infohashes_interval</td>
<td>int</td>
<td>21600</td>
</tr>
</tbody>
</table>
<p>the info-hashes sample recomputation interval (in seconds).
The node will precompute a subset of the tracked info-hashes and return
that instead of calculating it upon each request. The permissible range
is between 0 and 21600 seconds (inclusive).</p>
<a name="dht_max_infohashes_sample_count"></a><table border="1" class="docutils">
<colgroup>
<col width="69%" />
<col width="13%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>dht_max_infohashes_sample_count</td>
<td>int</td>
<td>20</td>
</tr>
</tbody>
</table>
<p>the maximum number of elements in the sampled subset of info-hashes.
If this number is too big, expect the DHT storage implementations
to clamp it in order to allow UDP packets go through</p>
<a name="max_piece_count"></a><table border="1" class="docutils">
<colgroup>
<col width="52%" />
<col width="18%" />
<col width="30%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>max_piece_count</td>
<td>int</td>
<td>0x200000</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">max_piece_count</tt> is the maximum allowed number of pieces in
metadata received via magnet links. Loading large torrents (with
more pieces than the default limit) may also require passing in
a higher limit to <a class="reference external" href="reference-Resume_Data.html#read_resume_data()">read_resume_data()</a> and
<a class="reference external" href="reference-Torrent_Info.html#parse_info_section()">torrent_info::parse_info_section()</a>, if those are used.</p>
<a name="metadata_token_limit"></a><table border="1" class="docutils">
<colgroup>
<col width="59%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>metadata_token_limit</td>
<td>int</td>
<td>2500000</td>
</tr>
</tbody>
</table>
<p>when receiving metadata (torrent file) from peers, this is the
max number of bencoded tokens we're willing to parse. This limit
is meant to prevent DoS attacks on peers. For very large
torrents, this limit may have to be raised.</p>
<a name="disk_write_mode"></a><table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="8%" />
<col width="69%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>disk_write_mode</td>
<td>int</td>
<td>settings_pack::mmap_write_mode_t::auto_mmap_write</td>
</tr>
</tbody>
</table>
<p>controls whether disk writes will be made through a memory mapped
file or via normal write calls. This only affects the
mmap_disk_io. When saving to a non-local drive (network share,
NFS or NAS) using memory mapped files is most likely inferior.
When writing to a local SSD (especially in DAX mode) using memory
mapped files likely gives the best performance.
The values for this setting are specified as <a class="reference external" href="reference-Settings.html#mmap_write_mode_t">mmap_write_mode_t</a>.</p>
<a name="mmap_file_size_cutoff"></a><table border="1" class="docutils">
<colgroup>
<col width="61%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>mmap_file_size_cutoff</td>
<td>int</td>
<td>40</td>
</tr>
</tbody>
</table>
<p>when using mmap_disk_io, files smaller than this number of blocks
will not be memory mapped, but will use normal pread/pwrite
operations. This file size limit is specified in 16 kiB blocks.</p>
<a name="i2p_inbound_quantity"></a>
<a name="i2p_outbound_quantity"></a>
<a name="i2p_inbound_length"></a>
<a name="i2p_outbound_length"></a><table border="1" class="docutils">
<colgroup>
<col width="61%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>i2p_inbound_quantity</td>
<td>int</td>
<td>3</td>
</tr>
<tr><td>i2p_outbound_quantity</td>
<td>int</td>
<td>3</td>
</tr>
<tr><td>i2p_inbound_length</td>
<td>int</td>
<td>3</td>
</tr>
<tr><td>i2p_outbound_length</td>
<td>int</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>Configures the SAM <a class="reference external" href="reference-Session.html#session">session</a>
quantity of I2P inbound and outbound tunnels [1..16].
number of hops for I2P inbound and outbound tunnels [0..7]
Changing these will not trigger a reconnect to the SAM bridge,
they will take effect the next time the SAM connection is
re-established (by restarting or changing i2p_hostname or
i2p_port).</p>
<a name="announce_port"></a><table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="20%" />
<col width="30%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">type</th>
<th class="head">default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>announce_port</td>
<td>int</td>
<td>0</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">announce_port</tt> is the port passed along as the <tt class="docutils literal">port</tt> parameter
to remote trackers such as HTTP or DHT. This setting does not affect
the effective listening port nor local service discovery announcements.
If left as zero (default), the listening port value is used.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This setting is only meant for very special cases where a
seed's listening port differs from the external port. As an
example, if a local proxy is used and that the proxy supports
reverse tunnels through NAT-PMP, the tracker must connect to
the external NAT-PMP port (configured using <tt class="docutils literal">announce_port</tt>)
instead of the actual local listening port.</p>
</div>
<pre class="literal-block">
struct settings_pack final : settings_interface
{
   friend  void <strong>apply_pack_impl</strong> (settings_pack const*
      , aux::session_settings_single_thread&amp;
      , std::vector&lt;void(aux::session_impl::*)()&gt;*);
   void <strong>set_bool</strong> (int name, bool val) override;
   void <strong>set_int</strong> (int name, int val) override;
   void <strong>set_str</strong> (int name, std::string val) override;
   void <strong>set_int</strong> (int name, flags::bitfield_flag&lt;Type, Tag&gt; const val);
   bool <strong>has_val</strong> (int name) const override;
   void <strong>clear</strong> ();
   void <strong>clear</strong> (int name);
   int <strong>get_int</strong> (int name) const override;
   bool <strong>get_bool</strong> (int name) const override;
   std::string const&amp; <strong>get_str</strong> (int name) const override;
   void <strong>for_each</strong> (Fun&amp;&amp; f) const;

   enum type_bases
   {
      string_type_base,
      int_type_base,
      bool_type_base,
      type_mask,
      index_mask,
   };

   enum mmap_write_mode_t
   {
      always_pwrite,
      always_mmap_write,
      auto_mmap_write,
   };

   enum suggest_mode_t
   {
      no_piece_suggestions,
      suggest_read_cache,
   };

   enum choking_algorithm_t
   {
      fixed_slots_choker,
      rate_based_choker,
      deprecated_bittyrant_choker,
   };

   enum seed_choking_algorithm_t
   {
      round_robin,
      fastest_upload,
      anti_leech,
   };

   enum io_buffer_mode_t
   {
      enable_os_cache,
      deprecated_disable_os_cache_for_aligned_files,
      disable_os_cache,
      write_through,
   };

   enum bandwidth_mixed_algo_t
   {
      prefer_tcp,
      peer_proportional,
   };

   enum enc_policy
   {
      pe_forced,
      pe_enabled,
      pe_disabled,
   };

   enum enc_level
   {
      pe_plaintext,
      pe_rc4,
      pe_both,
   };

   enum proxy_type_t
   {
      none,
      socks4,
      socks5,
      socks5_pw,
      http,
      http_pw,
   };
};
</pre>
<a name="set_int()"></a>
<a name="set_bool()"></a>
<a name="set_str()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:settings_pack%3A%3A%5Bset_int%28%29+set_bool%28%29+set_str%28%29%5D&labels=documentation&body=Documentation+under+heading+%22settings_pack%3A%3A%5Bset_int%28%29+set_bool%28%29+set_str%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="set-int-set-bool-set-str">
<h2>set_int() set_bool() set_str()</h2>
<pre class="literal-block">
void <strong>set_bool</strong> (int name, bool val) override;
void <strong>set_int</strong> (int name, int val) override;
void <strong>set_str</strong> (int name, std::string val) override;
void <strong>set_int</strong> (int name, flags::bitfield_flag&lt;Type, Tag&gt; const val);
</pre>
<p>set a configuration option in the <a class="reference external" href="reference-Settings.html#settings_pack">settings_pack</a>. <tt class="docutils literal">name</tt> is one of
the enum values from string_types, int_types or bool_types. They must
match the respective type of the set_* function.</p>
<a name="has_val()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:settings_pack%3A%3A%5Bhas_val%28%29%5D&labels=documentation&body=Documentation+under+heading+%22settings_pack%3A%3A%5Bhas_val%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="has-val">
<h2>has_val()</h2>
<pre class="literal-block">
bool <strong>has_val</strong> (int name) const override;
</pre>
<p>queries whether the specified configuration option has a value set in
this pack. <tt class="docutils literal">name</tt> can be any enumeration value from string_types,
int_types or bool_types.</p>
<a name="clear()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:settings_pack%3A%3A%5Bclear%28%29%5D&labels=documentation&body=Documentation+under+heading+%22settings_pack%3A%3A%5Bclear%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="clear">
<h2>clear()</h2>
<pre class="literal-block">
void <strong>clear</strong> ();
</pre>
<p>clear the settings pack from all settings</p>
<a name="clear()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:settings_pack%3A%3A%5Bclear%28%29%5D&labels=documentation&body=Documentation+under+heading+%22settings_pack%3A%3A%5Bclear%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="clear-1">
<h2>clear()</h2>
<pre class="literal-block">
void <strong>clear</strong> (int name);
</pre>
<p>clear a specific setting from the pack</p>
<a name="get_str()"></a>
<a name="get_int()"></a>
<a name="get_bool()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:settings_pack%3A%3A%5Bget_str%28%29+get_int%28%29+get_bool%28%29%5D&labels=documentation&body=Documentation+under+heading+%22settings_pack%3A%3A%5Bget_str%28%29+get_int%28%29+get_bool%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="get-str-get-int-get-bool">
<h2>get_str() get_int() get_bool()</h2>
<pre class="literal-block">
int <strong>get_int</strong> (int name) const override;
bool <strong>get_bool</strong> (int name) const override;
std::string const&amp; <strong>get_str</strong> (int name) const override;
</pre>
<p>queries the current configuration option from the <a class="reference external" href="reference-Settings.html#settings_pack">settings_pack</a>.
<tt class="docutils literal">name</tt> is one of the enumeration values from string_types, int_types
or bool_types. The enum value must match the type of the get_*
function. If the specified setting field has not been set, the default
value is returned.</p>
<a name="type_bases"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+type_bases&labels=documentation&body=Documentation+under+heading+%22enum+type_bases%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-type-bases">
<h2>enum type_bases</h2>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/settings_pack.hpp">libtorrent/settings_pack.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="47%" />
<col width="18%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>string_type_base</td>
<td>0</td>
<td>&nbsp;</td>
</tr>
<tr><td>int_type_base</td>
<td>16384</td>
<td>&nbsp;</td>
</tr>
<tr><td>bool_type_base</td>
<td>32768</td>
<td>&nbsp;</td>
</tr>
<tr><td>type_mask</td>
<td>49152</td>
<td>&nbsp;</td>
</tr>
<tr><td>index_mask</td>
<td>16383</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<a name="mmap_write_mode_t"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+mmap_write_mode_t&labels=documentation&body=Documentation+under+heading+%22enum+mmap_write_mode_t%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-mmap-write-mode-t">
<h2>enum mmap_write_mode_t</h2>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/settings_pack.hpp">libtorrent/settings_pack.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="8%" />
<col width="71%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>always_pwrite</td>
<td>0</td>
<td>disable writing to disk via mmap, always use normal write calls</td>
</tr>
<tr><td>always_mmap_write</td>
<td>1</td>
<td>prefer using memory mapped files for disk writes (at least for
large files where it might make sense)</td>
</tr>
<tr><td>auto_mmap_write</td>
<td>2</td>
<td>determine whether to use pwrite or memory mapped files for disk
writes depending on the kind of storage behind the save path</td>
</tr>
</tbody>
</table>
<a name="suggest_mode_t"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+suggest_mode_t&labels=documentation&body=Documentation+under+heading+%22enum+suggest_mode_t%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-suggest-mode-t">
<h2>enum suggest_mode_t</h2>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/settings_pack.hpp">libtorrent/settings_pack.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="52%" />
<col width="17%" />
<col width="31%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>no_piece_suggestions</td>
<td>0</td>
<td>&nbsp;</td>
</tr>
<tr><td>suggest_read_cache</td>
<td>1</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<a name="choking_algorithm_t"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+choking_algorithm_t&labels=documentation&body=Documentation+under+heading+%22enum+choking_algorithm_t%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-choking-algorithm-t">
<h2>enum choking_algorithm_t</h2>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/settings_pack.hpp">libtorrent/settings_pack.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="7%" />
<col width="65%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>fixed_slots_choker</td>
<td>0</td>
<td>This is the traditional choker with a fixed number of unchoke
slots (as specified by <a class="reference external" href="reference-Settings.html#unchoke_slots_limit">settings_pack::unchoke_slots_limit</a>).</td>
</tr>
<tr><td>rate_based_choker</td>
<td>2</td>
<td><p class="first">This opens up unchoke slots based on the upload rate achieved to
peers. The more slots that are opened, the marginal upload rate
required to open up another slot increases. Configure the initial
threshold with <a class="reference external" href="reference-Settings.html#rate_choker_initial_threshold">settings_pack::rate_choker_initial_threshold</a>.</p>
<p class="last">For more information, see <a class="reference external" href="manual-ref.html#rate-based-choking">rate based choking</a>.</p>
</td>
</tr>
<tr><td>deprecated_bittyrant_choker</td>
<td>3</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<a name="seed_choking_algorithm_t"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+seed_choking_algorithm_t&labels=documentation&body=Documentation+under+heading+%22enum+seed_choking_algorithm_t%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-seed-choking-algorithm-t">
<h2>enum seed_choking_algorithm_t</h2>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/settings_pack.hpp">libtorrent/settings_pack.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="18%" />
<col width="8%" />
<col width="75%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>round_robin</td>
<td>0</td>
<td>which round-robins the peers that are unchoked
when seeding. This distributes the upload bandwidth uniformly and
fairly. It minimizes the ability for a peer to download everything
without redistributing it.</td>
</tr>
<tr><td>fastest_upload</td>
<td>1</td>
<td>unchokes the peers we can send to the fastest. This might be a
bit more reliable in utilizing all available capacity.</td>
</tr>
<tr><td>anti_leech</td>
<td>2</td>
<td>prioritizes peers who have just started or are
just about to finish the download. The intention is to force
peers in the middle of the download to trade with each other.
This does not just take into account the pieces a peer is
reporting having downloaded, but also the pieces we have sent
to it.</td>
</tr>
</tbody>
</table>
<a name="io_buffer_mode_t"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+io_buffer_mode_t&labels=documentation&body=Documentation+under+heading+%22enum+io_buffer_mode_t%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-io-buffer-mode-t">
<h2>enum io_buffer_mode_t</h2>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/settings_pack.hpp">libtorrent/settings_pack.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="70%" />
<col width="10%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>enable_os_cache</td>
<td>0</td>
<td>&nbsp;</td>
</tr>
<tr><td>deprecated_disable_os_cache_for_aligned_files</td>
<td>1</td>
<td>&nbsp;</td>
</tr>
<tr><td>disable_os_cache</td>
<td>2</td>
<td>&nbsp;</td>
</tr>
<tr><td>write_through</td>
<td>3</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<a name="bandwidth_mixed_algo_t"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+bandwidth_mixed_algo_t&labels=documentation&body=Documentation+under+heading+%22enum+bandwidth_mixed_algo_t%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-bandwidth-mixed-algo-t">
<h2>enum bandwidth_mixed_algo_t</h2>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/settings_pack.hpp">libtorrent/settings_pack.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="8%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>prefer_tcp</td>
<td>0</td>
<td>disables the mixed mode bandwidth balancing</td>
</tr>
<tr><td>peer_proportional</td>
<td>1</td>
<td>does not throttle uTP, throttles TCP to the same proportion
of throughput as there are TCP connections</td>
</tr>
</tbody>
</table>
<a name="enc_policy"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+enc_policy&labels=documentation&body=Documentation+under+heading+%22enum+enc_policy%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-enc-policy">
<h2>enum enc_policy</h2>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/settings_pack.hpp">libtorrent/settings_pack.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="15%" />
<col width="8%" />
<col width="78%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>pe_forced</td>
<td>0</td>
<td>Only encrypted connections are allowed. Incoming connections that
are not encrypted are closed and if the encrypted outgoing
connection fails, a non-encrypted retry will not be made.</td>
</tr>
<tr><td>pe_enabled</td>
<td>1</td>
<td>encrypted connections are enabled, but non-encrypted connections
are allowed. An incoming non-encrypted connection will be accepted,
and if an outgoing encrypted connection fails, a non- encrypted
connection will be tried.</td>
</tr>
<tr><td>pe_disabled</td>
<td>2</td>
<td>only non-encrypted connections are allowed.</td>
</tr>
</tbody>
</table>
<a name="enc_level"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+enc_level&labels=documentation&body=Documentation+under+heading+%22enum+enc_level%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-enc-level">
<h2>enum enc_level</h2>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/settings_pack.hpp">libtorrent/settings_pack.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="26%" />
<col width="13%" />
<col width="60%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>pe_plaintext</td>
<td>1</td>
<td>use only plain text encryption</td>
</tr>
<tr><td>pe_rc4</td>
<td>2</td>
<td>use only RC4 encryption</td>
</tr>
<tr><td>pe_both</td>
<td>3</td>
<td>allow both</td>
</tr>
</tbody>
</table>
<a name="proxy_type_t"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+proxy_type_t&labels=documentation&body=Documentation+under+heading+%22enum+proxy_type_t%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-proxy-type-t">
<h2>enum proxy_type_t</h2>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/settings_pack.hpp">libtorrent/settings_pack.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="7%" />
<col width="81%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>none</td>
<td>0</td>
<td>No proxy server is used and all other fields are ignored.</td>
</tr>
<tr><td>socks4</td>
<td>1</td>
<td>The server is assumed to be a <a class="reference external" href="http://www.ufasoft.com/doc/socks4_protocol.htm">SOCKS4 server</a> that requires a
username.</td>
</tr>
<tr><td>socks5</td>
<td>2</td>
<td>The server is assumed to be a SOCKS5 server (<a class="reference external" href="http://www.faqs.org/rfcs/rfc1928.html">RFC 1928</a>) that does
not require any authentication. The username and password are
ignored.</td>
</tr>
<tr><td>socks5_pw</td>
<td>3</td>
<td>The server is assumed to be a SOCKS5 server that supports plain
text username and password authentication (<a class="reference external" href="http://www.faqs.org/rfcs/rfc1929.html">RFC 1929</a>). The
username and password specified may be sent to the proxy if it
requires.</td>
</tr>
<tr><td>http</td>
<td>4</td>
<td>The server is assumed to be an HTTP proxy. If the transport used
for the connection is non-HTTP, the server is assumed to support
the <a class="reference external" href="http://tools.ietf.org/html/draft-luotonen-web-proxy-tunneling-01">CONNECT</a> method. i.e. for web seeds and HTTP trackers, a plain
proxy will suffice. The proxy is assumed to not require
authorization. The username and password will not be used.</td>
</tr>
<tr><td>http_pw</td>
<td>5</td>
<td>The server is assumed to be an HTTP proxy that requires user
authorization. The username and password will be sent to the proxy.</td>
</tr>
</tbody>
</table>
<a name="min_memory_usage()"></a>
<a name="high_performance_seed()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:min_memory_usage%28%29+high_performance_seed%28%29&labels=documentation&body=Documentation+under+heading+%22min_memory_usage%28%29+high_performance_seed%28%29%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="min-memory-usage-high-performance-seed">
<h1>min_memory_usage() high_performance_seed()</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/session.hpp">libtorrent/session.hpp</a>&quot;</p>
<pre class="literal-block">
settings_pack <strong>min_memory_usage</strong> ();
settings_pack <strong>high_performance_seed</strong> ();
</pre>
<p>The default values of the <a class="reference external" href="reference-Session.html#session">session</a> settings are set for a regular
bittorrent client running on a desktop system. There are functions that
can set the <a class="reference external" href="reference-Session.html#session">session</a> settings to pre set settings for other environments.
These can be used for the basis, and should be tweaked to fit your needs
better.</p>
<p><tt class="docutils literal">min_memory_usage</tt> returns settings that will use the minimal amount of
RAM, at the potential expense of upload and download performance. It
adjusts the socket buffer sizes, disables the disk cache, lowers the send
buffer watermarks so that each connection only has at most one block in
use at any one time. It lowers the outstanding blocks send to the disk
I/O thread so that connections only have one block waiting to be flushed
to disk at any given time. It lowers the max number of peers in the peer
list for torrents. It performs multiple smaller reads when it hashes
pieces, instead of reading it all into memory before hashing.</p>
<p>This configuration is intended to be the starting point for embedded
devices. It will significantly reduce memory usage.</p>
<p><tt class="docutils literal">high_performance_seed</tt> returns settings optimized for a seed box,
serving many peers and that doesn't do any downloading. It has a 128 MB
disk cache and has a limit of 400 files in its file pool. It support fast
upload rates by allowing large send buffers.</p>
<a name="name_for_setting()"></a>
<a name="setting_by_name()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:name_for_setting%28%29+setting_by_name%28%29&labels=documentation&body=Documentation+under+heading+%22name_for_setting%28%29+setting_by_name%28%29%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="name-for-setting-setting-by-name">
<h1>name_for_setting() setting_by_name()</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/settings_pack.hpp">libtorrent/settings_pack.hpp</a>&quot;</p>
<pre class="literal-block">
char const* <strong>name_for_setting</strong> (int s);
int <strong>setting_by_name</strong> (string_view name);
</pre>
<p>converts a setting integer (from the enums string_types, int_types or
bool_types) to a string, and vice versa.</p>
<a name="default_settings()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:default_settings%28%29&labels=documentation&body=Documentation+under+heading+%22default_settings%28%29%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="default-settings">
<h1>default_settings()</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/settings_pack.hpp">libtorrent/settings_pack.hpp</a>&quot;</p>
<pre class="literal-block">
settings_pack <strong>default_settings</strong> ();
</pre>
<p>returns a <a class="reference external" href="reference-Settings.html#settings_pack">settings_pack</a> with every setting set to its default value</p>
<a name="generate_fingerprint()"></a><span class="report-issue">[<a href="http://github.com/arvidn/libtorrent/issues/new?title=docs:generate_fingerprint%28%29&labels=documentation&body=Documentation+under+heading+%22generate_fingerprint%28%29%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="generate-fingerprint">
<h1>generate_fingerprint()</h1>
<p>Declared in &quot;<a class="reference external" href="include/libtorrent/fingerprint.hpp">libtorrent/fingerprint.hpp</a>&quot;</p>
<pre class="literal-block">
std::string <strong>generate_fingerprint</strong> (std::string name
   , int major, int minor = 0, int revision = 0, int tag = 0);
</pre>
<p>This is a utility function to produce a client ID fingerprint formatted to
the most common convention. The fingerprint can be set via the
<tt class="docutils literal">peer_fingerprint</tt> setting, in <a class="reference external" href="reference-Settings.html#settings_pack">settings_pack</a>.</p>
<p>The name string should contain exactly two characters. These are the
characters unique to your client, used to identify it. Make sure not to
clash with anybody else. Here are some taken id's:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">id chars</th>
<th class="head">client</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>LT</td>
<td>libtorrent (default)</td>
</tr>
<tr><td>UT</td>
<td>uTorrent</td>
</tr>
<tr><td>UM</td>
<td>uTorrent Mac</td>
</tr>
<tr><td>qB</td>
<td>qBittorrent</td>
</tr>
<tr><td>BP</td>
<td>BitTorrent Pro</td>
</tr>
<tr><td>BT</td>
<td>BitTorrent</td>
</tr>
<tr><td>DE</td>
<td>Deluge</td>
</tr>
<tr><td>AZ</td>
<td>Azureus</td>
</tr>
<tr><td>TL</td>
<td>Tribler</td>
</tr>
</tbody>
</table>
<p>There's an informal directory of client id's <a class="reference external" href="http://wiki.theory.org/BitTorrentSpecification#peer_id">here</a>.</p>
<p>The <tt class="docutils literal">major</tt>, <tt class="docutils literal">minor</tt>, <tt class="docutils literal">revision</tt> and <tt class="docutils literal">tag</tt> parameters are used to
identify the version of your client.</p>
</div>

    </div>
    </div>
    <div id="gradient"></div>
    <div id="filler">
    <div id="footer">
    <div><a href="index.html">home</a></div>
    <div><a href="https://blog.libtorrent.org">blog</a></div>
    <div><a href="utp.html">uTP</a></div>
    <div><a href="https://sourceforge.net/projects/libtorrent/files/libtorrent/">download</a></div>
    <div><a href="reference.html">documentation</a></div>
    <div><a href="dht_store.html">DHT put extension</a></div>
    <div><a href="python_binding.html">python bindings</a></div>
    <div><a href="features-ref.html">features</a></div>
    <div><a href="dht_sec.html">DHT security extension</a></div>
    <div><a href="https://sourceforge.net/p/libtorrent/mailman/libtorrent-discuss/">mailing list archive</a></div>
    <div><a href="contributing.html">contributing</a></div>
    <div><a href="streaming.html">streaming</a></div>
    <div><a href="https://github.com/arvidn/libtorrent/issues">report a bug</a></div>
    <div><a href="building.html">building</a></div>
    <div><a href="bittorrent.pdf">bittorrent slides</a></div>
    </div>
	</div>

</div>
</body>
</html>
